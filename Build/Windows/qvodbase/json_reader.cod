; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	F:\Projects\Git\YFNet\trunk\Src\include\json\json_reader.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?max_digits10@?$numeric_limits@D@std@@2HB	; std::numeric_limits<char>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_W@std@@2HB	; std::numeric_limits<wchar_t>::max_digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_N@std@@2HB	; std::numeric_limits<bool>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?max_digits10@?$numeric_limits@C@std@@2HB	; std::numeric_limits<signed char>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?max_digits10@?$numeric_limits@E@std@@2HB	; std::numeric_limits<unsigned char>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?max_digits10@?$numeric_limits@F@std@@2HB	; std::numeric_limits<short>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?max_digits10@?$numeric_limits@G@std@@2HB	; std::numeric_limits<unsigned short>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?max_digits10@?$numeric_limits@H@std@@2HB	; std::numeric_limits<int>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?max_digits10@?$numeric_limits@I@std@@2HB	; std::numeric_limits<unsigned int>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?max_digits10@?$numeric_limits@J@std@@2HB	; std::numeric_limits<long>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?max_digits10@?$numeric_limits@K@std@@2HB	; std::numeric_limits<unsigned long>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_J@std@@2HB	; std::numeric_limits<__int64>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_K@std@@2HB	; std::numeric_limits<unsigned __int64>::max_digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?value@?$integral_constant@I$0A@@tr1@std@@2IB	; std::tr1::integral_constant<unsigned int,0>::value
PUBLIC	?_Rank@?$_Arithmetic_traits@_N@std@@2HB		; std::_Arithmetic_traits<bool>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@D@std@@2HB		; std::_Arithmetic_traits<char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@C@std@@2HB		; std::_Arithmetic_traits<signed char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@E@std@@2HB		; std::_Arithmetic_traits<unsigned char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@F@std@@2HB		; std::_Arithmetic_traits<short>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@G@std@@2HB		; std::_Arithmetic_traits<unsigned short>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@H@std@@2HB		; std::_Arithmetic_traits<int>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@I@std@@2HB		; std::_Arithmetic_traits<unsigned int>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@J@std@@2HB		; std::_Arithmetic_traits<long>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@K@std@@2HB		; std::_Arithmetic_traits<unsigned long>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@_J@std@@2HB		; std::_Arithmetic_traits<__int64>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@_K@std@@2HB		; std::_Arithmetic_traits<unsigned __int64>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@M@std@@2HB		; std::_Arithmetic_traits<float>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@N@std@@2HB		; std::_Arithmetic_traits<double>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@O@std@@2HB		; std::_Arithmetic_traits<long double>::_Rank
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?_EEM_DS@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@2HB ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_EEM_DS
PUBLIC	?_EEM_DS@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@2HB ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_EEM_DS
;	COMDAT ?_EEM_DS@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@2HB DD 01H ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_EEM_DS
CONST	ENDS
;	COMDAT ?_EEM_DS@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@2HB DD 04H ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_EEM_DS
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@O@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@O@std@@2HB DD 09H		; std::_Arithmetic_traits<long double>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@N@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@N@std@@2HB DD 08H		; std::_Arithmetic_traits<double>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@M@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@M@std@@2HB DD 07H		; std::_Arithmetic_traits<float>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_K@std@@2HB DD 06H		; std::_Arithmetic_traits<unsigned __int64>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_J@std@@2HB DD 06H		; std::_Arithmetic_traits<__int64>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@K@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@K@std@@2HB DD 05H		; std::_Arithmetic_traits<unsigned long>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@J@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@J@std@@2HB DD 05H		; std::_Arithmetic_traits<long>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@I@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@I@std@@2HB DD 04H		; std::_Arithmetic_traits<unsigned int>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@H@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@H@std@@2HB DD 04H		; std::_Arithmetic_traits<int>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@G@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@G@std@@2HB DD 03H		; std::_Arithmetic_traits<unsigned short>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@F@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@F@std@@2HB DD 03H		; std::_Arithmetic_traits<short>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@E@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@E@std@@2HB DD 02H		; std::_Arithmetic_traits<unsigned char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@C@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@C@std@@2HB DD 02H		; std::_Arithmetic_traits<signed char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@D@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@D@std@@2HB DD 02H		; std::_Arithmetic_traits<char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_N@std@@2HB DD 01H		; std::_Arithmetic_traits<bool>::_Rank
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@tr1@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@tr1@std@@2IB DD 00H	; std::tr1::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 08H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_K@std@@2HB DD 015H	; std::numeric_limits<unsigned __int64>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_J@std@@2HB DD 014H	; std::numeric_limits<__int64>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@K@std@@2HB DD 0bH	; std::numeric_limits<unsigned long>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@J@std@@2HB DD 0bH	; std::numeric_limits<long>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@I@std@@2HB DD 0bH	; std::numeric_limits<unsigned int>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@H@std@@2HB DD 0bH	; std::numeric_limits<int>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@G@std@@2HB DD 06H	; std::numeric_limits<unsigned short>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@F@std@@2HB DD 06H	; std::numeric_limits<short>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@E@std@@2HB DD 04H	; std::numeric_limits<unsigned char>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@C@std@@2HB DD 04H	; std::numeric_limits<signed char>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_N@std@@2HB DD 00H	; std::numeric_limits<bool>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_W@std@@2HB DD 06H	; std::numeric_limits<wchar_t>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@D@std@@2HB DD 04H	; std::numeric_limits<char>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 01H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogsp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 07		 je	 SHORT $LN1@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	59		 pop	 ecx
$LN1@scalar:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 56   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 58   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 62   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
EXTRN	_strlen:PROC
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 490  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 492  : 		}

  00003	5d		 pop	 ebp

; 491  : 		return (_CSTD strlen(_First));

  00004	e9 00 00 00 00	 jmp	 _strlen
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
EXTRN	_memcpy:PROC
; Function compile flags: /Ogsp
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 496  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 498  : 		}

  00003	5d		 pop	 ebp

; 497  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00004	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
EXTRN	_memmove:PROC
; Function compile flags: /Ogsp
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 516  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 518  : 		}

  00003	5d		 pop	 ebp

; 517  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00004	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAPADPADID@Z	; std::char_traits<char>::assign
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 521  : 		{	// assign _Count * _Ch to [_First, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 522  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00003	0f be 45 10	 movsx	 eax, BYTE PTR __Ch$[ebp]
  00007	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 _memset
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 523  : 		}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Ogsp
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 526  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 527  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 00		 mov	 al, BYTE PTR [eax]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000b	88 01		 mov	 BYTE PTR [ecx], al

; 528  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
; Function compile flags: /Ogsp
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT

; 541  : 		{	// convert metacharacter to character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 542  : 		return ((_Elem)_Meta);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00006	8a 00		 mov	 al, BYTE PTR [eax]

; 543  : 		}

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
; Function compile flags: /Ogsp
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT

; 546  : 		{	// convert character to metacharacter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 547  : 		return ((unsigned char)_Ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00006	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 548  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
; Function compile flags: /Ogsp
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 552  : 		{	// test for metacharacter equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 553  : 		return (_Left == _Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000d	f7 d8		 neg	 eax
  0000f	1b c0		 sbb	 eax, eax
  00011	40		 inc	 eax

; 554  : 		}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
; Function compile flags: /Ogsp
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 563  : 		return (EOF);

  00000	83 c8 ff	 or	 eax, -1

; 564  : 		}

  00003	c3		 ret	 0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 65   : 		{	// construct from pointers

  00000	8b c1		 mov	 eax, ecx
  00002	83 20 00	 and	 DWORD PTR [eax], 0
  00005	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 66   : 		}

  00009	c3		 ret	 0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
; Function compile flags: /Ogsp
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 77   : 		{	// construct childless container

  00000	8b c1		 mov	 eax, ecx
  00002	83 20 00	 and	 DWORD PTR [eax], 0

; 78   : 		}

  00005	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
PUBLIC	??0_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::_Iterator_base12
; Function compile flags: /Ogsp
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 111  : 		{	// construct orphaned iterator

  00000	8b c1		 mov	 eax, ecx
  00002	83 20 00	 and	 DWORD PTR [eax], 0
  00005	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 112  : 		}

  00009	c3		 ret	 0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
PUBLIC	??1_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::~_Iterator_base12
; Function compile flags: /Ogsp
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 129  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 130  : 		_Lockit _Lock(_LOCK_DEBUG);
; 131  : 		_Orphan_me();
; 132  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 133  : 		}

  00000	c3		 ret	 0
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
; Function compile flags: /Ogsp
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 136  : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 137  : 		if (_Parent != 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parent$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 04		 je	 SHORT $LN1@Adopt

; 138  : 			{	// have a parent, do adoption
; 139  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 140  : 
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 			if (_Myproxy != _Parent_proxy)
; 143  : 				{	// change parentage
; 144  : 				_Lockit _Lock(_LOCK_DEBUG);
; 145  : 				_Orphan_me();
; 146  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 147  : 				_Parent_proxy->_Myfirstiter = this;
; 148  : 				_Myproxy = _Parent_proxy;
; 149  : 				}
; 150  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 151  : 			_Myproxy = _Parent_proxy;

  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@Adopt:

; 152  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 153  : 			}
; 154  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
PUBLIC	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
; Function compile flags: /Ogsp
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 163  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	75 01		 jne	 SHORT $LN3@Getcont

; 164  : 		}

  00006	c3		 ret	 0
$LN3@Getcont:

; 163  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00007	8b 00		 mov	 eax, DWORD PTR [eax]

; 164  : 		}

  00009	c3		 ret	 0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
; Function compile flags: /Ogsp
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 195  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 196  : 	if (_Myproxy != 0)
; 197  : 		{	// proxy allocated, drain it
; 198  : 		_Lockit _Lock(_LOCK_DEBUG);
; 199  : 
; 200  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 201  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)
; 202  : 			(*_Pnext)->_Myproxy = 0;
; 203  : 		_Myproxy->_Myfirstiter = 0;
; 204  : 		}
; 205  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 206  : 	}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??0runtime_error@std@@QAE@PBD@Z			; std::runtime_error::runtime_error
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0runtime_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@PBD@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 170  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 171  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@PBD@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
; Function compile flags: /Ogsp
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
EXTRN	__Getctype:PROC
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T40856 = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 117  : 		{	// return ctype stuff

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 118  : 		return (::_Getctype());

  00007	8d 45 f0	 lea	 eax, DWORD PTR $T40856[ebp]
  0000a	57		 push	 edi
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __Getctype
  00011	8b f0		 mov	 esi, eax
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00016	8b f8		 mov	 edi, eax
  00018	a5		 movsd
  00019	a5		 movsd
  0001a	a5		 movsd
  0001b	59		 pop	 ecx
  0001c	a5		 movsd
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi

; 119  : 		}

  0001f	c9		 leave
  00020	c2 04 00	 ret	 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$15107 = -4					; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 75   : 			{	// get stamp, with lazy allocation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 76   : 			if (_Id == 0)

  00007	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0000a	75 24		 jne	 SHORT $LN2@operator

; 77   : 				{	// still zero, allocate stamp
; 78   : 				_BEGIN_LOCK(_LOCK_LOCALE)

  0000c	6a 00		 push	 0
  0000e	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$15107[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 79   : 					if (_Id == 0)

  00016	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00019	75 0d		 jne	 SHORT $LN1@operator

; 80   : 						_Id = ++_Id_cnt;

  0001b	ff 05 00 00 00
	00		 inc	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00026	89 06		 mov	 DWORD PTR [esi], eax
$LN1@operator:

; 81   : 				_END_LOCK()

  00028	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$15107[ebp]
  0002b	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
$LN2@operator:

; 82   : 				}
; 83   : 			return (_Id);

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	5e		 pop	 esi

; 84   : 			}

  00033	c9		 leave
  00034	c3		 ret	 0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
PUBLIC	?_Incref@facet@locale@std@@QAEXXZ		; std::locale::facet::_Incref
; Function compile flags: /Ogsp
;	COMDAT ?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
__Lock$15113 = -4					; size = 4
?_Incref@facet@locale@std@@QAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 111  : 			{	// safely increment the reference count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 112  : 			_BEGIN_LOCK(_LOCK_LOCALE)

  00007	6a 00		 push	 0
  00009	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$15113[ebp]
  0000c	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 113  : 				if (_Refs < (size_t)(-1))

  00011	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00014	83 f8 ff	 cmp	 eax, -1
  00017	73 04		 jae	 SHORT $LN1@Incref

; 114  : 					++_Refs;

  00019	40		 inc	 eax
  0001a	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN1@Incref:

; 115  : 			_END_LOCK()

  0001d	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$15113[ebp]
  00020	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00025	5e		 pop	 esi

; 116  : 			}

  00026	c9		 leave
  00027	c3		 ret	 0
?_Incref@facet@locale@std@@QAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
PUBLIC	?_Decref@facet@locale@std@@QAEPAV123@XZ		; std::locale::facet::_Decref
; Function compile flags: /Ogsp
;	COMDAT ?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT
__Lock$15118 = -4					; size = 4
?_Decref@facet@locale@std@@QAEPAV123@XZ PROC		; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 119  : 			{	// safely decrement the reference count, return this when dead

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 120  : 			_BEGIN_LOCK(_LOCK_LOCALE)

  00008	6a 00		 push	 0
  0000a	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$15118[ebp]
  0000d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 121  : 				if (0 < _Refs && _Refs < (size_t)(-1))

  00012	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00015	85 c0		 test	 eax, eax
  00017	74 09		 je	 SHORT $LN1@Decref
  00019	83 f8 ff	 cmp	 eax, -1
  0001c	73 04		 jae	 SHORT $LN1@Decref

; 122  : 					--_Refs;

  0001e	48		 dec	 eax
  0001f	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN1@Decref:

; 123  : 				return (_Refs == 0 ? this : 0);

  00022	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00025	f7 de		 neg	 esi
  00027	1b f6		 sbb	 esi, esi
  00029	f7 d6		 not	 esi
  0002b	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$15118[ebp]
  0002e	23 f7		 and	 esi, edi
  00030	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00035	5f		 pop	 edi
  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi

; 124  : 			_END_LOCK()
; 125  : 			}

  00039	c9		 leave
  0003a	c3		 ret	 0
?_Decref@facet@locale@std@@QAEPAV123@XZ ENDP		; std::locale::facet::_Decref
_TEXT	ENDS
PUBLIC	?_Register@facet@locale@std@@QAEXXZ		; std::locale::facet::_Register
EXTRN	?_Facet_Register@facet@locale@std@@CAXPAV123@@Z:PROC ; std::locale::facet::_Facet_Register
; Function compile flags: /Ogsp
;	COMDAT ?_Register@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
?_Register@facet@locale@std@@QAEXXZ PROC		; std::locale::facet::_Register, COMDAT
; _this$ = ecx

; 129  :  #if defined(_M_CEE)
; 130  : 			_Facet_Register_m(this);
; 131  : 
; 132  :  #else /* defined(_M_CEE) */
; 133  : 			_Facet_Register(this);

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 ?_Facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::_Facet_Register
  00006	59		 pop	 ecx

; 134  :  #endif /* defined(_M_CEE) */
; 135  : 			}

  00007	c3		 ret	 0
?_Register@facet@locale@std@@QAEXXZ ENDP		; std::locale::facet::_Register
_TEXT	ENDS
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??1facet@locale@std@@UAE@XZ			; std::locale::facet::~facet
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Efacet@locale@std@@UAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@UAEPAXI@Z
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT
??1facet@locale@std@@UAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 164  : 			{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@

; 165  : 			}

  00006	c3		 ret	 0
??1facet@locale@std@@UAE@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
; Function compile flags: /Ogsp
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 170  : 			{	// construct with initial reference count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Initrefs$[ebp]
  00008	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
  0000e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 171  : 			}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
; Function compile flags: /Ogsp
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 309  : 		{	// construct by copying

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 0e		 mov	 DWORD PTR [esi], ecx

; 310  : 		_Ptr->_Incref();

  0000d	e8 00 00 00 00	 call	 ?_Incref@facet@locale@std@@QAEXXZ ; std::locale::facet::_Incref

; 311  : 		}

  00012	8b c6		 mov	 eax, esi
  00014	5e		 pop	 esi
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
_TEXT	ENDS
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
; Function compile flags: /Ogsp
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 410  : 		if (_Ptr != 0)

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	85 c9		 test	 ecx, ecx
  00004	74 11		 je	 SHORT $LN4@locale

; 411  : 			_DELETE_CRT(_Ptr->_Decref());

  00006	e8 00 00 00 00	 call	 ?_Decref@facet@locale@std@@QAEPAV123@XZ ; std::locale::facet::_Decref
  0000b	85 c0		 test	 eax, eax
  0000d	74 08		 je	 SHORT $LN4@locale
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	6a 01		 push	 1
  00013	8b c8		 mov	 ecx, eax
  00015	ff 12		 call	 DWORD PTR [edx]
$LN4@locale:

; 412  : 		}

  00017	c3		 ret	 0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
; Function compile flags: /Ogsp
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 436  : 		{	// look up a facet in locale object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 437  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 438  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR __Id$[ebp]
  00009	3b 71 0c	 cmp	 esi, DWORD PTR [ecx+12]
  0000c	73 08		 jae	 SHORT $LN6@Getfacet
  0000e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00011	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00014	eb 02		 jmp	 SHORT $LN7@Getfacet
$LN6@Getfacet:
  00016	33 c0		 xor	 eax, eax
$LN7@Getfacet:

; 439  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00018	85 c0		 test	 eax, eax
  0001a	75 19		 jne	 SHORT $LN1@Getfacet
  0001c	38 41 14	 cmp	 BYTE PTR [ecx+20], al
  0001f	74 14		 je	 SHORT $LN1@Getfacet

; 440  : 			return (_Facptr);	// found facet or not transparent
; 441  : 		else
; 442  : 			{	// look in current locale
; 443  : 			locale::_Locimp *_Ptr = _Getgloballocale();

  00021	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 444  : 			return (_Id < _Ptr->_Facetcount
; 445  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 446  : 				: 0);	// no entry in current locale

  00026	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  00029	73 08		 jae	 SHORT $LN8@Getfacet
  0002b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002e	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00031	eb 02		 jmp	 SHORT $LN1@Getfacet
$LN8@Getfacet:
  00033	33 c0		 xor	 eax, eax
$LN1@Getfacet:
  00035	5e		 pop	 esi

; 447  : 			}
; 448  : 		}

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_Gfacet@locale@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@UAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00010	74 07		 je	 SHORT $LN1@scalar@2
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	59		 pop	 ecx
$LN1@scalar@2:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??_Gfacet@locale@std@@UAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 2011 : 		{	// default constructor

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Refs$[ebp]
  00008	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@

; 2012 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
; Function compile flags: /Ogsp
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 2016 : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
  00006	c3		 ret	 0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00010	74 07		 je	 SHORT $LN1@scalar@3
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	59		 pop	 ecx
$LN1@scalar@3:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?is@?$ctype@D@std@@QBE_NFD@Z			; std::ctype<char>::is
; Function compile flags: /Ogsp
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 1
?is@?$ctype@D@std@@QBE_NFD@Z PROC			; std::ctype<char>::is, COMDAT
; _this$ = ecx

; 2271 : 		{	// test if element fits any mask classifications

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2272 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

  00003	0f b6 45 0c	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00007	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000a	66 8b 55 08	 mov	 dx, WORD PTR __Maskval$[ebp]
  0000e	66 85 14 41	 test	 WORD PTR [ecx+eax*2], dx
  00012	6a 00		 push	 0
  00014	58		 pop	 eax
  00015	0f 95 c0	 setne	 al

; 2273 : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?is@?$ctype@D@std@@QBE_NFD@Z ENDP			; std::ctype<char>::is
_TEXT	ENDS
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
; Function compile flags: /Ogsp
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T40929 = -16						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 2399 : 		{	// initialize from _Lobj

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 2400 : 		_Ctype = _Lobj._Getctype();

  00008	8d 45 f0	 lea	 eax, DWORD PTR $T40929[ebp]
  0000b	50		 push	 eax
  0000c	8b f9		 mov	 edi, ecx
  0000e	e8 00 00 00 00	 call	 __Getctype
  00013	83 c7 08	 add	 edi, 8
  00016	8b f0		 mov	 esi, eax
  00018	a5		 movsd
  00019	a5		 movsd
  0001a	a5		 movsd
  0001b	59		 pop	 ecx
  0001c	a5		 movsd
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi

; 2401 : 		}

  0001f	c9		 leave
  00020	c2 04 00	 ret	 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
_TEXT	ENDS
PUBLIC	??0error_code@std@@QAE@HABVerror_category@1@@Z	; std::error_code::error_code
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\system_error
;	COMDAT ??0error_code@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_code@std@@QAE@HABVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT
; _this$ = ecx

; 204  : 		{	// construct from error code and category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Cat$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 205  : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0error_code@std@@QAE@HABVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@31@@Z ; std::make_error_code
EXTRN	?iostream_category@std@@YAABVerror_category@1@XZ:PROC ; std::iostream_category
; Function compile flags: /Ogsp
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@31@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errno$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@31@@Z PROC ; std::make_error_code, COMDAT

; 446  : 	{	// make an error_code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 	return (error_code(_Errno, iostream_category()));

  00003	e8 00 00 00 00	 call	 ?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
  00008	8b 55 0c	 mov	 edx, DWORD PTR __Errno$[ebp]
  0000b	8b c8		 mov	 ecx, eax
  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00010	89 10		 mov	 DWORD PTR [eax], edx
  00012	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 448  : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@31@@Z ENDP ; std::make_error_code
_TEXT	ENDS
PUBLIC	?_Makestr@system_error@std@@AAEXXZ		; std::system_error::_Makestr
; Function compile flags: /Ogsp
;	COMDAT ?_Makestr@system_error@std@@AAEXXZ
_TEXT	SEGMENT
?_Makestr@system_error@std@@AAEXXZ PROC			; std::system_error::_Makestr, COMDAT
; _this$ = ecx

; 563  : //		_Mymes = this->runtime_error::what();
; 564  : //		if (!_Mymes.empty())
; 565  : //			_Mymes.append(": ");
; 566  : //		_Mymes.append(_Mycode.message());
; 567  : 		}

  00000	c3		 ret	 0
?_Makestr@system_error@std@@AAEXXZ ENDP			; std::system_error::_Makestr
_TEXT	ENDS
PUBLIC	??1system_error@std@@UAE@XZ			; std::system_error::~system_error
; Function compile flags: /Ogsp
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 336  : 		return (_Mystate);

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 337  : 		}

  00003	c3		 ret	 0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
; Function compile flags: /Ogsp
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 358  : 		return (rdstate() == goodbit);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  00005	0f 94 c0	 sete	 al

; 359  : 		}

  00008	c3		 ret	 0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
PUBLIC	?fail@ios_base@std@@QBE_NXZ			; std::ios_base::fail
; Function compile flags: /Ogsp
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?fail@ios_base@std@@QBE_NXZ PROC			; std::ios_base::fail, COMDAT
; _this$ = ecx

; 368  : 		return (((int)rdstate()
; 369  : 			& ((int)badbit | (int)failbit)) != 0);

  00000	f6 41 0c 06	 test	 BYTE PTR [ecx+12], 6
  00004	6a 00		 push	 0
  00006	58		 pop	 eax
  00007	0f 95 c0	 setne	 al

; 370  : 		}

  0000a	c3		 ret	 0
?fail@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::fail
_TEXT	ENDS
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
; Function compile flags: /Ogsp
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 395  : 		return (_Fmtfl);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 396  : 		}

  00003	c3		 ret	 0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
; Function compile flags: /Ogsp
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
$T40973 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 451  : 		{	// get locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 452  : 		return (*_Ploc);

  00004	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	83 65 fc 00	 and	 DWORD PTR $T40973[ebp], 0
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00011	89 0e		 mov	 DWORD PTR [esi], ecx
  00013	e8 00 00 00 00	 call	 ?_Incref@facet@locale@std@@QAEXXZ ; std::locale::facet::_Incref
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi

; 453  : 		}

  0001b	c9		 leave
  0001c	c2 04 00	 ret	 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
_TEXT	ENDS
PUBLIC	??0Features@Json@@QAE@XZ			; Json::Features::Features
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
;	COMDAT ??0Features@Json@@QAE@XZ
_TEXT	SEGMENT
??0Features@Json@@QAE@XZ PROC				; Json::Features::Features, COMDAT
; _this$ = ecx

; 22   : {

  00000	8b c1		 mov	 eax, ecx
  00002	66 c7 00 01 00	 mov	 WORD PTR [eax], 1

; 23   : }

  00007	c3		 ret	 0
??0Features@Json@@QAE@XZ ENDP				; Json::Features::Features
_TEXT	ENDS
PUBLIC	?all@Features@Json@@SA?AV12@XZ			; Json::Features::all
; Function compile flags: /Ogsp
;	COMDAT ?all@Features@Json@@SA?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?all@Features@Json@@SA?AV12@XZ PROC			; Json::Features::all, COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 29   :    return Features();

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	66 c7 00 01 00	 mov	 WORD PTR [eax], 1

; 30   : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?all@Features@Json@@SA?AV12@XZ ENDP			; Json::Features::all
_TEXT	ENDS
PUBLIC	?strictMode@Features@Json@@SA?AV12@XZ		; Json::Features::strictMode
; Function compile flags: /Ogsp
;	COMDAT ?strictMode@Features@Json@@SA?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?strictMode@Features@Json@@SA?AV12@XZ PROC		; Json::Features::strictMode, COMDAT

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 36   :    Features features;
; 37   :    features.allowComments_ = false;

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	66 c7 00 00 01	 mov	 WORD PTR [eax], 256	; 00000100H

; 38   :    features.strictRoot_ = true;
; 39   :    return features;
; 40   : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?strictMode@Features@Json@@SA?AV12@XZ ENDP		; Json::Features::strictMode
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?in@Json@@YA_NDDDDD@Z
_TEXT	SEGMENT
_c1$ = 8						; size = 1
_c2$ = 12						; size = 1
_c3$ = 16						; size = 1
_c4$ = 20						; size = 1
?in@Json@@YA_NDDDDD@Z PROC				; Json::in, COMDAT
; _c$ = eax

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4;

  00003	3a 45 08	 cmp	 al, BYTE PTR _c1$[ebp]
  00006	74 13		 je	 SHORT $LN3@in
  00008	3a 45 0c	 cmp	 al, BYTE PTR _c2$[ebp]
  0000b	74 0e		 je	 SHORT $LN3@in
  0000d	3a 45 10	 cmp	 al, BYTE PTR _c3$[ebp]
  00010	74 09		 je	 SHORT $LN3@in
  00012	3a 45 14	 cmp	 al, BYTE PTR _c4$[ebp]
  00015	74 04		 je	 SHORT $LN3@in
  00017	33 c0		 xor	 eax, eax

; 50   : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN3@in:

; 49   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4;

  0001b	33 c0		 xor	 eax, eax
  0001d	40		 inc	 eax

; 50   : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?in@Json@@YA_NDDDDD@Z ENDP				; Json::in
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?in@Json@@YA_NDDDDDD@Z
_TEXT	SEGMENT
_c1$ = 8						; size = 1
_c2$ = 12						; size = 1
_c3$ = 16						; size = 1
_c4$ = 20						; size = 1
_c5$ = 24						; size = 1
?in@Json@@YA_NDDDDDD@Z PROC				; Json::in, COMDAT
; _c$ = eax

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4  ||  c == c5;

  00003	3a 45 08	 cmp	 al, BYTE PTR _c1$[ebp]
  00006	74 18		 je	 SHORT $LN3@in@2
  00008	3a 45 0c	 cmp	 al, BYTE PTR _c2$[ebp]
  0000b	74 13		 je	 SHORT $LN3@in@2
  0000d	3a 45 10	 cmp	 al, BYTE PTR _c3$[ebp]
  00010	74 0e		 je	 SHORT $LN3@in@2
  00012	3a 45 14	 cmp	 al, BYTE PTR _c4$[ebp]
  00015	74 09		 je	 SHORT $LN3@in@2
  00017	3a 45 18	 cmp	 al, BYTE PTR _c5$[ebp]
  0001a	74 04		 je	 SHORT $LN3@in@2
  0001c	33 c0		 xor	 eax, eax

; 56   : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
$LN3@in@2:

; 55   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4  ||  c == c5;

  00020	33 c0		 xor	 eax, eax
  00022	40		 inc	 eax

; 56   : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?in@Json@@YA_NDDDDDD@Z ENDP				; Json::in
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?containsNewLine@Json@@YA_NPBD0@Z
_TEXT	SEGMENT
_end$ = 8						; size = 4
?containsNewLine@Json@@YA_NPBD0@Z PROC			; Json::containsNewLine, COMDAT
; _begin$ = eax

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   :    for ( ;begin < end; ++begin )

  00003	eb 0d		 jmp	 SHORT $LN11@containsNe
$LL5@containsNe:

; 64   :       if ( *begin == '\n'  ||  *begin == '\r' )

  00005	8a 08		 mov	 cl, BYTE PTR [eax]
  00007	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  0000a	74 0f		 je	 SHORT $LN9@containsNe
  0000c	80 f9 0d	 cmp	 cl, 13			; 0000000dH
  0000f	74 0a		 je	 SHORT $LN9@containsNe

; 63   :    for ( ;begin < end; ++begin )

  00011	40		 inc	 eax
$LN11@containsNe:
  00012	3b 45 08	 cmp	 eax, DWORD PTR _end$[ebp]
  00015	72 ee		 jb	 SHORT $LL5@containsNe

; 66   :    return false;

  00017	32 c0		 xor	 al, al

; 67   : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN9@containsNe:

; 65   :          return true;

  0001b	b0 01		 mov	 al, 1

; 67   : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?containsNewLine@Json@@YA_NPBD0@Z ENDP			; Json::containsNewLine
_TEXT	ENDS
PUBLIC	?skipSpaces@Reader@Json@@AAEXXZ			; Json::Reader::skipSpaces
; Function compile flags: /Ogsp
;	COMDAT ?skipSpaces@Reader@Json@@AAEXXZ
_TEXT	SEGMENT
?skipSpaces@Reader@Json@@AAEXXZ PROC			; Json::Reader::skipSpaces, COMDAT
; _this$ = ecx

; 351  :    while ( current_ != end_ )

  00000	eb 1d		 jmp	 SHORT $LN10@skipSpaces
$LL5@skipSpaces:

; 352  :    {
; 353  :       Char c = *current_;

  00002	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  00005	8a 10		 mov	 dl, BYTE PTR [eax]

; 354  :       if ( c == ' '  ||  c == '\t'  ||  c == '\r'  ||  c == '\n' )

  00007	80 fa 20	 cmp	 dl, 32			; 00000020H
  0000a	74 0f		 je	 SHORT $LN2@skipSpaces
  0000c	80 fa 09	 cmp	 dl, 9
  0000f	74 0a		 je	 SHORT $LN2@skipSpaces
  00011	80 fa 0d	 cmp	 dl, 13			; 0000000dH
  00014	74 05		 je	 SHORT $LN2@skipSpaces
  00016	80 fa 0a	 cmp	 dl, 10			; 0000000aH
  00019	75 0c		 jne	 SHORT $LN3@skipSpaces
$LN2@skipSpaces:

; 355  :          ++current_;

  0001b	40		 inc	 eax
  0001c	89 41 54	 mov	 DWORD PTR [ecx+84], eax
$LN10@skipSpaces:

; 351  :    while ( current_ != end_ )

  0001f	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  00022	3b 41 50	 cmp	 eax, DWORD PTR [ecx+80]
  00025	75 db		 jne	 SHORT $LL5@skipSpaces
$LN3@skipSpaces:

; 356  :       else
; 357  :          break;
; 358  :    }
; 359  : }

  00027	c3		 ret	 0
?skipSpaces@Reader@Json@@AAEXXZ ENDP			; Json::Reader::skipSpaces
_TEXT	ENDS
PUBLIC	?match@Reader@Json@@AAE_NPBDH@Z			; Json::Reader::match
; Function compile flags: /Ogsp
;	COMDAT ?match@Reader@Json@@AAE_NPBDH@Z
_TEXT	SEGMENT
_pattern$ = 8						; size = 4
_patternLength$ = 12					; size = 4
?match@Reader@Json@@AAE_NPBDH@Z PROC			; Json::Reader::match, COMDAT
; _this$ = ecx

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 366  :    if ( end_ - current_ < patternLength )

  00006	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  00009	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  0000c	57		 push	 edi
  0000d	8b 7d 0c	 mov	 edi, DWORD PTR _patternLength$[ebp]
  00010	2b c2		 sub	 eax, edx
  00012	3b c7		 cmp	 eax, edi
  00014	7d 04		 jge	 SHORT $LN4@match

; 367  :       return false;

  00016	32 c0		 xor	 al, al
  00018	eb 1f		 jmp	 SHORT $LN5@match
$LN4@match:
  0001a	53		 push	 ebx

; 368  :    int index = patternLength;

  0001b	8b c7		 mov	 eax, edi

; 369  :    while ( index-- )

  0001d	85 ff		 test	 edi, edi
  0001f	74 10		 je	 SHORT $LN9@match
$LL3@match:

; 370  :       if ( current_[index] != pattern[index] )

  00021	8b 5d 08	 mov	 ebx, DWORD PTR _pattern$[ebp]
  00024	48		 dec	 eax
  00025	8a 0c 02	 mov	 cl, BYTE PTR [edx+eax]
  00028	3a 0c 18	 cmp	 cl, BYTE PTR [eax+ebx]
  0002b	75 12		 jne	 SHORT $LN8@match

; 369  :    while ( index-- )

  0002d	85 c0		 test	 eax, eax
  0002f	75 f0		 jne	 SHORT $LL3@match
$LN9@match:

; 372  :    current_ += patternLength;

  00031	03 d7		 add	 edx, edi
  00033	89 56 54	 mov	 DWORD PTR [esi+84], edx

; 373  :    return true;

  00036	b0 01		 mov	 al, 1
$LN10@match:
  00038	5b		 pop	 ebx
$LN5@match:
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi

; 374  : }

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN8@match:

; 371  :          return false;

  0003f	32 c0		 xor	 al, al
  00041	eb f5		 jmp	 SHORT $LN10@match
?match@Reader@Json@@AAE_NPBDH@Z ENDP			; Json::Reader::match
_TEXT	ENDS
PUBLIC	?readNumber@Reader@Json@@AAEXXZ			; Json::Reader::readNumber
; Function compile flags: /Ogsp
;	COMDAT ?readNumber@Reader@Json@@AAEXXZ
_TEXT	SEGMENT
?readNumber@Reader@Json@@AAEXXZ PROC			; Json::Reader::readNumber, COMDAT
; _this$ = ecx

; 454  :    while ( current_ != end_ )

  00000	eb 2c		 jmp	 SHORT $LN16@readNumber
$LL4@readNumber:

; 455  :    {
; 456  :       if ( !(*current_ >= '0'  &&  *current_ <= '9')  &&
; 457  :            !in( *current_, '.', 'e', 'E', '+', '-' ) )

  00002	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  00005	8a 10		 mov	 dl, BYTE PTR [eax]
  00007	80 fa 30	 cmp	 dl, 48			; 00000030H
  0000a	7c 05		 jl	 SHORT $LN1@readNumber
  0000c	80 fa 39	 cmp	 dl, 57			; 00000039H
  0000f	7e 19		 jle	 SHORT $LN9@readNumber
$LN1@readNumber:
  00011	80 fa 2e	 cmp	 dl, 46			; 0000002eH
  00014	74 14		 je	 SHORT $LN9@readNumber
  00016	80 fa 65	 cmp	 dl, 101			; 00000065H
  00019	74 0f		 je	 SHORT $LN9@readNumber
  0001b	80 fa 45	 cmp	 dl, 69			; 00000045H
  0001e	74 0a		 je	 SHORT $LN9@readNumber
  00020	80 fa 2b	 cmp	 dl, 43			; 0000002bH
  00023	74 05		 je	 SHORT $LN9@readNumber
  00025	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  00028	75 0c		 jne	 SHORT $LN14@readNumber
$LN9@readNumber:

; 458  :          break;
; 459  :       ++current_;

  0002a	40		 inc	 eax
  0002b	89 41 54	 mov	 DWORD PTR [ecx+84], eax
$LN16@readNumber:

; 454  :    while ( current_ != end_ )

  0002e	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  00031	3b 41 50	 cmp	 eax, DWORD PTR [ecx+80]
  00034	75 cc		 jne	 SHORT $LL4@readNumber
$LN14@readNumber:

; 460  :    }
; 461  : }

  00036	c3		 ret	 0
?readNumber@Reader@Json@@AAEXXZ ENDP			; Json::Reader::readNumber
_TEXT	ENDS
PUBLIC	?getNextChar@Reader@Json@@AAEDXZ		; Json::Reader::getNextChar
; Function compile flags: /Ogsp
;	COMDAT ?getNextChar@Reader@Json@@AAEDXZ
_TEXT	SEGMENT
?getNextChar@Reader@Json@@AAEDXZ PROC			; Json::Reader::getNextChar, COMDAT
; _this$ = ecx

; 810  :    if ( current_ == end_ )

  00000	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00003	3b 51 50	 cmp	 edx, DWORD PTR [ecx+80]
  00006	75 03		 jne	 SHORT $LN1@getNextCha

; 811  :       return 0;

  00008	32 c0		 xor	 al, al

; 813  : }

  0000a	c3		 ret	 0
$LN1@getNextCha:

; 812  :    return *current_++;

  0000b	8a 02		 mov	 al, BYTE PTR [edx]
  0000d	42		 inc	 edx
  0000e	89 51 54	 mov	 DWORD PTR [ecx+84], edx

; 813  : }

  00011	c3		 ret	 0
?getNextChar@Reader@Json@@AAEDXZ ENDP			; Json::Reader::getNextChar
_TEXT	ENDS
PUBLIC	?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ; Json::Reader::getLocationLineAndColumn
; Function compile flags: /Ogsp
;	COMDAT ?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z
_TEXT	SEGMENT
_location$ = 8						; size = 4
_line$ = 12						; size = 4
_column$ = 16						; size = 4
?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z PROC ; Json::Reader::getLocationLineAndColumn, COMDAT
; _this$ = ecx

; 820  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 821  :    Location current = begin_;

  00003	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]

; 822  :    Location lastLineStart = current;
; 823  :    line = 0;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _line$[ebp]
  00009	83 20 00	 and	 DWORD PTR [eax], 0
  0000c	56		 push	 esi

; 824  :    while ( current < location  &&  current != end_ )

  0000d	8b 75 08	 mov	 esi, DWORD PTR _location$[ebp]
  00010	57		 push	 edi
  00011	8b fa		 mov	 edi, edx
  00013	3b d6		 cmp	 edx, esi
  00015	73 24		 jae	 SHORT $LN5@getLocatio
  00017	53		 push	 ebx
$LL6@getLocatio:
  00018	3b 51 50	 cmp	 edx, DWORD PTR [ecx+80]
  0001b	74 1d		 je	 SHORT $LN10@getLocatio

; 825  :    {
; 826  :       Char c = *current++;

  0001d	8a 1a		 mov	 bl, BYTE PTR [edx]
  0001f	42		 inc	 edx

; 827  :       if ( c == '\r' )

  00020	80 fb 0d	 cmp	 bl, 13			; 0000000dH
  00023	75 08		 jne	 SHORT $LN4@getLocatio

; 828  :       {
; 829  :          if ( *current == '\n' )

  00025	80 3a 0a	 cmp	 BYTE PTR [edx], 10	; 0000000aH
  00028	75 08		 jne	 SHORT $LN3@getLocatio

; 830  :             ++current;

  0002a	42		 inc	 edx

; 831  :          lastLineStart = current;
; 832  :          ++line;

  0002b	eb 05		 jmp	 SHORT $LN3@getLocatio
$LN4@getLocatio:

; 833  :       }
; 834  :       else if ( c == '\n' )

  0002d	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00030	75 04		 jne	 SHORT $LN1@getLocatio
$LN3@getLocatio:

; 835  :       {
; 836  :          lastLineStart = current;
; 837  :          ++line;

  00032	ff 00		 inc	 DWORD PTR [eax]
  00034	8b fa		 mov	 edi, edx
$LN1@getLocatio:

; 824  :    while ( current < location  &&  current != end_ )

  00036	3b d6		 cmp	 edx, esi
  00038	72 de		 jb	 SHORT $LL6@getLocatio
$LN10@getLocatio:
  0003a	5b		 pop	 ebx
$LN5@getLocatio:

; 838  :       }
; 839  :    }
; 840  :    // column & line start at 1
; 841  :    column = int(location - lastLineStart) + 1;

  0003b	8b 4d 10	 mov	 ecx, DWORD PTR _column$[ebp]
  0003e	2b f7		 sub	 esi, edi
  00040	46		 inc	 esi
  00041	89 31		 mov	 DWORD PTR [ecx], esi

; 842  :    ++line;

  00043	ff 00		 inc	 DWORD PTR [eax]
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi

; 843  : }

  00047	5d		 pop	 ebp
  00048	c2 0c 00	 ret	 12			; 0000000cH
?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ENDP ; Json::Reader::getLocationLineAndColumn
_TEXT	ENDS
PUBLIC	??1?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 1506 : 		return (this->_Mysize);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1507 : 		}

  00003	c3		 ret	 0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogsp
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1511 : 		return (this->_Mysize);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1512 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
; Function compile flags: /Ogsp
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 1550 : 		return (this->_Mysize == 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00005	0f 94 c0	 sete	 al

; 1551 : 		}

  00008	c3		 ret	 0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
PUBLIC	??0?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::_Yarn<char>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??0?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT
; _this$ = ecx

; 3315 : 		{	// default construct

  00000	8b c1		 mov	 eax, ecx
  00002	83 20 00	 and	 DWORD PTR [eax], 0
  00005	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 3316 : 		}

  00009	c3		 ret	 0
??0?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
PUBLIC	?c_str@?$_Yarn@D@std@@QBEPBDXZ			; std::_Yarn<char>::c_str
; Function compile flags: /Ogsp
;	COMDAT ?c_str@?$_Yarn@D@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$_Yarn@D@std@@QBEPBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT
; _this$ = ecx

; 3376 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	75 03		 jne	 SHORT $LN4@c_str
  00006	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
$LN4@c_str:

; 3377 : 		}

  00009	c3		 ret	 0
?c_str@?$_Yarn@D@std@@QBEPBDXZ ENDP			; std::_Yarn<char>::c_str
_TEXT	ENDS
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 86   : 		return (_Mystrbuf);

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]

; 87   : 		}

  00003	c3		 ret	 0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEPQ_Bool_struct@2@HXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct::*
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEPQ_Bool_struct@2@HXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEPQ_Bool_struct@2@HXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct::*, COMDAT
; _this$ = ecx

; 105  : 			return (_Ok ? _CONVERTIBLE_TO_TRUE : 0);

  00000	33 c0		 xor	 eax, eax
  00002	38 41 04	 cmp	 BYTE PTR [ecx+4], al
  00005	0f 95 c0	 setne	 al
  00008	48		 dec	 eax

; 106  : 			}

  00009	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBEPQ_Bool_struct@2@HXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct::*
_TEXT	ENDS
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogsp
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 83   : 			if (_Myistr.rdbuf() != 0)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN1@Sentry_bas

; 84   : 				_Myistr.rdbuf()->_Unlock();

  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	8b c8		 mov	 ecx, eax
  00013	ff 62 08	 jmp	 DWORD PTR [edx+8]
$LN1@Sentry_bas:

; 85   : 			}

  00016	c3		 ret	 0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size, COMDAT
; _this$ = ecx

; 1150 : 		return (this->_Mysize);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1151 : 		}

  00003	c3		 ret	 0
?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size
_TEXT	ENDS
PUBLIC	??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator*
; Function compile flags: /Ogsp
;	COMDAT ??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator*, COMDAT
; _this$ = ecx

; 331  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	75 04		 jne	 SHORT $LN6@operator@2
  00006	33 d2		 xor	 edx, edx
  00008	eb 02		 jmp	 SHORT $LN7@operator@2
$LN6@operator@2:
  0000a	8b 10		 mov	 edx, DWORD PTR [eax]
$LN7@operator@2:

; 332  : 
; 333  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 334  : 		if (_Mycont == 0
; 335  : 			|| this->_Myoff < _Mycont->_Myoff
; 336  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 337  : 		{	// report error
; 338  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 339  : 		_SCL_SECURE_OUT_OF_RANGE;
; 340  : 		}
; 341  : 
; 342  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 343  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 344  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 345  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 346  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 347  : 
; 348  : 		__analysis_assume(_Mycont != 0);
; 349  : 
; 350  : 		size_type _Block = _Myoff / _DEQUESIZ;

  0000c	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 351  : 		size_type _Off = _Myoff & (_DEQUESIZ - 1);	// assume power of 2
; 352  : 
; 353  : 		if (_Mycont->_Mapsize <= _Block)

  0000f	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00012	3b c8		 cmp	 ecx, eax
  00014	77 02		 ja	 SHORT $LN1@operator@2

; 354  : 			_Block -= _Mycont->_Mapsize;

  00016	2b c1		 sub	 eax, ecx
$LN1@operator@2:

; 355  : 		return ((_Mycont->_Map)[_Block][_Off]);

  00018	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0001b	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 356  : 		}

  0001e	c3		 ret	 0
??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator++, COMDAT
; _this$ = ecx

; 364  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 365  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 366  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 367  : 		if (_Mycont == 0
; 368  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 369  : 		{	// report error
; 370  : 		_DEBUG_ERROR("deque iterator not incrementable");
; 371  : 		_SCL_SECURE_OUT_OF_RANGE;
; 372  : 		}
; 373  : 
; 374  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 375  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 376  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 377  : 		_SCL_SECURE_VALIDATE_RANGE(
; 378  : 			this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 379  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 380  : 
; 381  : 		++_Myoff;

  00002	ff 40 08	 inc	 DWORD PTR [eax+8]

; 382  : 		return (*this);
; 383  : 		}

  00005	c3		 ret	 0
??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator++
_TEXT	ENDS
PUBLIC	??1?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2003 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2004 : 			: this->_Bx._Buf);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2005 : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 2003 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2004 : 			: this->_Bx._Buf);

  00009	8b c1		 mov	 eax, ecx

; 2005 : 		}

  0000b	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogsp
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2009 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2010 : 			: this->_Bx._Buf);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr@2
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2011 : 		}

  00008	c3		 ret	 0
$LN3@Myptr@2:

; 2009 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2010 : 			: this->_Bx._Buf);

  00009	8b c1		 mov	 eax, ecx

; 2011 : 		}

  0000b	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 459  : 		}

  00000	c3		 ret	 0
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Ogsp
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Yarn@D@std@@AAEXXZ			; std::_Yarn<char>::_Tidy
EXTRN	_free:PROC
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@D@std@@AAEXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT
; _this$ = ecx

; 3391 : 		{	// discard any string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3392 : 		if (_Myptr != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 07		 je	 SHORT $LN1@Tidy

; 3393 : 
; 3394 :  #ifdef _DEBUG
; 3395 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3396 : 
; 3397 :  #else /* _DEBUG */
; 3398 : 			_CSTD free(_Myptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	59		 pop	 ecx
$LN1@Tidy:

; 3399 :  #endif /* _DEBUG */
; 3400 : 
; 3401 : 		_Myptr = 0;

  00010	83 26 00	 and	 DWORD PTR [esi], 0
  00013	5e		 pop	 esi

; 3402 : 		}

  00014	c3		 ret	 0
?_Tidy@?$_Yarn@D@std@@AAEXXZ ENDP			; std::_Yarn<char>::_Tidy
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 76   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 77   : 			if (_Myistr.rdbuf() != 0)

  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00010	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  00014	85 c0		 test	 eax, eax
  00016	74 07		 je	 SHORT $LN1@Sentry_bas@2

; 78   : 				_Myistr.rdbuf()->_Lock();

  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	8b c8		 mov	 ecx, eax
  0001c	ff 52 04	 call	 DWORD PTR [edx+4]
$LN1@Sentry_bas@2:

; 79   : 			}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 141  : 		return (sync());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 34	 jmp	 DWORD PTR [eax+52]
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
PUBLIC	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
; Function compile flags: /Ogsp
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT
; _this$ = ecx

; 223  : 		return (*_IGnext);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 224  : 		}

  00005	c3		 ret	 0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
_TEXT	ENDS
PUBLIC	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
; Function compile flags: /Ogsp
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT
; _this$ = ecx

; 267  : 		--*_IGcount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 268  : 		return ((*_IGnext)++);

  00005	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000d	89 11		 mov	 DWORD PTR [ecx], edx

; 269  : 		}

  0000f	c3		 ret	 0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
_TEXT	ENDS
PUBLIC	?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
; Function compile flags: /Ogsp
;	COMDAT ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc, COMDAT
; _this$ = ecx

; 273  : 		--*_IGcount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 274  : 		return (++(*_IGnext));

  00005	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	40		 inc	 eax
  0000b	89 01		 mov	 DWORD PTR [ecx], eax

; 275  : 		}

  0000d	c3		 ret	 0
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
_TEXT	ENDS
PUBLIC	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
; Function compile flags: /Ogsp
;	COMDAT ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail, COMDAT
; _this$ = ecx

; 279  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  00000	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00003	33 c0		 xor	 eax, eax
  00005	39 02		 cmp	 DWORD PTR [edx], eax
  00007	74 05		 je	 SHORT $LN3@Gnavail
  00009	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3@Gnavail:
  0000e	99		 cdq

; 280  : 		}

  0000f	c3		 ret	 0
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
_TEXT	ENDS
PUBLIC	?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty, COMDAT
; _this$ = ecx

; 1160 : 		return (this->_Mysize == 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00005	0f 94 c0	 sete	 al

; 1161 : 		}

  00008	c3		 ret	 0
?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
_TEXT	ENDS
PUBLIC	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ PROC ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
_TEXT	ENDS
PUBLIC	??1?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::~_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::~_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::~_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$ = ecx

; 1905 : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1906 : 		return (this->_Alval);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1907 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
; Function compile flags: /Ogsp
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 1910 : 		{	// assign _Count copies of _Ch beginning at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1911 : 		if (_Count == 1)

  00003	83 7d 0c 01	 cmp	 DWORD PTR __Count$[ebp], 1
  00007	75 13		 jne	 SHORT $LN2@Chassign

; 1912 : 			_Traits::assign(*(_Myptr() + _Off), _Ch);

  00009	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0000d	72 02		 jb	 SHORT $LN7@Chassign
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN7@Chassign:
  00011	8a 45 10	 mov	 al, BYTE PTR __Ch$[ebp]
  00014	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00017	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 1913 : 		else

  0001a	eb 1c		 jmp	 SHORT $LN15@Chassign
$LN2@Chassign:

; 1914 : 			_Traits::assign(_Myptr() + _Off, _Count, _Ch);

  0001c	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00020	72 02		 jb	 SHORT $LN13@Chassign
  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN13@Chassign:
  00024	0f be 45 10	 movsx	 eax, BYTE PTR __Ch$[ebp]
  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	03 4d 08	 add	 ecx, DWORD PTR __Off$[ebp]
  0002e	50		 push	 eax
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _memset
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@Chassign:

; 1915 : 		}

  00038	5d		 pop	 ebp
  00039	c2 0c 00	 ret	 12			; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogsp
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1972 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1973 : 		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + this->_Mysize <= _Ptr)

  00003	83 7d 08 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00007	74 2c		 je	 SHORT $LN2@Inside
  00009	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0000c	83 fa 10	 cmp	 edx, 16			; 00000010H
  0000f	72 04		 jb	 SHORT $LN8@Inside
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	eb 02		 jmp	 SHORT $LN9@Inside
$LN8@Inside:
  00015	8b c1		 mov	 eax, ecx
$LN9@Inside:
  00017	39 45 08	 cmp	 DWORD PTR __Ptr$[ebp], eax
  0001a	72 19		 jb	 SHORT $LN2@Inside
  0001c	83 fa 10	 cmp	 edx, 16			; 00000010H
  0001f	72 04		 jb	 SHORT $LN12@Inside
  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	eb 02		 jmp	 SHORT $LN13@Inside
$LN12@Inside:
  00025	8b c1		 mov	 eax, ecx
$LN13@Inside:
  00027	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0002a	03 c8		 add	 ecx, eax
  0002c	3b 4d 08	 cmp	 ecx, DWORD PTR __Ptr$[ebp]
  0002f	76 04		 jbe	 SHORT $LN2@Inside

; 1975 : 		else
; 1976 : 			return (true);

  00031	b0 01		 mov	 al, 1
  00033	eb 02		 jmp	 SHORT $LN1@Inside
$LN2@Inside:

; 1974 : 			return (false);	// don't ask

  00035	32 c0		 xor	 al, al
$LN1@Inside:

; 1977 : 		}

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2015 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2020 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 74   : 		return (_Tiestr);

  00000	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]

; 75   : 		}

  00003	c3		 ret	 0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVValue@Json@@@std@@QAE@XZ	; std::allocator<Json::Value *>::allocator<Json::Value *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVValue@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVValue@Json@@@std@@QAE@XZ PROC		; std::allocator<Json::Value *>::allocator<Json::Value *>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@PAVValue@Json@@@std@@QAE@XZ ENDP		; std::allocator<Json::Value *>::allocator<Json::Value *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::deallocate
; Function compile flags: /Ogsp
;	COMDAT ?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value *>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value *>::deallocate
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::deallocate
; Function compile flags: /Ogsp
;	COMDAT ?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value * *>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value * *>::deallocate
_TEXT	ENDS
PUBLIC	?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty, COMDAT
; _this$ = ecx

; 1160 : 		return (this->_Mysize == 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00005	0f 94 c0	 sete	 al

; 1161 : 		}

  00008	c3		 ret	 0
?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
_TEXT	ENDS
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen, COMDAT
; _this$ = ecx

; 1580 : 		_Xlength_error("deque<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen@2:
$LN3@Xlen@2:
  0000a	cc		 int	 3
?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::deallocate
; Function compile flags: /Ogsp
;	COMDAT ?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::deallocate
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::deallocate
; Function compile flags: /Ogsp
;	COMDAT ?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::deallocate
_TEXT	ENDS
PUBLIC	?_Compat@?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEXABV12@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Compat
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?_Compat@?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Compat, COMDAT
; _this$ = ecx

; 538  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Compat
_TEXT	ENDS
PUBLIC	?_Setcont@?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPBV?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Setcont
; Function compile flags: /Ogsp
;	COMDAT ?_Setcont@?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPBV?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z
_TEXT	SEGMENT
__Pdeque$ = 8						; size = 4
?_Setcont@?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPBV?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Setcont, COMDAT
; _this$ = ecx

; 541  : 		{	// set container pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 542  : 		this->_Adopt(_Pdeque);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pdeque$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 04		 je	 SHORT $LN3@Setcont
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@Setcont:

; 543  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Setcont@?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPBV?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Setcont
_TEXT	ENDS
PUBLIC	??Y?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator+=
; Function compile flags: /Ogsp
;	COMDAT ??Y?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator+=, COMDAT
; _this$ = ecx

; 654  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 655  : 		this->_Myoff += _Off;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00008	01 48 08	 add	 DWORD PTR [eax+8], ecx

; 656  : 		return (*this);
; 657  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??Y?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator+=
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	83 c8 ff	 or	 eax, -1

; 220  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen, COMDAT
; _this$ = ecx

; 1580 : 		_Xlength_error("deque<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen@3:
$LN3@Xlen@3:
  0000a	cc		 int	 3
?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Value *>::allocator<Json::Value *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z PROC	; std::allocator<Json::Value *>::allocator<Json::Value *>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<Json::Value *>::allocator<Json::Value *>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ ; std::allocator<Json::Reader::ErrorInfo>::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ PROC ; std::allocator<Json::Reader::ErrorInfo>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 5d 74 d1 05	 mov	 eax, 97612893		; 05d1745dH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ ENDP ; std::allocator<Json::Reader::ErrorInfo>::max_size
_TEXT	ENDS
PUBLIC	??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator-
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator-, COMDAT
; _this$ = ecx

; 461  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 462  : 		_Compat(_Right);
; 463  : 		return (_Right._Myoff <= this->_Myoff
; 464  : 			? this->_Myoff - _Right._Myoff
; 465  : 			: -(difference_type)(_Right._Myoff - this->_Myoff));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00009	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000c	2b c2		 sub	 eax, edx

; 466  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator-
_TEXT	ENDS
PUBLIC	??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::operator*
; Function compile flags: /Ogsp
;	COMDAT ??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEABQAVValue@Json@@XZ
_TEXT	SEGMENT
??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEABQAVValue@Json@@XZ PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::operator*, COMDAT
; _this$ = ecx

; 331  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	75 04		 jne	 SHORT $LN6@operator@3
  00006	33 d2		 xor	 edx, edx
  00008	eb 02		 jmp	 SHORT $LN7@operator@3
$LN6@operator@3:
  0000a	8b 10		 mov	 edx, DWORD PTR [eax]
$LN7@operator@3:

; 332  : 
; 333  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 334  : 		if (_Mycont == 0
; 335  : 			|| this->_Myoff < _Mycont->_Myoff
; 336  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 337  : 		{	// report error
; 338  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 339  : 		_SCL_SECURE_OUT_OF_RANGE;
; 340  : 		}
; 341  : 
; 342  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 343  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 344  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 345  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 346  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 347  : 
; 348  : 		__analysis_assume(_Mycont != 0);
; 349  : 
; 350  : 		size_type _Block = _Myoff / _DEQUESIZ;

  0000c	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000f	8b c8		 mov	 ecx, eax
  00011	56		 push	 esi

; 351  : 		size_type _Off = _Myoff & (_DEQUESIZ - 1);	// assume power of 2
; 352  : 
; 353  : 		if (_Mycont->_Mapsize <= _Block)

  00012	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00015	c1 e9 02	 shr	 ecx, 2
  00018	83 e0 03	 and	 eax, 3
  0001b	3b f1		 cmp	 esi, ecx
  0001d	77 02		 ja	 SHORT $LN1@operator@3

; 354  : 			_Block -= _Mycont->_Mapsize;

  0001f	2b ce		 sub	 ecx, esi
$LN1@operator@3:

; 355  : 		return ((_Mycont->_Map)[_Block][_Off]);

  00021	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00024	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00027	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0002a	5e		 pop	 esi

; 356  : 		}

  0002b	c3		 ret	 0
??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEABQAVValue@Json@@XZ ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::operator*
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ ; std::allocator<Json::Value *>::max_size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ PROC	; std::allocator<Json::Value *>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ ENDP	; std::allocator<Json::Value *>::max_size
_TEXT	ENDS
PUBLIC	??Y?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::operator+=
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ??Y?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::operator+=, COMDAT
; _this$ = ecx

; 654  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 655  : 		this->_Myoff += _Off;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00008	01 48 08	 add	 DWORD PTR [eax+8], ecx

; 656  : 		return (*this);
; 657  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??Y?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::operator+=
_TEXT	ENDS
PUBLIC	?_Setcont@?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPBV?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@2@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::_Setcont
; Function compile flags: /Ogsp
;	COMDAT ?_Setcont@?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPBV?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@2@@Z
_TEXT	SEGMENT
__Pdeque$ = 8						; size = 4
?_Setcont@?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPBV?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@2@@Z PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::_Setcont, COMDAT
; _this$ = ecx

; 541  : 		{	// set container pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 542  : 		this->_Adopt(_Pdeque);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pdeque$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 04		 je	 SHORT $LN3@Setcont@2
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@Setcont@2:

; 543  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Setcont@?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPBV?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@2@@Z ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::_Setcont
_TEXT	ENDS
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogsp
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::move<Json::Value * &>
; Function compile flags: /Ogsp
;	COMDAT ??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z PROC ; std::move<Json::Value * &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ENDP ; std::move<Json::Value * &>
_TEXT	ENDS
PUBLIC	??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::forward<Json::Value *>
; Function compile flags: /Ogsp
;	COMDAT ??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z PROC ; std::forward<Json::Value *>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ENDP ; std::forward<Json::Value *>
_TEXT	ENDS
PUBLIC	??$?0PAVValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Value *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?0PAVValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0PAVValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Value *>, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0PAVValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Value *>
_TEXT	ENDS
PUBLIC	??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>
; Function compile flags: /Ogsp
;	COMDAT ??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>
_TEXT	ENDS
PUBLIC	??$?0VErrorInfo@Reader@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Reader::ErrorInfo>
; Function compile flags: /Ogsp
;	COMDAT ??$?0VErrorInfo@Reader@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0VErrorInfo@Reader@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0VErrorInfo@Reader@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Reader::ErrorInfo>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z
_TEXT	SEGMENT
$T41334 = -12						; size = 12
$T41339 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z PROC ; std::_Allocate<Json::Reader::ErrorInfo>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3b		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 5d 74 d1
	05		 cmp	 ecx, 97612893		; 05d1745dH
  00015	77 0e		 ja	 SHORT $LN1@Allocate
  00017	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	59		 pop	 ecx
  00021	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00023	75 25		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00025	83 65 08 00	 and	 DWORD PTR $T41339[ebp], 0
  00029	8d 45 08	 lea	 eax, DWORD PTR $T41339[ebp]
  0002c	50		 push	 eax
  0002d	8d 4d f4	 lea	 ecx, DWORD PTR $T41334[ebp]
  00030	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00035	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003a	8d 45 f4	 lea	 eax, DWORD PTR $T41334[ebp]
  0003d	50		 push	 eax
  0003e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T41334[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00045	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  0004a	c9		 leave
  0004b	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z ENDP ; std::_Allocate<Json::Reader::ErrorInfo>
_TEXT	ENDS
PUBLIC	??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>
; Function compile flags: /Ogsp
;	COMDAT ??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z PROC ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z ; std::_Allocate<Json::Value *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z
_TEXT	SEGMENT
$T41347 = -12						; size = 12
$T41351 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z PROC ; std::_Allocate<Json::Value *>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3d		 je	 SHORT $LN5@Allocate@2

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00015	77 10		 ja	 SHORT $LN1@Allocate@2
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 02	 shl	 eax, 2
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	59		 pop	 ecx
  00023	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00025	75 25		 jne	 SHORT $LN5@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00027	83 65 08 00	 and	 DWORD PTR $T41351[ebp], 0
  0002b	8d 45 08	 lea	 eax, DWORD PTR $T41351[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T41347[ebp]
  00032	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00037	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003c	8d 45 f4	 lea	 eax, DWORD PTR $T41347[ebp]
  0003f	50		 push	 eax
  00040	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T41347[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00047	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@2:
$LN5@Allocate@2:

; 40   : 	}

  0004c	c9		 leave
  0004d	c3		 ret	 0
$LN9@Allocate@2:
??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z ENDP ; std::_Allocate<Json::Value *>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z
_TEXT	SEGMENT
$T41356 = -12						; size = 12
$T41360 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z PROC ; std::_Allocate<Json::Reader::ErrorInfo *>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3d		 je	 SHORT $LN5@Allocate@3

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00015	77 10		 ja	 SHORT $LN1@Allocate@3
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 02	 shl	 eax, 2
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	59		 pop	 ecx
  00023	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00025	75 25		 jne	 SHORT $LN5@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00027	83 65 08 00	 and	 DWORD PTR $T41360[ebp], 0
  0002b	8d 45 08	 lea	 eax, DWORD PTR $T41360[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T41356[ebp]
  00032	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00037	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003c	8d 45 f4	 lea	 eax, DWORD PTR $T41356[ebp]
  0003f	50		 push	 eax
  00040	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T41356[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00047	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@3:
$LN5@Allocate@3:

; 40   : 	}

  0004c	c9		 leave
  0004d	c3		 ret	 0
$LN9@Allocate@3:
??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z ENDP ; std::_Allocate<Json::Reader::ErrorInfo *>
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
; Function compile flags: /Ogsp
;	COMDAT ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
_TEXT	SEGMENT
$T41365 = -12						; size = 12
$T41369 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z PROC ; std::_Allocate<std::_Container_proxy>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3d		 je	 SHORT $LN5@Allocate@4

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 10		 ja	 SHORT $LN1@Allocate@4
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 03	 shl	 eax, 3
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	59		 pop	 ecx
  00023	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00025	75 25		 jne	 SHORT $LN5@Allocate@4
$LN1@Allocate@4:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00027	83 65 08 00	 and	 DWORD PTR $T41369[ebp], 0
  0002b	8d 45 08	 lea	 eax, DWORD PTR $T41369[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T41365[ebp]
  00032	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00037	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003c	8d 45 f4	 lea	 eax, DWORD PTR $T41365[ebp]
  0003f	50		 push	 eax
  00040	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T41365[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00047	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@4:
$LN5@Allocate@4:

; 40   : 	}

  0004c	c9		 leave
  0004d	c3		 ret	 0
$LN9@Allocate@4:
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Container_proxy>
_TEXT	ENDS
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Ogsp
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T41374 = -12						; size = 12
$T41378 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;

  00003	33 c0		 xor	 eax, eax
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 32   : 
; 33   : 	if (_Count <= 0)

  00008	39 45 08	 cmp	 DWORD PTR __Count$[ebp], eax

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000b	76 38		 jbe	 SHORT $LN5@Allocate@5

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000d	83 7d 08 ff	 cmp	 DWORD PTR __Count$[ebp], -1
  00011	77 0d		 ja	 SHORT $LN1@Allocate@5
  00013	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00016	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001b	59		 pop	 ecx
  0001c	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0001e	75 25		 jne	 SHORT $LN5@Allocate@5
$LN1@Allocate@5:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00020	83 65 08 00	 and	 DWORD PTR $T41378[ebp], 0
  00024	8d 45 08	 lea	 eax, DWORD PTR $T41378[ebp]
  00027	50		 push	 eax
  00028	8d 4d f4	 lea	 ecx, DWORD PTR $T41374[ebp]
  0002b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00030	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00035	8d 45 f4	 lea	 eax, DWORD PTR $T41374[ebp]
  00038	50		 push	 eax
  00039	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T41374[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00040	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@5:
$LN5@Allocate@5:

; 40   : 	}

  00045	c9		 leave
  00046	c3		 ret	 0
$LN9@Allocate@5:
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z ; std::_Allocate<Json::Value * *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z
_TEXT	SEGMENT
$T41383 = -12						; size = 12
$T41387 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z PROC ; std::_Allocate<Json::Value * *>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 3d		 je	 SHORT $LN5@Allocate@6

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00015	77 10		 ja	 SHORT $LN1@Allocate@6
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 02	 shl	 eax, 2
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	59		 pop	 ecx
  00023	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00025	75 25		 jne	 SHORT $LN5@Allocate@6
$LN1@Allocate@6:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00027	83 65 08 00	 and	 DWORD PTR $T41387[ebp], 0
  0002b	8d 45 08	 lea	 eax, DWORD PTR $T41387[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T41383[ebp]
  00032	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00037	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003c	8d 45 f4	 lea	 eax, DWORD PTR $T41383[ebp]
  0003f	50		 push	 eax
  00040	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T41383[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00047	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@6:
$LN5@Allocate@6:

; 40   : 	}

  0004c	c9		 leave
  0004d	c3		 ret	 0
$LN9@Allocate@6:
??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z ENDP ; std::_Allocate<Json::Value * *>
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00014	8b c6		 mov	 eax, esi
  00016	5e		 pop	 esi
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV34@@Z ; std::allocator<Json::Value *>::construct
; Function compile flags: /Ogsp
;	COMDAT ?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV34@@Z PROC ; std::allocator<Json::Value *>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@construct:

; 203  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV34@@Z ENDP ; std::allocator<Json::Value *>::construct
_TEXT	ENDS
PUBLIC	??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::move<std::basic_istream<char,std::char_traits<char> > &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::move<std::basic_istream<char,std::char_traits<char> > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::move<std::basic_istream<char,std::char_traits<char> > &>
_TEXT	ENDS
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
; Function compile flags: /Ogsp
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAVErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@PAV123@@Z ; std::_Val_type<Json::Reader::ErrorInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAVErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@PAV123@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAVErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@PAV123@@Z PROC ; std::_Val_type<Json::Reader::ErrorInfo *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAVErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@PAV123@@Z ENDP ; std::_Val_type<Json::Reader::ErrorInfo *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@VErrorInfo@Reader@Json@@V123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVErrorInfo@Reader@Json@@0@Z ; std::_Ptr_cat<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
; Function compile flags: /Ogsp
;	COMDAT ??$_Ptr_cat@VErrorInfo@Reader@Json@@V123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVErrorInfo@Reader@Json@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@VErrorInfo@Reader@Json@@V123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVErrorInfo@Reader@Json@@0@Z PROC ; std::_Ptr_cat<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@VErrorInfo@Reader@Json@@V123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVErrorInfo@Reader@Json@@0@Z ENDP ; std::_Ptr_cat<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
_TEXT	ENDS
PUBLIC	??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z ; std::forward<Json::Reader::ErrorInfo const &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z PROC ; std::forward<Json::Reader::ErrorInfo const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z ENDP ; std::forward<Json::Reader::ErrorInfo const &>
_TEXT	ENDS
PUBLIC	??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator==<char,char>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator==<char,char>, COMDAT

; 263  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 264  : 	}

  00002	c3		 ret	 0
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator==<char,char>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >, COMDAT

; 485  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 486  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 487  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 488  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVErrorInfo@Reader@Json@@0@Z ; std::_Ptr_cat<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Ptr_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVErrorInfo@Reader@Json@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVErrorInfo@Reader@Json@@0@Z PROC ; std::_Ptr_cat<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVErrorInfo@Reader@Json@@0@Z ENDP ; std::_Ptr_cat<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>, COMDAT

; 399  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 400  : 	_DEBUG_RANGE(_First, _Last);
; 401  : 	_DEBUG_POINTER(_Dest);
; 402  : 	size_t _Count = (size_t)(_Last - _First);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00007	2b 75 08	 sub	 esi, DWORD PTR __First$[ebp]
  0000a	c1 fe 02	 sar	 esi, 2

; 403  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 404  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000d	c1 e6 02	 shl	 esi, 2
  00010	56		 push	 esi
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00017	e8 00 00 00 00	 call	 _memmove
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001f	03 c6		 add	 eax, esi
  00021	5e		 pop	 esi

; 405  : 	}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z ; std::_Val_type<Json::Reader::ErrorInfo * *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z PROC ; std::_Val_type<Json::Reader::ErrorInfo * *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z ENDP ; std::_Val_type<Json::Reader::ErrorInfo * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 105  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *> >
_TEXT	ENDS
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAPAVValue@Json@@0@Z ; std::_Ptr_cat<Json::Value * *,Json::Value * *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAPAVValue@Json@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAPAVValue@Json@@0@Z PROC ; std::_Ptr_cat<Json::Value * *,Json::Value * *>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	c9		 leave
  00008	c3		 ret	 0
??$_Ptr_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAPAVValue@Json@@0@Z ENDP ; std::_Ptr_cat<Json::Value * *,Json::Value * *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Value * *,Json::Value * *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Json::Value * *,Json::Value * *>, COMDAT

; 399  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 400  : 	_DEBUG_RANGE(_First, _Last);
; 401  : 	_DEBUG_POINTER(_Dest);
; 402  : 	size_t _Count = (size_t)(_Last - _First);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00007	2b 75 08	 sub	 esi, DWORD PTR __First$[ebp]
  0000a	c1 fe 02	 sar	 esi, 2

; 403  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 404  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000d	c1 e6 02	 shl	 esi, 2
  00010	56		 push	 esi
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00017	e8 00 00 00 00	 call	 _memmove
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001f	03 c6		 add	 eax, esi
  00021	5e		 pop	 esi

; 405  : 	}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::Value * *,Json::Value * *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z ; std::_Val_type<Json::Value * * *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z PROC ; std::_Val_type<Json::Value * * *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z ENDP ; std::_Val_type<Json::Value * * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Json::Value * *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Json::Value * *> >, COMDAT

; 105  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Json::Value * *> >
_TEXT	ENDS
PUBLIC	??$_Destroy@PAVValue@Json@@@std@@YAXPAPAVValue@Json@@@Z ; std::_Destroy<Json::Value *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Destroy@PAVValue@Json@@@std@@YAXPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAVValue@Json@@@std@@YAXPAPAVValue@Json@@@Z PROC ; std::_Destroy<Json::Value *>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAVValue@Json@@@std@@YAXPAPAVValue@Json@@@Z ENDP ; std::_Destroy<Json::Value *>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@@Z ; std::_Destroy<Json::Value * *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Destroy@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@@Z PROC ; std::_Destroy<Json::Value * *>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@@Z ENDP ; std::_Destroy<Json::Value * *>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@@Z ; std::_Destroy<Json::Reader::ErrorInfo *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Destroy@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Destroy<Json::Reader::ErrorInfo *>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Destroy<Json::Reader::ErrorInfo *>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Container_proxy@std@@@std@@YAXPAU_Container_proxy@0@@Z ; std::_Destroy<std::_Container_proxy>
; Function compile flags: /Ogsp
;	COMDAT ??$_Destroy@U_Container_proxy@std@@@std@@YAXPAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Container_proxy@std@@@std@@YAXPAU_Container_proxy@0@@Z PROC ; std::_Destroy<std::_Container_proxy>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Container_proxy@std@@@std@@YAXPAU_Container_proxy@0@@Z ENDP ; std::_Destroy<std::_Container_proxy>
_TEXT	ENDS
PUBLIC	??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator*
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator*, COMDAT
; _this$ = ecx

; 619  : 		return ((reference)**(_Mybase *)this);

  00000	e9 00 00 00 00	 jmp	 ??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator*
??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator++
; Function compile flags: /Ogsp
;	COMDAT ??E?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator++, COMDAT
; _this$ = ecx

; 628  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 629  : 		++*(_Mybase *)this;

  00002	ff 40 08	 inc	 DWORD PTR [eax+8]

; 630  : 		return (*this);
; 631  : 		}

  00005	c3		 ret	 0
??E?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator--
; Function compile flags: /Ogsp
;	COMDAT ??F?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator--, COMDAT
; _this$ = ecx

; 393  : 		{	// predecrement

  00000	8b c1		 mov	 eax, ecx

; 394  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 395  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 396  : 		if (_Mycont == 0
; 397  : 			|| this->_Myoff <= _Mycont->_Myoff)
; 398  : 		{	// report error
; 399  : 		_DEBUG_ERROR("deque iterator not decrementable");
; 400  : 		_SCL_SECURE_OUT_OF_RANGE;
; 401  : 		}
; 402  : 
; 403  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 404  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 405  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 406  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff < this->_Myoff);
; 407  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 408  : 
; 409  : 		--_Myoff;

  00002	ff 48 08	 dec	 DWORD PTR [eax+8]

; 410  : 		return (*this);
; 411  : 		}

  00005	c3		 ret	 0
??F?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator--
_TEXT	ENDS
PUBLIC	??$move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z ; std::move<Json::Reader::ErrorInfo &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z PROC ; std::move<Json::Reader::ErrorInfo &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z ENDP ; std::move<Json::Reader::ErrorInfo &>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z PROC ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>, COMDAT

; 2723 : 	{	// copy _Val _Count times through [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2724 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00003	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00007	76 16		 jbe	 SHORT $LN1@Fill_n
  00009	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
$LL3@Fill_n:

; 2725 : 		*_Dest = _Val;

  0000c	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00011	ff 4d 0c	 dec	 DWORD PTR __Count$[ebp]
  00014	89 08		 mov	 DWORD PTR [eax], ecx
  00016	83 c0 04	 add	 eax, 4
  00019	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0001d	77 ed		 ja	 SHORT $LL3@Fill_n
$LN1@Fill_n:

; 2726 : 	}

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z ENDP ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z PROC ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>, COMDAT

; 2723 : 	{	// copy _Val _Count times through [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2724 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00003	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00007	76 16		 jbe	 SHORT $LN1@Fill_n@2
  00009	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
$LL3@Fill_n@2:

; 2725 : 		*_Dest = _Val;

  0000c	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00011	ff 4d 0c	 dec	 DWORD PTR __Count$[ebp]
  00014	89 08		 mov	 DWORD PTR [eax], ecx
  00016	83 c0 04	 add	 eax, 4
  00019	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0001d	77 ed		 ja	 SHORT $LL3@Fill_n@2
$LN1@Fill_n@2:

; 2726 : 	}

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z ENDP ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
_TEXT	ENDS
PUBLIC	??$forward@VErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z ; std::forward<Json::Reader::ErrorInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@VErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@VErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z PROC ; std::forward<Json::Reader::ErrorInfo>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@VErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z ENDP ; std::forward<Json::Reader::ErrorInfo>
_TEXT	ENDS
PUBLIC	??1_Container_base12@std@@QAE@XZ		; std::_Container_base12::~_Container_base12
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??1_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
??1_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::~_Container_base12, COMDAT
; _this$ = ecx

; 92   : 		_Orphan_all();
; 93   : 		}

  00000	c3		 ret	 0
??1_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::~_Container_base12
_TEXT	ENDS
PUBLIC	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z	; std::_Iterator_base12::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z PROC		; std::_Iterator_base12::operator=, COMDAT
; _this$ = ecx

; 121  : 		{	// assign an iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 122  : 		if (_Myproxy != _Right._Myproxy)

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	39 10		 cmp	 DWORD PTR [eax], edx
  0000c	74 0a		 je	 SHORT $LN4@operator@4

; 123  : 			_Adopt(_Right._Myproxy->_Mycont);

  0000e	8b 12		 mov	 edx, DWORD PTR [edx]
  00010	85 d2		 test	 edx, edx
  00012	74 04		 je	 SHORT $LN4@operator@4
  00014	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00016	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@operator@4:

; 124  : 		return (*this);
; 125  : 		}

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ENDP		; std::_Iterator_base12::operator=
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@4
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@4:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?c_str@locale@std@@QBEPBDXZ			; std::locale::c_str
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
;	COMDAT ?c_str@locale@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@locale@std@@QBEPBDXZ PROC			; std::locale::c_str, COMDAT
; _this$ = ecx

; 432  : 		return (_Ptr->_Name.c_str());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00005	85 c9		 test	 ecx, ecx
  00007	74 03		 je	 SHORT $LN5@c_str@2
  00009	8b c1		 mov	 eax, ecx

; 433  : 		}

  0000b	c3		 ret	 0

; 432  : 		return (_Ptr->_Name.c_str());

$LN5@c_str@2:
  0000c	83 c0 1c	 add	 eax, 28			; 0000001cH

; 433  : 		}

  0000f	c3		 ret	 0
?c_str@locale@std@@QBEPBDXZ ENDP			; std::locale::c_str
_TEXT	ENDS
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z		; std::ctype<char>::ctype<char>
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocinfo
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
CONST	ENDS
;	COMDAT ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
$T41538 = -16						; size = 16
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 2365 : 		{	// construct from current locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	56		 push	 esi
  0000d	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 2366 : 		_Init(_Lobj);

  00010	8d 45 f0	 lea	 eax, DWORD PTR $T41538[ebp]
  00013	57		 push	 edi
  00014	50		 push	 eax
  00015	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_7?$ctype@D@std@@6B@
  0001b	e8 00 00 00 00	 call	 __Getctype
  00020	8d 7b 08	 lea	 edi, DWORD PTR [ebx+8]
  00023	8b f0		 mov	 esi, eax
  00025	a5		 movsd
  00026	a5		 movsd
  00027	a5		 movsd
  00028	59		 pop	 ecx
  00029	a5		 movsd
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi

; 2367 : 		}

  0002c	8b c3		 mov	 eax, ebx
  0002e	5b		 pop	 ebx
  0002f	c9		 leave
  00030	c2 08 00	 ret	 8
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<char>::ctype<char>
_TEXT	ENDS
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 2405 : 		if (0 < _Ctype._Delfl)

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	85 c0		 test	 eax, eax
  00005	7e 0a		 jle	 SHORT $LN6@Tidy@2

; 2406 : 			free((void *)_Ctype._Table);

  00007	ff 71 10	 push	 DWORD PTR [ecx+16]
  0000a	e8 00 00 00 00	 call	 _free

; 2408 : 			delete[] (void *)_Ctype._Table;

  0000f	59		 pop	 ecx

; 2409 : 		}

  00010	c3		 ret	 0
$LN6@Tidy@2:

; 2407 : 		else if (_Ctype._Delfl < 0)

  00011	79 09		 jns	 SHORT $LN1@Tidy@2

; 2408 : 			delete[] (void *)_Ctype._Table;

  00013	ff 71 10	 push	 DWORD PTR [ecx+16]
  00016	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0001b	59		 pop	 ecx
$LN1@Tidy@2:

; 2409 : 		}

  0001c	c3		 ret	 0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
EXTRN	__Tolower:PROC
; Function compile flags: /Ogsp
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2412 : 		{	// convert element to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2413 : 		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00007	83 c1 08	 add	 ecx, 8
  0000a	51		 push	 ecx
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __Tolower
  00011	59		 pop	 ecx
  00012	59		 pop	 ecx

; 2414 : 		}

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2418 : 		{	// convert [_First, _Last) in place to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2419 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2420 : 		for (; _First != _Last; ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0000a	74 19		 je	 SHORT $LN1@do_tolower
  0000c	57		 push	 edi
  0000d	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]
$LL3@do_tolower:

; 2421 : 			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);

  00010	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00013	57		 push	 edi
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __Tolower
  0001a	88 06		 mov	 BYTE PTR [esi], al
  0001c	46		 inc	 esi
  0001d	59		 pop	 ecx
  0001e	59		 pop	 ecx
  0001f	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00022	75 ec		 jne	 SHORT $LL3@do_tolower
  00024	5f		 pop	 edi
$LN1@do_tolower:

; 2422 : 		return ((const _Elem *)_First);

  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi

; 2423 : 		}

  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
EXTRN	__Toupper:PROC
; Function compile flags: /Ogsp
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2426 : 		{	// convert element to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2427 : 		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00007	83 c1 08	 add	 ecx, 8
  0000a	51		 push	 ecx
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __Toupper
  00011	59		 pop	 ecx
  00012	59		 pop	 ecx

; 2428 : 		}

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2432 : 		{	// convert [_First, _Last) in place to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2433 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2434 : 		for (; _First != _Last; ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0000a	74 19		 je	 SHORT $LN1@do_toupper
  0000c	57		 push	 edi
  0000d	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]
$LL3@do_toupper:

; 2435 : 			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);

  00010	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00013	57		 push	 edi
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __Toupper
  0001a	88 06		 mov	 BYTE PTR [esi], al
  0001c	46		 inc	 esi
  0001d	59		 pop	 ecx
  0001e	59		 pop	 ecx
  0001f	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00022	75 ec		 jne	 SHORT $LL3@do_toupper
  00024	5f		 pop	 edi
$LN1@do_toupper:

; 2436 : 		return ((const _Elem *)_First);

  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi

; 2437 : 		}

  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2440 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2441 : 		return (_Byte);

  00003	8a 45 08	 mov	 al, BYTE PTR __Byte$[ebp]

; 2442 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2446 : 		{	// widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2447 : 		_DEBUG_RANGE(_First, _Last);
; 2448 : 		_DEBUG_POINTER(_Dest);
; 2449 : 		_CSTD memcpy(_Dest, _First, _Last - _First);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00009	50		 push	 eax
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00010	e8 00 00 00 00	 call	 _memcpy

; 2450 : 		return (_Last);

  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2451 : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2454 : 		{	// narrow char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2455 : 		return (_Ch);

  00003	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]

; 2456 : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2460 : 		{	// narrow elements in [_First, _Last) to chars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2461 : 		_DEBUG_RANGE(_First, _Last);
; 2462 : 		_DEBUG_POINTER(_Dest);
; 2463 : 		_CSTD memcpy(_Dest, _First, _Last - _First);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00009	50		 push	 eax
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	ff 75 14	 push	 DWORD PTR __Dest$[ebp]
  00010	e8 00 00 00 00	 call	 _memcpy

; 2464 : 		return (_Last);

  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2465 : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
; Function compile flags: /Ogsp
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2394 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@

; 2395 : 		_Tidy();

  00009	e8 00 00 00 00	 call	 ?_Tidy@?$ctype@D@std@@IAEXXZ ; std::ctype<char>::_Tidy

; 2396 : 		}

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  00014	5e		 pop	 esi
  00015	c3		 ret	 0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  0000c	e8 00 00 00 00	 call	 ?_Tidy@?$ctype@D@std@@IAEXXZ ; std::ctype<char>::_Tidy
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
  0001b	74 07		 je	 SHORT $LN1@scalar@5
  0001d	56		 push	 esi
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	59		 pop	 ecx
$LN1@scalar@5:
  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??0system_error@std@@QAE@Verror_code@1@PBD@Z	; std::system_error::system_error
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\system_error
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
_DATA	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@PBD@Z
_TEXT	SEGMENT
__Errcode$ = 8						; size = 8
$T41602 = 16						; size = 4
__Message$ = 16						; size = 4
??0system_error@std@@QAE@Verror_code@1@PBD@Z PROC	; std::system_error::system_error, COMDAT
; _this$ = ecx

; 516  : 		{	// construct from error code and message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 10	 mov	 eax, DWORD PTR __Message$[ebp]
  00006	56		 push	 esi
  00007	89 45 10	 mov	 DWORD PTR $T41602[ebp], eax
  0000a	8d 45 10	 lea	 eax, DWORD PTR $T41602[ebp]
  0000d	50		 push	 eax
  0000e	8b f1		 mov	 esi, ecx
  00010	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00015	8b 45 08	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00018	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0001b	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp+4]
  0001e	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00021	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@

; 517  : 		_Makestr();
; 518  : 		}

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c2 0c 00	 ret	 12			; 0000000cH
??0system_error@std@@QAE@Verror_code@1@PBD@Z ENDP	; std::system_error::system_error
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@6
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@6:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
_DATA	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 237  : 			{	// construct with message

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00006	56		 push	 esi
  00007	ff 75 08	 push	 DWORD PTR __Message$[ebp]
  0000a	8b f1		 mov	 esi, ecx
  0000c	ff 70 04	 push	 DWORD PTR [eax+4]
  0000f	ff 30		 push	 DWORD PTR [eax]
  00011	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@

; 238  : 			}

  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
_TEXT	ENDS
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
; Function compile flags: /Ogsp
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ ; `string'
PUBLIC	__TI4?AVfailure@ios_base@std@@
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@	; `string'
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	__CTA4?AVfailure@ios_base@std@@
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\system_error
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT __CTA4?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA4?AVfailure@ios_base@std@@ DD 04H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ DB 'ios_base::failbit se'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT __TI4?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI4?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA4?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@ DB 'ios_base::badbit set', 00H ; `string'
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xiosbase
CONST	ENDS
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T41638 = -20						; size = 20
__State$ = 8						; size = 4
$T41733 = 12						; size = 4
$T41697 = 12						; size = 4
$T41661 = 12						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 310  : 		{	// set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 311  : 		_Mystate = (iostate)(_State & _Statmask);

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	83 e0 17	 and	 eax, 23			; 00000017H
  00009	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 312  : 		if ((_Mystate & _Except) == 0)

  0000c	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000f	83 ec 14	 sub	 esp, 20			; 00000014H
  00012	23 c8		 and	 ecx, eax
  00014	74 6c		 je	 SHORT $LN1@clear

; 313  : 			;
; 314  : 		else if (_Reraise)

  00016	33 c0		 xor	 eax, eax
  00018	38 45 0c	 cmp	 BYTE PTR __Reraise$[ebp], al
  0001b	74 07		 je	 SHORT $LN6@clear

; 315  : 			_RERAISE;

  0001d	50		 push	 eax
$LN57@clear:
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN59@clear:
$LN6@clear:

; 316  : 		else if (_Mystate & _Except & badbit)
; 317  : 			_THROW_NCEE(failure, "ios_base::badbit set");

  00024	33 f6		 xor	 esi, esi
  00026	46		 inc	 esi
  00027	f6 c1 04	 test	 cl, 4
  0002a	74 31		 je	 SHORT $LN4@clear
  0002c	e8 00 00 00 00	 call	 ?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
  00031	8b f8		 mov	 edi, eax
  00033	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR $T41661[ebp], OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN58@clear:
  0003a	8d 45 0c	 lea	 eax, DWORD PTR $T41661[ebp]
  0003d	50		 push	 eax
  0003e	8d 4d ec	 lea	 ecx, DWORD PTR $T41638[ebp]
  00041	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00046	89 75 f8	 mov	 DWORD PTR $T41638[ebp+12], esi
  00049	89 7d fc	 mov	 DWORD PTR $T41638[ebp+16], edi
  0004c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T41638[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00053	68 00 00 00 00	 push	 OFFSET __TI4?AVfailure@ios_base@std@@
  00058	8d 45 ec	 lea	 eax, DWORD PTR $T41638[ebp]
  0005b	eb c1		 jmp	 SHORT $LN57@clear
$LN4@clear:

; 318  : 		else if (_Mystate & _Except & failbit)

  0005d	f6 c1 02	 test	 cl, 2
  00060	74 10		 je	 SHORT $LN2@clear

; 319  : 			_THROW_NCEE(failure, "ios_base::failbit set");

  00062	e8 00 00 00 00	 call	 ?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
  00067	8b f8		 mov	 edi, eax
  00069	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR $T41697[ebp], OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  00070	eb c8		 jmp	 SHORT $LN58@clear
$LN2@clear:

; 320  : 		else
; 321  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

  00072	e8 00 00 00 00	 call	 ?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
  00077	8b f8		 mov	 edi, eax
  00079	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR $T41733[ebp], OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  00080	eb b8		 jmp	 SHORT $LN58@clear
$LN1@clear:

; 322  : 		}

  00082	c9		 leave
  00083	c2 08 00	 ret	 8
$LN56@clear:
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
  00014	8b c6		 mov	 eax, esi
  00016	5e		 pop	 esi
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@
  00016	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00019	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0001c	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0001f	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00022	5f		 pop	 edi
  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 07		 je	 SHORT $LN1@scalar@7
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
$LN1@scalar@7:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@ABV01@@Z
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@
  00014	8b c6		 mov	 eax, esi
  00016	5e		 pop	 esi
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogsp
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	?readCStyleComment@Reader@Json@@AAE_NXZ		; Json::Reader::readCStyleComment
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
;	COMDAT ?readCStyleComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
?readCStyleComment@Reader@Json@@AAE_NXZ PROC		; Json::Reader::readCStyleComment, COMDAT
; _this$ = ecx

; 428  :    while ( current_ != end_ )

  00000	eb 11		 jmp	 SHORT $LN1@readCStyle
$LL3@readCStyle:

; 429  :    {
; 430  :       Char c = getNextChar();

  00002	e8 00 00 00 00	 call	 ?getNextChar@Reader@Json@@AAEDXZ ; Json::Reader::getNextChar

; 431  :       if ( c == '*'  &&  *current_ == '/' )

  00007	3c 2a		 cmp	 al, 42			; 0000002aH
  00009	75 08		 jne	 SHORT $LN1@readCStyle
  0000b	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  0000e	80 38 2f	 cmp	 BYTE PTR [eax], 47	; 0000002fH
  00011	74 08		 je	 SHORT $LN7@readCStyle
$LN1@readCStyle:

; 428  :    while ( current_ != end_ )

  00013	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  00016	3b 41 50	 cmp	 eax, DWORD PTR [ecx+80]
  00019	75 e7		 jne	 SHORT $LL3@readCStyle
$LN7@readCStyle:

; 432  :          break;
; 433  :    }
; 434  :    return getNextChar() == '/';

  0001b	e8 00 00 00 00	 call	 ?getNextChar@Reader@Json@@AAEDXZ ; Json::Reader::getNextChar
  00020	33 c9		 xor	 ecx, ecx
  00022	3c 2f		 cmp	 al, 47			; 0000002fH
  00024	0f 94 c0	 sete	 al

; 435  : }

  00027	c3		 ret	 0
?readCStyleComment@Reader@Json@@AAE_NXZ ENDP		; Json::Reader::readCStyleComment
_TEXT	ENDS
PUBLIC	?readCppStyleComment@Reader@Json@@AAE_NXZ	; Json::Reader::readCppStyleComment
; Function compile flags: /Ogsp
;	COMDAT ?readCppStyleComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
?readCppStyleComment@Reader@Json@@AAE_NXZ PROC		; Json::Reader::readCppStyleComment, COMDAT
; _this$ = ecx

; 441  :    while ( current_ != end_ )

  00000	eb 0d		 jmp	 SHORT $LN10@readCppSty
$LL4@readCppSty:

; 442  :    {
; 443  :       Char c = getNextChar();

  00002	e8 00 00 00 00	 call	 ?getNextChar@Reader@Json@@AAEDXZ ; Json::Reader::getNextChar

; 444  :       if (  c == '\r'  ||  c == '\n' )

  00007	3c 0d		 cmp	 al, 13			; 0000000dH
  00009	74 0c		 je	 SHORT $LN8@readCppSty
  0000b	3c 0a		 cmp	 al, 10			; 0000000aH
  0000d	74 08		 je	 SHORT $LN8@readCppSty
$LN10@readCppSty:

; 441  :    while ( current_ != end_ )

  0000f	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  00012	3b 41 50	 cmp	 eax, DWORD PTR [ecx+80]
  00015	75 eb		 jne	 SHORT $LL4@readCppSty
$LN8@readCppSty:

; 445  :          break;
; 446  :    }
; 447  :    return true;

  00017	b0 01		 mov	 al, 1

; 448  : }

  00019	c3		 ret	 0
?readCppStyleComment@Reader@Json@@AAE_NXZ ENDP		; Json::Reader::readCppStyleComment
_TEXT	ENDS
PUBLIC	?readString@Reader@Json@@AAE_NXZ		; Json::Reader::readString
; Function compile flags: /Ogsp
;	COMDAT ?readString@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
?readString@Reader@Json@@AAE_NXZ PROC			; Json::Reader::readString, COMDAT
; _this$ = ecx

; 465  : {

  00000	53		 push	 ebx

; 466  :    Char c = 0;

  00001	32 db		 xor	 bl, bl

; 467  :    while ( current_ != end_ )

  00003	eb 18		 jmp	 SHORT $LN1@readString
$LL5@readString:

; 468  :    {
; 469  :       c = getNextChar();

  00005	e8 00 00 00 00	 call	 ?getNextChar@Reader@Json@@AAEDXZ ; Json::Reader::getNextChar
  0000a	8a d8		 mov	 bl, al

; 470  :       if ( c == '\\' )

  0000c	80 fb 5c	 cmp	 bl, 92			; 0000005cH
  0000f	75 07		 jne	 SHORT $LN3@readString

; 471  :          getNextChar();

  00011	e8 00 00 00 00	 call	 ?getNextChar@Reader@Json@@AAEDXZ ; Json::Reader::getNextChar
  00016	eb 05		 jmp	 SHORT $LN1@readString
$LN3@readString:

; 472  :       else if ( c == '"' )

  00018	80 fb 22	 cmp	 bl, 34			; 00000022H
  0001b	74 08		 je	 SHORT $LN9@readString
$LN1@readString:

; 467  :    while ( current_ != end_ )

  0001d	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  00020	3b 41 50	 cmp	 eax, DWORD PTR [ecx+80]
  00023	75 e0		 jne	 SHORT $LL5@readString
$LN9@readString:

; 473  :          break;
; 474  :    }
; 475  :    return c == '"';

  00025	33 c0		 xor	 eax, eax
  00027	80 fb 22	 cmp	 bl, 34			; 00000022H
  0002a	0f 94 c0	 sete	 al
  0002d	5b		 pop	 ebx

; 476  : }

  0002e	c3		 ret	 0
?readString@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readString
_TEXT	ENDS
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1435 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 
; 1438 : 		if (this->_Mysize <= _Off)
; 1439 : 
; 1440 : 			_DEBUG_ERROR("string subscript out of range");
; 1441 : 
; 1442 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1443 : 		_SCL_SECURE_VALIDATE_RANGE(_Off < this->_Mysize);
; 1444 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1445 : 
; 1446 : 		return (_Myptr()[_Off]);

  00005	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00009	72 02		 jb	 SHORT $LN5@operator@5
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN5@operator@5:
  0000d	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]

; 1447 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Ogsp
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1496 : 		return (_Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN5@c_str@3
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1497 : 		}

  00008	c3		 ret	 0

; 1496 : 		return (_Myptr());

$LN5@c_str@3:
  00009	8b c1		 mov	 eax, ecx

; 1497 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 3365 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3366 : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 07		 je	 SHORT $LN3@Yarn
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	59		 pop	 ecx
$LN3@Yarn:
  00010	83 26 00	 and	 DWORD PTR [esi], 0
  00013	5e		 pop	 esi

; 3367 : 		}

  00014	c3		 ret	 0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
PUBLIC	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sgetc, COMDAT
; _this$ = ecx

; 152  : 		return (0 < _Gnavail()
; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 07		 je	 SHORT $LN7@sgetc
  00008	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0000b	8b 12		 mov	 edx, DWORD PTR [edx]
  0000d	eb 02		 jmp	 SHORT $LN8@sgetc
$LN7@sgetc:
  0000f	33 d2		 xor	 edx, edx
$LN8@sgetc:
  00011	85 d2		 test	 edx, edx
  00013	7e 06		 jle	 SHORT $LN3@sgetc
  00015	8b 00		 mov	 eax, DWORD PTR [eax]
  00017	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 154  : 		}

  0001a	c3		 ret	 0
$LN3@sgetc:

; 152  : 		return (0 < _Gnavail()
; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

  0001b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001d	ff 60 18	 jmp	 DWORD PTR [eax+24]
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
_TEXT	ENDS
PUBLIC	?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stack
;	COMDAT ?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty, COMDAT
; _this$ = ecx

; 79   : 		return (c.empty());

  00000	33 c0		 xor	 eax, eax
  00002	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00005	0f 94 c0	 sete	 al

; 80   : 		}

  00008	c3		 ret	 0
?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1952 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1953 : 		_Traits::assign(_Myptr()[this->_Mysize = _Newsize], _Elem());

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0000a	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000d	72 02		 jb	 SHORT $LN5@Eos
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN5@Eos:
  00011	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1954 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1987 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1988 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 20		 je	 SHORT $LN9@Tidy@3

; 1989 : 			;
; 1990 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 1a		 jb	 SHORT $LN9@Tidy@3

; 1991 : 			{	// copy any leftovers to small buffer and deallocate
; 1992 : 			_Elem *_Ptr = this->_Bx._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 1993 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN7@Tidy@3

; 1994 : 				_Traits::copy(this->_Bx._Buf, _Ptr, _Newsize);

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@Tidy@3:

; 1995 : 			this->_Alval.deallocate(_Ptr, this->_Myres + 1);

  00028	53		 push	 ebx
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	59		 pop	 ecx
  0002f	5b		 pop	 ebx
$LN9@Tidy@3:

; 1996 : 			}
; 1997 : 		this->_Myres = this->_BUF_SIZE - 1;
; 1998 : 		_Eos(_Newsize);

  00030	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00033	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0003a	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi

; 1999 : 		}

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 454  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 455  : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 42   : 		{	// set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		ios_base::clear((iostate)(_Mystrbuf == 0
; 44   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

  00003	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00007	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  0000a	75 03		 jne	 SHORT $LN4@clear@2
  0000c	83 c8 04	 or	 eax, 4
$LN4@clear@2:
  0000f	ff 75 0c	 push	 DWORD PTR __Reraise$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 45   : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
PUBLIC	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc, COMDAT
; _this$ = ecx

; 146  : 		return (0 < _Gnavail()
; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 07		 je	 SHORT $LN7@sbumpc
  00008	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	eb 02		 jmp	 SHORT $LN8@sbumpc
$LN7@sbumpc:
  0000f	33 c0		 xor	 eax, eax
$LN8@sbumpc:
  00011	85 c0		 test	 eax, eax
  00013	7e 13		 jle	 SHORT $LN3@sbumpc
  00015	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00018	ff 08		 dec	 DWORD PTR [eax]
  0001a	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0001d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00022	89 11		 mov	 DWORD PTR [ecx], edx
  00024	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 148  : 		}

  00027	c3		 ret	 0
$LN3@sbumpc:

; 146  : 		return (0 < _Gnavail()
; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

  00028	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002a	ff 60 1c	 jmp	 DWORD PTR [eax+28]
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 310  : 	_Deque_const_iterator(size_type _Off, const _Container_base12 *_Pdeque)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 311  : 		{	// construct with offset _Off in *_Pdeque
; 312  : 		_Setcont((_Mydeque *)_Pdeque);

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdeque$[ebp]
  00008	83 20 00	 and	 DWORD PTR [eax], 0
  0000b	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0000f	85 c9		 test	 ecx, ecx
  00011	74 04		 je	 SHORT $LN7@Deque_cons
  00013	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00015	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Deque_cons:

; 313  : 		_Myoff = _Off;

  00017	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0001a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 314  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
PUBLIC	??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator==
; Function compile flags: /Ogsp
;	COMDAT ??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator==, COMDAT
; _this$ = ecx

; 474  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 475  : 		_Compat(_Right);
; 476  : 		return (this->_Myoff == _Right._Myoff);

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	2b 41 08	 sub	 eax, DWORD PTR [ecx+8]
  0000c	f7 d8		 neg	 eax
  0000e	1b c0		 sbb	 eax, eax
  00010	40		 inc	 eax

; 477  : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator==
_TEXT	ENDS
PUBLIC	??1?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::~_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::~_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::~_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1108 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 1109 : 		if (this->_Mysize < _Off)

  00007	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0000d	3b c1		 cmp	 eax, ecx
  0000f	73 0a		 jae	 SHORT $LN3@erase

; 1110 : 			_Xran();	// _Off off end

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00016	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN28@erase:
$LN3@erase:

; 1111 : 		if (this->_Mysize - _Off < _Count)

  0001b	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0001e	2b c1		 sub	 eax, ecx
  00020	3b c3		 cmp	 eax, ebx
  00022	73 02		 jae	 SHORT $LN2@erase

; 1112 : 			_Count = this->_Mysize - _Off;	// trim _Count

  00024	8b d8		 mov	 ebx, eax
$LN2@erase:

; 1113 : 		if (0 < _Count)

  00026	85 db		 test	 ebx, ebx
  00028	74 46		 je	 SHORT $LN25@erase

; 1114 : 			{	// move elements down
; 1115 : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 1116 : 				this->_Mysize - _Off - _Count);

  0002a	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0002d	57		 push	 edi
  0002e	83 fa 10	 cmp	 edx, 16			; 00000010H
  00031	72 04		 jb	 SHORT $LN11@erase
  00033	8b 3e		 mov	 edi, DWORD PTR [esi]
  00035	eb 02		 jmp	 SHORT $LN12@erase
$LN11@erase:
  00037	8b fe		 mov	 edi, esi
$LN12@erase:
  00039	83 fa 10	 cmp	 edx, 16			; 00000010H
  0003c	72 04		 jb	 SHORT $LN15@erase
  0003e	8b 16		 mov	 edx, DWORD PTR [esi]
  00040	eb 02		 jmp	 SHORT $LN16@erase
$LN15@erase:
  00042	8b d6		 mov	 edx, esi
$LN16@erase:
  00044	2b c3		 sub	 eax, ebx
  00046	03 f9		 add	 edi, ecx
  00048	50		 push	 eax
  00049	03 fb		 add	 edi, ebx
  0004b	03 d1		 add	 edx, ecx
  0004d	57		 push	 edi
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 _memmove

; 1117 : 			size_type _Newsize = this->_Mysize - _Count;

  00054	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	2b c3		 sub	 eax, ebx

; 1118 : 			_Eos(_Newsize);

  0005c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00060	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00063	5f		 pop	 edi
  00064	72 04		 jb	 SHORT $LN23@erase
  00066	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00068	eb 02		 jmp	 SHORT $LN24@erase
$LN23@erase:
  0006a	8b ce		 mov	 ecx, esi
$LN24@erase:
  0006c	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
$LN25@erase:

; 1119 : 			}
; 1120 : 		return (*this);

  00070	8b c6		 mov	 eax, esi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx

; 1121 : 		}

  00074	5d		 pop	 ebp
  00075	c2 08 00	 ret	 8
$LN27@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1516 : 		size_type _Num = this->_Alval.max_size();
; 1517 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	6a fe		 push	 -2			; fffffffeH
  00002	58		 pop	 eax

; 1518 : 		}

  00003	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value *>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z ; std::_Allocate<Json::Value *>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size, COMDAT
; _this$ = ecx

; 1155 : 		return (this->_Alval.max_size());

  00000	b8 5d 74 d1 05	 mov	 eax, 97612893		; 05d1745dH

; 1156 : 		}

  00005	c3		 ret	 0
?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo *>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 601  : 		{	// construct with offset _Off in *_Pdeque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 0c	 push	 DWORD PTR __Pdeque$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >

; 602  : 		}

  00011	8b c6		 mov	 eax, esi
  00013	5e		 pop	 esi
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
PUBLIC	??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator-
; Function compile flags: /Ogsp
;	COMDAT ??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator-, COMDAT
; _this$ = ecx

; 677  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 678  : 		return (*(_Mybase *)this - _Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00009	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000c	2b c2		 sub	 eax, edx

; 679  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator-
_TEXT	ENDS
PUBLIC	??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::operator*
; Function compile flags: /Ogsp
;	COMDAT ??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEAAPAVValue@Json@@XZ PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::operator*, COMDAT
; _this$ = ecx

; 619  : 		return ((reference)**(_Mybase *)this);

  00000	e9 00 00 00 00	 jmp	 ??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::operator*
??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEAAPAVValue@Json@@XZ ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::operator*
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
; Function compile flags: /Ogsp
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size, COMDAT
; _this$ = ecx

; 1155 : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1156 : 		}

  00005	c3		 ret	 0
?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value * *>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z ; std::_Allocate<Json::Value * *>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value * *>::allocate
_TEXT	ENDS
PUBLIC	??Z?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::operator-=
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ??Z?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::operator-=, COMDAT
; _this$ = ecx

; 666  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 667  : 		return (*this += -_Off);

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00008	29 48 08	 sub	 DWORD PTR [eax+8], ecx

; 668  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??Z?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::operator-=
_TEXT	ENDS
PUBLIC	??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 310  : 	_Deque_const_iterator(size_type _Off, const _Container_base12 *_Pdeque)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 311  : 		{	// construct with offset _Off in *_Pdeque
; 312  : 		_Setcont((_Mydeque *)_Pdeque);

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdeque$[ebp]
  00008	83 20 00	 and	 DWORD PTR [eax], 0
  0000b	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0000f	85 c9		 test	 ecx, ecx
  00011	74 04		 je	 SHORT $LN7@Deque_cons@2
  00013	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00015	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Deque_cons@2:

; 313  : 		_Myoff = _Off;

  00017	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0001a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 314  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
PUBLIC	??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator!=<char,char>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator!=<char,char>, COMDAT

; 271  : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 272  : 	}

  00002	c3		 ret	 0
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator!=<char,char>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@PAVValue@Json@@@std@@PAVValue@Json@@PAV34@@std@@YAXAAV?$allocator@PAVValue@Json@@@0@PAPAVValue@Json@@$$QAPAV23@@Z ; std::_Cons_val<std::allocator<Json::Value *>,Json::Value *,Json::Value *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@PAVValue@Json@@@std@@PAVValue@Json@@PAV34@@std@@YAXAAV?$allocator@PAVValue@Json@@@0@PAPAVValue@Json@@$$QAPAV23@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@PAVValue@Json@@@std@@PAVValue@Json@@PAV34@@std@@YAXAAV?$allocator@PAVValue@Json@@@0@PAPAVValue@Json@@$$QAPAV23@@Z PROC ; std::_Cons_val<std::allocator<Json::Value *>,Json::Value *,Json::Value *>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN7@Cons_val
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Cons_val:

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@PAVValue@Json@@@std@@PAVValue@Json@@PAV34@@std@@YAXAAV?$allocator@PAVValue@Json@@@0@PAPAVValue@Json@@$$QAPAV23@@Z ENDP ; std::_Cons_val<std::allocator<Json::Value *>,Json::Value *,Json::Value *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z
_TEXT	SEGMENT
__Cat$42146 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z PROC ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$42146[ebp]
  00007	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000a	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00010	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
  00018	83 c4 14	 add	 esp, 20			; 00000014H

; 415  : 	}

  0001b	c9		 leave
  0001c	c3		 ret	 0
??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z ENDP ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@@Z ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@@Z
_TEXT	SEGMENT
__Cat$42164 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@@Z PROC ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$42164[ebp]
  00007	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000a	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00010	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Value * *,Json::Value * *>
  00018	83 c4 14	 add	 esp, 20			; 00000014H

; 415  : 	}

  0001b	c9		 leave
  0001c	c3		 ret	 0
??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@@Z ENDP ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@@Z ; std::_Destroy_range<std::allocator<Json::Value * *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Json::Value * *> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Json::Value * *> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z ; std::allocator<Json::Value *>::destroy
; Function compile flags: /Ogsp
;	COMDAT ?destroy@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z PROC ; std::allocator<Json::Value *>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z ENDP ; std::allocator<Json::Value *>::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z ; std::allocator<Json::Value * *>::destroy
; Function compile flags: /Ogsp
;	COMDAT ?destroy@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z PROC ; std::allocator<Json::Value * *>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z ENDP ; std::allocator<Json::Value * *>::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo *>::destroy
; Function compile flags: /Ogsp
;	COMDAT ?destroy@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z ; std::allocator<std::_Container_proxy>::construct
; Function compile flags: /Ogsp
;	COMDAT ?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z PROC ; std::allocator<std::_Container_proxy>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct@2
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct@2:

; 203  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z ENDP ; std::allocator<std::_Container_proxy>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@@Z ; std::allocator<std::_Container_proxy>::destroy
; Function compile flags: /Ogsp
;	COMDAT ?destroy@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@@Z PROC ; std::allocator<std::_Container_proxy>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@IPAV123@PAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IPBQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<Json::Reader::ErrorInfo *,unsigned int,Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@IPAV123@PAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IPBQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T42215 = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@IPAV123@PAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IPBQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<Json::Reader::ErrorInfo *,unsigned int,Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>, COMDAT

; 660  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 661  : 	_Fill_n(_First, _Count, (_Valty)0);

  00004	83 65 fc 00	 and	 DWORD PTR $T42215[ebp], 0
  00008	8d 45 fc	 lea	 eax, DWORD PTR $T42215[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 662  : 	}

  0001a	c9		 leave
  0001b	c3		 ret	 0
??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@IPAV123@PAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IPBQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<Json::Reader::ErrorInfo *,unsigned int,Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
_TEXT	ENDS
PUBLIC	??$_Uninit_def_fill_n@PAPAVValue@Json@@IPAPAV12@PAPAV12@@std@@YAXPAPAPAVValue@Json@@IPBQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<Json::Value * *,unsigned int,Json::Value * *,Json::Value * *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Uninit_def_fill_n@PAPAVValue@Json@@IPAPAV12@PAPAV12@@std@@YAXPAPAPAVValue@Json@@IPBQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T42218 = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_def_fill_n@PAPAVValue@Json@@IPAPAV12@PAPAV12@@std@@YAXPAPAPAVValue@Json@@IPBQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<Json::Value * *,unsigned int,Json::Value * *,Json::Value * *>, COMDAT

; 660  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 661  : 	_Fill_n(_First, _Count, (_Valty)0);

  00004	83 65 fc 00	 and	 DWORD PTR $T42218[ebp], 0
  00008	8d 45 fc	 lea	 eax, DWORD PTR $T42218[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 662  : 	}

  0001a	c9		 leave
  0001b	c3		 ret	 0
??$_Uninit_def_fill_n@PAPAVValue@Json@@IPAPAV12@PAPAV12@@std@@YAXPAPAPAVValue@Json@@IPBQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<Json::Value * *,unsigned int,Json::Value * *,Json::Value * *>
_TEXT	ENDS
PUBLIC	??F?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator--
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ??F?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator--, COMDAT
; _this$ = ecx

; 641  : 		{	// predecrement

  00000	8b c1		 mov	 eax, ecx

; 642  : 		--*(_Mybase *)this;

  00002	ff 48 08	 dec	 DWORD PTR [eax+8]

; 643  : 		return (*this);
; 644  : 		}

  00005	c3		 ret	 0
??F?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator--
_TEXT	ENDS
PUBLIC	??0_Iterator_base12@std@@QAE@ABU01@@Z		; std::_Iterator_base12::_Iterator_base12
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0_Iterator_base12@std@@QAE@ABU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 116  : 		{	// copy an iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	83 20 00	 and	 DWORD PTR [eax], 0
  00008	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 117  : 		*this = _Right;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00011	85 c9		 test	 ecx, ecx
  00013	74 0a		 je	 SHORT $LN6@Iterator_b
  00015	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00017	85 c9		 test	 ecx, ecx
  00019	74 04		 je	 SHORT $LN6@Iterator_b
  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001d	89 08		 mov	 DWORD PTR [eax], ecx
$LN6@Iterator_b:

; 118  : 		}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??0_Iterator_base12@std@@QAE@ABU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@	; `string'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	__CTA2?AVruntime_error@std@@
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__EH_epilog3:PROC
EXTRN	__EH_prolog3:PROC
;	COMDAT __CTA2?AVruntime_error@std@@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stdexcept
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocinfo
xdata$x	ENDS
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T42243 = -28						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T42269 = 8						; size = 4
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 76   :         {	// construct from NTBS

  00000	6a 10		 push	 16			; 00000010H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0_Locinfo@std@@QAE@PBD@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	33 db		 xor	 ebx, ebx
  00013	53		 push	 ebx
  00014	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00019	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0001c	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001f	88 5e 08	 mov	 BYTE PTR [esi+8], bl
  00022	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00025	88 5e 10	 mov	 BYTE PTR [esi+16], bl
  00028	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  0002b	88 5e 18	 mov	 BYTE PTR [esi+24], bl
  0002e	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  00031	88 5e 20	 mov	 BYTE PTR [esi+32], bl
  00034	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 77   :         if (_Pch == 0)

  00038	39 5d 08	 cmp	 DWORD PTR __Pch$[ebp], ebx
  0003b	75 28		 jne	 SHORT $LN1@Locinfo

; 78   :             _THROW_NCEE(runtime_error, "bad locale name");

  0003d	8d 45 08	 lea	 eax, DWORD PTR $T42269[ebp]
  00040	50		 push	 eax
  00041	8d 4d e4	 lea	 ecx, DWORD PTR $T42243[ebp]
  00044	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T42269[ebp], OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
  0004b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00050	68 00 00 00 00	 push	 OFFSET __TI2?AVruntime_error@std@@
  00055	8d 45 e4	 lea	 eax, DWORD PTR $T42243[ebp]
  00058	50		 push	 eax
  00059	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T42243[ebp], OFFSET ??_7runtime_error@std@@6B@
  00060	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN22@Locinfo:
$LN1@Locinfo:

; 79   :         _Locinfo_ctor(this, _Pch);

  00065	ff 75 08	 push	 DWORD PTR __Pch$[ebp]
  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 ?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
  0006e	59		 pop	 ecx
  0006f	59		 pop	 ecx

; 80   :         }

  00070	8b c6		 mov	 eax, esi
  00072	e8 00 00 00 00	 call	 __EH_epilog3
  00077	c2 04 00	 ret	 4
$LN21@Locinfo:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 14	 add	 ecx, 20			; 00000014H
  00024	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002f	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
  00034	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00038	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003b	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0003e	33 c8		 xor	 ecx, eax
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
  0004a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1_Locinfo@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1_Locinfo@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$4
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocinfo
xdata$x	ENDS
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 93   :         {

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??1_Locinfo@std@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 94   :         _Locinfo_dtor(this);

  00011	56		 push	 esi
  00012	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  00019	e8 00 00 00 00	 call	 ?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor

; 95   :         }

  0001e	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00021	59		 pop	 ecx
  00022	85 c0		 test	 eax, eax
  00024	74 07		 je	 SHORT $LN10@Locinfo@2
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _free
  0002c	59		 pop	 ecx
$LN10@Locinfo@2:
  0002d	83 66 1c 00	 and	 DWORD PTR [esi+28], 0
  00031	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00034	85 c0		 test	 eax, eax
  00036	74 07		 je	 SHORT $LN15@Locinfo@2
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _free
  0003e	59		 pop	 ecx
$LN15@Locinfo@2:
  0003f	83 66 14 00	 and	 DWORD PTR [esi+20], 0
  00043	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00046	85 c0		 test	 eax, eax
  00048	74 07		 je	 SHORT $LN20@Locinfo@2
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _free
  00050	59		 pop	 ecx
$LN20@Locinfo@2:
  00051	83 66 0c 00	 and	 DWORD PTR [esi+12], 0
  00055	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00058	85 c0		 test	 eax, eax
  0005a	74 07		 je	 SHORT $LN25@Locinfo@2
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _free
  00062	59		 pop	 ecx
$LN25@Locinfo@2:
  00063	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00067	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0006b	8b ce		 mov	 ecx, esi
  0006d	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00072	e8 00 00 00 00	 call	 __EH_epilog3
  00077	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 14	 add	 ecx, 20			; 00000014H
  00024	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002f	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__ehhandler$??1_Locinfo@std@@QAE@XZ:
  00034	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00038	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003b	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0003e	33 c8		 xor	 ecx, eax
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
  0004a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
xdata$x	ENDS
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T42345 = -52						; size = 36
$T42349 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T42344 = 8						; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2371 : 		{	// return locale category mask and construct standard facet

  00000	6a 28		 push	 40			; 00000028H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 2372 : 		if (_Ppf != 0 && *_Ppf == 0)

  0000c	8b 7d 08	 mov	 edi, DWORD PTR __Ppf$[ebp]
  0000f	83 65 f0 00	 and	 DWORD PTR $T42349[ebp], 0
  00013	85 ff		 test	 edi, edi
  00015	74 5a		 je	 SHORT $LN9@Getcat
  00017	83 3f 00	 cmp	 DWORD PTR [edi], 0
  0001a	75 55		 jne	 SHORT $LN9@Getcat

; 2373 : 			*_Ppf = _NEW_CRT ctype<_Elem>(
; 2374 : 				_Locinfo(_Ploc->c_str()));

  0001c	6a 18		 push	 24			; 00000018H
  0001e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00023	59		 pop	 ecx
  00024	89 45 08	 mov	 DWORD PTR $T42344[ebp], eax
  00027	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	85 c0		 test	 eax, eax
  0002d	74 2c		 je	 SHORT $LN4@Getcat
  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00037	85 c9		 test	 ecx, ecx
  00039	75 03		 jne	 SHORT $LN15@Getcat
  0003b	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
$LN15@Getcat:
  0003e	51		 push	 ecx
  0003f	8d 4d cc	 lea	 ecx, DWORD PTR $T42345[ebp]
  00042	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00047	8b 4d 08	 mov	 ecx, DWORD PTR $T42344[ebp]
  0004a	6a 00		 push	 0
  0004c	50		 push	 eax
  0004d	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T42349[ebp], 1
  00054	e8 00 00 00 00	 call	 ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ; std::ctype<char>::ctype<char>
  00059	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  0005b	33 c0		 xor	 eax, eax
$LN5@Getcat:
  0005d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00061	f6 45 f0 01	 test	 BYTE PTR $T42349[ebp], 1
  00065	89 07		 mov	 DWORD PTR [edi], eax
  00067	74 08		 je	 SHORT $LN9@Getcat
  00069	8d 4d cc	 lea	 ecx, DWORD PTR $T42345[ebp]
  0006c	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN9@Getcat:

; 2375 : 		return (_X_CTYPE);

  00071	6a 02		 push	 2
  00073	58		 pop	 eax

; 2376 : 		}

  00074	e8 00 00 00 00	 call	 __EH_epilog3
  00079	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR $T42344[ebp]
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx
  00009	c3		 ret	 0
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0000a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00011	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 550  : 		{	// construct empty string

  00000	8b c1		 mov	 eax, ecx

; 551  : 		_Tidy();

  00002	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00006	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
  0000d	c6 00 00	 mov	 BYTE PTR [eax], 0

; 552  : 		}

  00010	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 753  : 		_Tidy(true);

  00000	6a 00		 push	 0
  00002	6a 01		 push	 1
  00004	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 754  : 		}

  00009	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 54   : 		{	// merge _State into state, possible reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 		if (_State != goodbit)

  00003	83 7d 08 00	 cmp	 DWORD PTR __State$[ebp], 0
  00007	74 18		 je	 SHORT $LN6@setstate

; 56   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

  00009	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000c	0b 45 08	 or	 eax, DWORD PTR __State$[ebp]
  0000f	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00013	75 03		 jne	 SHORT $LN8@setstate
  00015	83 c8 04	 or	 eax, 4
$LN8@setstate:
  00018	ff 75 0c	 push	 DWORD PTR __Reraise$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN6@setstate:

; 57   : 		}

  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
PUBLIC	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\streambuf
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::snextc, COMDAT
; _this$ = ecx

; 163  : 		{	// point to next character and return it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());

  00003	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00006	33 c0		 xor	 eax, eax
  00008	39 01		 cmp	 DWORD PTR [ecx], eax
  0000a	74 05		 je	 SHORT $LN9@snextc
  0000c	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN9@snextc:
  00011	83 f8 01	 cmp	 eax, 1
  00014	7e 12		 jle	 SHORT $LN5@snextc
  00016	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00019	ff 08		 dec	 DWORD PTR [eax]
  0001b	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0001e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00020	40		 inc	 eax
  00021	89 01		 mov	 DWORD PTR [ecx], eax
  00023	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00026	5e		 pop	 esi

; 168  : 		}

  00027	c3		 ret	 0
$LN5@snextc:

; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());

  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
  0002f	83 f8 ff	 cmp	 eax, -1
  00032	75 04		 jne	 SHORT $LN3@snextc
  00034	0b c0		 or	 eax, eax
  00036	5e		 pop	 esi

; 168  : 		}

  00037	c3		 ret	 0
$LN3@snextc:

; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());

  00038	8b ce		 mov	 ecx, esi
  0003a	5e		 pop	 esi
  0003b	e9 00 00 00 00	 jmp	 ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::snextc
_TEXT	ENDS
PUBLIC	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin, COMDAT
; _this$ = ecx

; 1055 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1056 : 		return (const_iterator(this->_Myoff, this));

  00003	51		 push	 ecx
  00004	ff 71 0c	 push	 DWORD PTR [ecx+12]
  00007	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1057 : 		}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
_TEXT	ENDS
PUBLIC	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end, COMDAT
; _this$ = ecx

; 1065 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1066 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
  00009	51		 push	 ecx
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1067 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
_TEXT	ENDS
PUBLIC	??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator!=
; Function compile flags: /Ogsp
;	COMDAT ??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator!=, COMDAT
; _this$ = ecx

; 480  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 481  : 		return (!(*this == _Right));

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  0000e	0f 95 c0	 setne	 al

; 482  : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  00010	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00013	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00016	5f		 pop	 edi
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
PUBLIC	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
; Function compile flags: /Ogsp
;	COMDAT ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin, COMDAT
; _this$ = ecx

; 1050 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1051 : 		return (iterator(this->_Myoff, this));

  00003	51		 push	 ecx
  00004	ff 71 0c	 push	 DWORD PTR [ecx+12]
  00007	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1052 : 		}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
_TEXT	ENDS
PUBLIC	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
; Function compile flags: /Ogsp
;	COMDAT ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end, COMDAT
; _this$ = ecx

; 1060 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1061 : 		return (iterator(this->_Myoff + this->_Mysize, this));

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
  00009	51		 push	 ecx
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1062 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
_TEXT	ENDS
PUBLIC	??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  00010	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00013	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00016	5f		 pop	 edi
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
EXTRN	__EH_prolog3_catch:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
tv296 = -20						; size = 4
__Newres$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1918 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	6a 0c		 push	 12			; 0000000cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi

; 1919 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00011	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  00014	83 cf 0f	 or	 edi, 15			; 0000000fH

; 1920 : 		if (max_size() < _Newres)

  00017	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0001a	76 05		 jbe	 SHORT $LN9@Copy

; 1921 : 			_Newres = _Newsize;	// undo roundup if too big

  0001c	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0001f	eb 27		 jmp	 SHORT $LN5@Copy
$LN9@Copy:

; 1922 : 		else if (this->_Myres / 2 <= _Newres / 3)

  00021	33 d2		 xor	 edx, edx
  00023	6a 03		 push	 3
  00025	8b c7		 mov	 eax, edi
  00027	5b		 pop	 ebx
  00028	f7 f3		 div	 ebx
  0002a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0002d	89 4d ec	 mov	 DWORD PTR tv296[ebp], ecx
  00030	d1 6d ec	 shr	 DWORD PTR tv296[ebp], 1
  00033	8b 55 ec	 mov	 edx, DWORD PTR tv296[ebp]
  00036	3b d0		 cmp	 edx, eax
  00038	76 0e		 jbe	 SHORT $LN5@Copy

; 1923 : 			;
; 1924 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

  0003a	6a fe		 push	 -2			; fffffffeH
  0003c	5f		 pop	 edi
  0003d	8b c7		 mov	 eax, edi
  0003f	2b c2		 sub	 eax, edx
  00041	3b c8		 cmp	 ecx, eax
  00043	77 03		 ja	 SHORT $LN5@Copy

; 1925 : 			_Newres = this->_Myres
; 1926 : 				+ this->_Myres / 2;	// grow exponentially if possible

  00045	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]
$LN5@Copy:

; 1927 : 		else
; 1928 : 			_Newres = max_size();	// settle for max_size()
; 1929 : 
; 1930 : 		_Elem *_Ptr;
; 1931 : 		_TRY_BEGIN

  00048	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1932 : 			_Ptr = this->_Alval.allocate(_Newres + 1);

  0004c	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0004f	6a 00		 push	 0
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>
  00057	59		 pop	 ecx
  00058	59		 pop	 ecx
  00059	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  0005c	eb 27		 jmp	 SHORT $LN19@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 1933 : 		_CATCH_ALL
; 1934 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  0005e	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00061	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00064	89 45 ec	 mov	 DWORD PTR __Newres$[ebp], eax

; 1935 : 			_TRY_BEGIN
; 1936 : 				_Ptr = this->_Alval.allocate(_Newres + 1);

  00067	40		 inc	 eax
  00068	6a 00		 push	 0
  0006a	50		 push	 eax
  0006b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  0006f	e8 00 00 00 00	 call	 ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>
  00074	59		 pop	 ecx
  00075	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  00078	59		 pop	 ecx

; 1940 : 			_CATCH_END
; 1941 : 		_CATCH_END

  00079	b8 00 00 00 00	 mov	 eax, $LN63@Copy
  0007e	c3		 ret	 0
$LN63@Copy:
  0007f	8b 75 e8	 mov	 esi, DWORD PTR _this$[ebp]
  00082	8b 7d ec	 mov	 edi, DWORD PTR __Newres$[ebp]
$LN19@Copy:

; 1942 : 
; 1943 : 		if (0 < _Oldlen)

  00085	8b 5d 0c	 mov	 ebx, DWORD PTR __Oldlen$[ebp]
  00088	85 db		 test	 ebx, ebx
  0008a	74 19		 je	 SHORT $LN52@Copy

; 1944 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

  0008c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00090	72 04		 jb	 SHORT $LN50@Copy
  00092	8b 06		 mov	 eax, DWORD PTR [esi]
  00094	eb 02		 jmp	 SHORT $LN51@Copy
$LN50@Copy:
  00096	8b c6		 mov	 eax, esi
$LN51@Copy:
  00098	53		 push	 ebx
  00099	50		 push	 eax
  0009a	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0009d	e8 00 00 00 00	 call	 _memcpy
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN52@Copy:

; 1945 : 		_Tidy(true);

  000a5	6a 00		 push	 0
  000a7	6a 01		 push	 1
  000a9	8b ce		 mov	 ecx, esi
  000ab	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1946 : 		this->_Bx._Ptr = _Ptr;

  000b0	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000b3	89 06		 mov	 DWORD PTR [esi], eax

; 1947 : 		this->_Myres = _Newres;

  000b5	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 1948 : 		_Eos(_Oldlen);

  000b8	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000bb	83 ff 10	 cmp	 edi, 16			; 00000010H
  000be	73 02		 jae	 SHORT $LN59@Copy
  000c0	8b c6		 mov	 eax, esi
$LN59@Copy:
  000c2	c6 04 18 00	 mov	 BYTE PTR [eax+ebx], 0

; 1949 : 		}

  000c6	e8 00 00 00 00	 call	 __EH_epilog3
  000cb	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 1937 : 			_CATCH_ALL
; 1938 : 			_Tidy(true);	// failed again, discard storage and reraise

  000ce	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	33 f6		 xor	 esi, esi
  000d3	56		 push	 esi
  000d4	6a 01		 push	 1
  000d6	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1939 : 			_RERAISE;

  000db	56		 push	 esi
  000dc	56		 push	 esi
  000dd	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN67@Copy:
$LN66@Copy:
  000e2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter, COMDAT
; _this$ = ecx

; 1070 : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1071 : 		return (iterator(_Where._Myoff, this));

  00003	51		 push	 ecx
  00004	ff 75 14	 push	 DWORD PTR __Where$[ebp+8]
  00007	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1072 : 		}

  00012	5d		 pop	 ebp
  00013	c2 10 00	 ret	 16			; 00000010H
?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter
_TEXT	ENDS
PUBLIC	??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  00010	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00013	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00016	5f		 pop	 edi
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
PUBLIC	??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 601  : 		{	// construct with offset _Off in *_Pdeque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 0c	 push	 DWORD PTR __Pdeque$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >

; 602  : 		}

  00011	8b c6		 mov	 eax, esi
  00013	5e		 pop	 esi
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
EXTRN	??0bad_cast@std@@QAE@PBD@Z:PROC			; std::bad_cast::bad_cast
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	??1bad_cast@std@@UAE@XZ:PROC			; std::bad_cast::~bad_cast
EXTRN	??0bad_cast@std@@QAE@ABV01@@Z:PROC		; std::bad_cast::bad_cast
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T42673 = -32						; size = 12
__Lock$37546 = -20					; size = 4
__Psave$37547 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 504  : 	{	// get facet reference from locale

  00000	6a 14		 push	 20			; 00000014H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 505  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  0000c	6a 00		 push	 0
  0000e	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$37546[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 506  : 		const locale::facet *_Psave =
; 507  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  00016	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  0001c	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 508  : 
; 509  : 		size_t _Id = _Facet::id;

  00020	b9 00 00 00 00	 mov	 ecx, OFFSET ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
  00025	89 75 f0	 mov	 DWORD PTR __Psave$37547[ebp], esi
  00028	e8 00 00 00 00	 call	 ??Bid@locale@std@@QAEIXZ ; std::locale::id::operator unsigned int

; 510  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
  00036	8b f8		 mov	 edi, eax

; 511  : 
; 512  : 		if (_Pf != 0)

  00038	85 ff		 test	 edi, edi
  0003a	75 4d		 jne	 SHORT $LN10@use_facet

; 513  : 			;	// got facet from locale
; 514  : 		else if (_Psave != 0)

  0003c	85 f6		 test	 esi, esi
  0003e	74 04		 je	 SHORT $LN4@use_facet

; 515  : 			_Pf = _Psave;	// lazy facet already allocated

  00040	8b fe		 mov	 edi, esi
  00042	eb 45		 jmp	 SHORT $LN10@use_facet
$LN4@use_facet:

; 516  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  00044	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  00047	8d 45 f0	 lea	 eax, DWORD PTR __Psave$37547[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
  00050	59		 pop	 ecx
  00051	59		 pop	 ecx
  00052	83 f8 ff	 cmp	 eax, -1
  00055	75 1b		 jne	 SHORT $LN2@use_facet

; 517  : 
; 518  :  #if _HAS_EXCEPTIONS
; 519  : 
; 520  : 			_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  00057	68 00 00 00 00	 push	 OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  0005c	8d 4d e0	 lea	 ecx, DWORD PTR $T42673[ebp]
  0005f	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@PBD@Z ; std::bad_cast::bad_cast
  00064	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  00069	8d 45 e0	 lea	 eax, DWORD PTR $T42673[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@use_facet:
$LN2@use_facet:

; 521  : 
; 522  :  #else /* _HAS_EXCEPTIONS */
; 523  : 			abort();	// lazy disallowed
; 524  :  #endif /* _HAS_EXCEPTIONS */
; 525  : 
; 526  : 		else
; 527  : 			{	// queue up lazy facet for destruction
; 528  : 			_Pf = _Psave;

  00072	8b 7d f0	 mov	 edi, DWORD PTR __Psave$37547[ebp]

; 529  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 530  : 
; 531  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 532  : 			_Pfmod->_Incref();

  00075	8b cf		 mov	 ecx, edi
  00077	89 3d 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, edi ; std::_Facetptr<std::ctype<char> >::_Psave
  0007d	e8 00 00 00 00	 call	 ?_Incref@facet@locale@std@@QAEXXZ ; std::locale::facet::_Incref

; 533  : 			_Pfmod->_Register();

  00082	57		 push	 edi
  00083	e8 00 00 00 00	 call	 ?_Facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::_Facet_Register
  00088	59		 pop	 ecx
$LN10@use_facet:

; 534  : 			}
; 535  : 
; 536  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00089	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0008d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$37546[ebp]
  00090	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00095	8b c7		 mov	 eax, edi

; 537  : 	_END_LOCK()
; 538  : 	}

  00097	e8 00 00 00 00	 call	 __EH_epilog3
  0009c	c3		 ret	 0
$LN13@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$37546[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
PUBLIC	??$_Dest_val@V?$allocator@PAVValue@Json@@@std@@PAVValue@Json@@@std@@YAXAAV?$allocator@PAVValue@Json@@@0@PAPAVValue@Json@@@Z ; std::_Dest_val<std::allocator<Json::Value *>,Json::Value *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@PAVValue@Json@@@std@@PAVValue@Json@@@std@@YAXAAV?$allocator@PAVValue@Json@@@0@PAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@PAVValue@Json@@@std@@PAVValue@Json@@@std@@YAXAAV?$allocator@PAVValue@Json@@@0@PAPAVValue@Json@@@Z PROC ; std::_Dest_val<std::allocator<Json::Value *>,Json::Value *>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@PAVValue@Json@@@std@@PAVValue@Json@@@std@@YAXAAV?$allocator@PAVValue@Json@@@0@PAPAVValue@Json@@@Z ENDP ; std::_Dest_val<std::allocator<Json::Value *>,Json::Value *>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@PAPAVValue@Json@@@std@@PAPAVValue@Json@@@std@@YAXAAV?$allocator@PAPAVValue@Json@@@0@PAPAPAVValue@Json@@@Z ; std::_Dest_val<std::allocator<Json::Value * *>,Json::Value * *>
; Function compile flags: /Ogsp
;	COMDAT ??$_Dest_val@V?$allocator@PAPAVValue@Json@@@std@@PAPAVValue@Json@@@std@@YAXAAV?$allocator@PAPAVValue@Json@@@0@PAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@PAPAVValue@Json@@@std@@PAPAVValue@Json@@@std@@YAXAAV?$allocator@PAPAVValue@Json@@@0@PAPAPAVValue@Json@@@Z PROC ; std::_Dest_val<std::allocator<Json::Value * *>,Json::Value * *>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@PAPAVValue@Json@@@std@@PAPAVValue@Json@@@std@@YAXAAV?$allocator@PAPAVValue@Json@@@0@PAPAPAVValue@Json@@@Z ENDP ; std::_Dest_val<std::allocator<Json::Value * *>,Json::Value * *>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@@Z ; std::_Dest_val<std::allocator<std::_Container_proxy>,std::_Container_proxy>
; Function compile flags: /Ogsp
;	COMDAT ??$_Dest_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@@Z PROC ; std::_Dest_val<std::allocator<std::_Container_proxy>,std::_Container_proxy>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@@Z ENDP ; std::_Dest_val<std::allocator<std::_Container_proxy>,std::_Container_proxy>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IPBQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IPBQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z
_TEXT	SEGMENT
$T42735 = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Pval$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IPBQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 670  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 671  : 	_Uninit_def_fill_n(_First, _Count, _Pval, _Al,
; 672  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  00004	83 65 fc 00	 and	 DWORD PTR $T42735[ebp], 0
  00008	8d 45 fc	 lea	 eax, DWORD PTR $T42735[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 673  : 	}

  0001a	c9		 leave
  0001b	c3		 ret	 0
??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IPBQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAVErrorInfo@Reader@Json@@@std@@YAXAAV?$allocator@PAVErrorInfo@Reader@Json@@@0@PAPAVErrorInfo@Reader@Json@@@Z ; std::_Dest_val<std::allocator<Json::Reader::ErrorInfo *>,Json::Reader::ErrorInfo *>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAVErrorInfo@Reader@Json@@@std@@YAXAAV?$allocator@PAVErrorInfo@Reader@Json@@@0@PAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAVErrorInfo@Reader@Json@@@std@@YAXAAV?$allocator@PAVErrorInfo@Reader@Json@@@0@PAPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Dest_val<std::allocator<Json::Reader::ErrorInfo *>,Json::Reader::ErrorInfo *>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAVErrorInfo@Reader@Json@@@std@@YAXAAV?$allocator@PAVErrorInfo@Reader@Json@@@0@PAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Dest_val<std::allocator<Json::Reader::ErrorInfo *>,Json::Reader::ErrorInfo *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::_Container_proxy>,std::_Container_proxy,std::_Container_proxy>
; Function compile flags: /Ogsp
;	COMDAT ??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z PROC ; std::_Cons_val<std::allocator<std::_Container_proxy>,std::_Container_proxy,std::_Container_proxy>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val@2
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val@2:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::_Container_proxy>,std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IPBQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@@Z ; std::_Uninitialized_default_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IPBQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@@Z
_TEXT	SEGMENT
$T42787 = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Pval$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IPBQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >, COMDAT

; 670  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 671  : 	_Uninit_def_fill_n(_First, _Count, _Pval, _Al,
; 672  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  00004	83 65 fc 00	 and	 DWORD PTR $T42787[ebp], 0
  00008	8d 45 fc	 lea	 eax, DWORD PTR $T42787[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 673  : 	}

  0001a	c9		 leave
  0001b	c3		 ret	 0
??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IPBQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >
_TEXT	ENDS
PUBLIC	??0ErrorInfo@Reader@Json@@QAE@XZ		; Json::Reader::ErrorInfo::ErrorInfo
; Function compile flags: /Ogsp
;	COMDAT ??0ErrorInfo@Reader@Json@@QAE@XZ
_TEXT	SEGMENT
??0ErrorInfo@Reader@Json@@QAE@XZ PROC			; Json::Reader::ErrorInfo::ErrorInfo, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	83 60 1c 00	 and	 DWORD PTR [eax+28], 0
  00006	c7 40 20 0f 00
	00 00		 mov	 DWORD PTR [eax+32], 15	; 0000000fH
  0000d	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
  00011	c3		 ret	 0
??0ErrorInfo@Reader@Json@@QAE@XZ ENDP			; Json::Reader::ErrorInfo::ErrorInfo
_TEXT	ENDS
PUBLIC	??1ErrorInfo@Reader@Json@@QAE@XZ		; Json::Reader::ErrorInfo::~ErrorInfo
; Function compile flags: /Ogsp
;	COMDAT ??1ErrorInfo@Reader@Json@@QAE@XZ
_TEXT	SEGMENT
??1ErrorInfo@Reader@Json@@QAE@XZ PROC			; Json::Reader::ErrorInfo::~ErrorInfo, COMDAT
; _this$ = ecx
  00000	6a 00		 push	 0
  00002	6a 01		 push	 1
  00004	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00007	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  0000c	c3		 ret	 0
??1ErrorInfo@Reader@Json@@QAE@XZ ENDP			; Json::Reader::ErrorInfo::~ErrorInfo
_TEXT	ENDS
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ostream
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 570  : 		{	// flush output stream

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 571  : 		ios_base::iostate _State = ios_base::goodbit;
; 572  : 		if (!ios_base::fail() && _Myios::rdbuf()->pubsync() == -1)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	f6 44 30 0c 06	 test	 BYTE PTR [eax+esi+12], 6
  00010	75 13		 jne	 SHORT $LN1@flush
  00012	8b 44 30 38	 mov	 eax, DWORD PTR [eax+esi+56]
  00016	8b 10		 mov	 edx, DWORD PTR [eax]
  00018	8b c8		 mov	 ecx, eax
  0001a	ff 52 34	 call	 DWORD PTR [edx+52]
  0001d	83 f8 ff	 cmp	 eax, -1
  00020	75 03		 jne	 SHORT $LN1@flush

; 573  : 			_State |= ios_base::badbit;	// sync failed

  00022	6a 04		 push	 4
  00024	5f		 pop	 edi
$LN1@flush:

; 574  : 		_Myios::setstate(_State);

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002a	6a 00		 push	 0
  0002c	57		 push	 edi
  0002d	03 ce		 add	 ecx, esi
  0002f	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  00034	5f		 pop	 edi

; 575  : 		return (*this);

  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi

; 576  : 		}

  00038	c3		 ret	 0
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1958 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1959 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0000a	76 0a		 jbe	 SHORT $LN6@Grow

; 1960 : 			_Xlen();	// result too long

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN31@Grow:
$LN6@Grow:

; 1961 : 		if (this->_Myres < _Newsize)

  00016	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00019	3b c6		 cmp	 eax, esi
  0001b	73 0b		 jae	 SHORT $LN5@Grow

; 1962 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

  0001d	ff 71 10	 push	 DWORD PTR [ecx+16]
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00026	eb 2f		 jmp	 SHORT $LN28@Grow
$LN5@Grow:

; 1963 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00028	33 d2		 xor	 edx, edx
  0002a	38 55 0c	 cmp	 BYTE PTR __Trim$[ebp], dl
  0002d	74 18		 je	 SHORT $LN3@Grow
  0002f	83 fe 10	 cmp	 esi, 16			; 00000010H
  00032	73 13		 jae	 SHORT $LN3@Grow

; 1964 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1965 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

  00034	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00037	3b f0		 cmp	 esi, eax
  00039	73 02		 jae	 SHORT $LN9@Grow
  0003b	8b c6		 mov	 eax, esi
$LN9@Grow:
  0003d	50		 push	 eax
  0003e	6a 01		 push	 1
  00040	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00045	eb 10		 jmp	 SHORT $LN28@Grow
$LN3@Grow:

; 1966 : 		else if (_Newsize == 0)

  00047	3b f2		 cmp	 esi, edx
  00049	75 0c		 jne	 SHORT $LN28@Grow

; 1967 : 			_Eos(0);	// new size is zero, just null terminate

  0004b	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0004e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00051	72 02		 jb	 SHORT $LN26@Grow
  00053	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN26@Grow:
  00055	88 11		 mov	 BYTE PTR [ecx], dl
$LN28@Grow:

; 1968 : 		return (0 < _Newsize);	// return true only if more work to do

  00057	33 c0		 xor	 eax, eax
  00059	3b c6		 cmp	 eax, esi
  0005b	1b c0		 sbb	 eax, eax
  0005d	f7 d8		 neg	 eax
  0005f	5e		 pop	 esi

; 1969 : 		}

  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
$LN30@Grow:
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
PUBLIC	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\ios
xdata$x	SEGMENT
__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$12 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0
__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$12
__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T42971 = 8						; size = 4
__Noskip$ = 8						; size = 1
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Ipfx, COMDAT
; _this$ = ecx

; 116  : 		{	// test stream state and skip whitespace as needed

  00000	6a 08		 push	 8
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 117  : 		if (ios_base::good())

  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00016	03 ce		 add	 ecx, esi
  00018	33 db		 xor	 ebx, ebx
  0001a	39 59 0c	 cmp	 DWORD PTR [ecx+12], ebx
  0001d	0f 85 e6 00 00
	00		 jne	 $LN1@Ipfx

; 118  : 			{	// state okay, flush tied stream and skip whitespace
; 119  : 			if (_Myios::tie() != 0)

  00023	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  00026	3b cb		 cmp	 ecx, ebx
  00028	74 05		 je	 SHORT $LN10@Ipfx

; 120  : 				_Myios::tie()->flush();

  0002a	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN10@Ipfx:

; 121  : 
; 122  : 			if (!_Noskip && ios_base::flags() & ios_base::skipws)

  0002f	38 5d 08	 cmp	 BYTE PTR __Noskip$[ebp], bl
  00032	75 78		 jne	 SHORT $LN17@Ipfx
  00034	8b 06		 mov	 eax, DWORD PTR [esi]
  00036	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00039	8b 4c 31 14	 mov	 ecx, DWORD PTR [ecx+esi+20]
  0003d	f6 c1 01	 test	 cl, 1
  00040	74 6a		 je	 SHORT $LN17@Ipfx

; 123  : 				{	// skip whitespace
; 124  : 				const _Ctype& _Ctype_fac = _USE(ios_base::getloc(), _Ctype);

  00042	8d 4d 08	 lea	 ecx, DWORD PTR $T42971[ebp]
  00045	51		 push	 ecx
  00046	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00049	03 ce		 add	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00050	50		 push	 eax
  00051	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  00054	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00059	59		 pop	 ecx
  0005a	8d 4d 08	 lea	 ecx, DWORD PTR $T42971[ebp]
  0005d	8b f8		 mov	 edi, eax
  0005f	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale

; 125  : 
; 126  : 				_TRY_IO_BEGIN
; 127  : 				int_type _Meta = _Myios::rdbuf()->sgetc();

  00064	8b 06		 mov	 eax, DWORD PTR [esi]
  00066	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00069	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  0006d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00074	e8 00 00 00 00	 call	 ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
$LL7@Ipfx:

; 130  : 					if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  00079	83 f8 ff	 cmp	 eax, -1
  0007c	75 1e		 jne	 SHORT $LN4@Ipfx

; 131  : 						{	// end of file, quit
; 132  : 						_Myios::setstate(ios_base::eofbit);

  0007e	8b 06		 mov	 eax, DWORD PTR [esi]
  00080	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00083	03 ce		 add	 ecx, esi
  00085	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00088	83 c8 01	 or	 eax, 1
  0008b	39 59 38	 cmp	 DWORD PTR [ecx+56], ebx
  0008e	75 03		 jne	 SHORT $LN44@Ipfx
  00090	83 c8 04	 or	 eax, 4
$LN44@Ipfx:
  00093	53		 push	 ebx
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 133  : 						break;

  0009a	eb 0c		 jmp	 SHORT $LN5@Ipfx
$LN4@Ipfx:

; 134  : 						}
; 135  : 					else if (!_Ctype_fac.is(_Ctype::space,
; 136  : 						_Traits::to_char_type(_Meta)))

  0009c	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0009f	0f b6 c0	 movzx	 eax, al
  000a2	f6 04 41 48	 test	 BYTE PTR [ecx+eax*2], 72 ; 00000048H
  000a6	75 14		 jne	 SHORT $LN6@Ipfx
$LN5@Ipfx:
  000a8	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
$LN17@Ipfx:

; 139  : 				}
; 140  : 
; 141  : 			if (ios_base::good())

  000ac	8b 06		 mov	 eax, DWORD PTR [esi]
  000ae	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b1	03 ce		 add	 ecx, esi
  000b3	39 59 0c	 cmp	 DWORD PTR [ecx+12], ebx
  000b6	75 51		 jne	 SHORT $LN1@Ipfx

; 142  : 				return (true);

  000b8	b0 01		 mov	 al, 1
  000ba	eb 64		 jmp	 SHORT $LN12@Ipfx
$LN6@Ipfx:

; 128  : 
; 129  : 				for (; ; _Meta = _Myios::rdbuf()->snextc())

  000bc	8b 06		 mov	 eax, DWORD PTR [esi]
  000be	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c1	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  000c5	e8 00 00 00 00	 call	 ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
  000ca	eb ad		 jmp	 SHORT $LL7@Ipfx
__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0:

; 137  : 						break;	// not whitespace, quit
; 138  : 				_CATCH_IO_END

  000cc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	8b 01		 mov	 eax, DWORD PTR [ecx]
  000d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d4	03 c1		 add	 eax, ecx
  000d6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000d9	33 db		 xor	 ebx, ebx
  000db	83 c9 04	 or	 ecx, 4
  000de	39 58 38	 cmp	 DWORD PTR [eax+56], ebx
  000e1	75 03		 jne	 SHORT $LN57@Ipfx
  000e3	83 c9 04	 or	 ecx, 4
$LN57@Ipfx:
  000e6	83 e1 17	 and	 ecx, 23			; 00000017H
  000e9	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  000ec	85 48 10	 test	 DWORD PTR [eax+16], ecx
  000ef	75 11		 jne	 SHORT $LN66@Ipfx
  000f1	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  000f5	b8 00 00 00 00	 mov	 eax, $LN18@Ipfx
  000fa	c3		 ret	 0
$LN18@Ipfx:
  000fb	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000fe	33 db		 xor	 ebx, ebx
  00100	eb aa		 jmp	 SHORT $LN17@Ipfx
$LN66@Ipfx:
  00102	53		 push	 ebx
  00103	53		 push	 ebx
  00104	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN137@Ipfx:
$LN1@Ipfx:

; 143  : 			}
; 144  : 		_Myios::setstate(ios_base::failbit);

  00109	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0010c	83 c8 02	 or	 eax, 2
  0010f	39 59 38	 cmp	 DWORD PTR [ecx+56], ebx
  00112	75 03		 jne	 SHORT $LN128@Ipfx
  00114	83 c8 04	 or	 eax, 4
$LN128@Ipfx:
  00117	53		 push	 ebx
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 145  : 		return (false);

  0011e	32 c0		 xor	 al, al
$LN12@Ipfx:

; 146  : 		}

  00120	e8 00 00 00 00	 call	 __EH_epilog3
  00125	c2 04 00	 ret	 4
$LN136@Ipfx:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR $T42971[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
PUBLIC	?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back, COMDAT
; _this$ = ecx

; 1273 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1274 : 		if (empty())
; 1275 : 			_DEBUG_ERROR("deque empty before pop");
; 1276 : 		else
; 1277 : 			{	// something to erase, do it
; 1278 : 			_Orphan_off(this->_Myoff + this->_Mysize - 1);
; 1279 : 			size_type _Newoff = this->_Mysize + this->_Myoff - 1;
; 1280 : 			size_type _Block = _Newoff / _DEQUESIZ;
; 1281 : 			if (this->_Mapsize <= _Block)
; 1282 : 				_Block -= this->_Mapsize;
; 1283 : 			_Dest_val(this->_Alval,
; 1284 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1285 : 			if (--this->_Mysize == 0)
; 1286 : 				this->_Myoff = 0;
; 1287 : 			}
; 1288 : 
; 1289 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1290 : 		if (!empty())

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	85 c0		 test	 eax, eax
  00005	74 0a		 je	 SHORT $LN1@pop_back

; 1291 : 			{	// something to erase, do it
; 1292 : 			size_type _Newoff = this->_Mysize + this->_Myoff - 1;
; 1293 : 			size_type _Block = _Newoff / _DEQUESIZ;
; 1294 : 			if (this->_Mapsize <= _Block)
; 1295 : 				_Block -= this->_Mapsize;
; 1296 : 			_Dest_val(this->_Alval,
; 1297 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1298 : 			if (--this->_Mysize == 0)

  00007	48		 dec	 eax
  00008	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000b	75 04		 jne	 SHORT $LN1@pop_back

; 1299 : 				this->_Myoff = 0;

  0000d	83 61 0c 00	 and	 DWORD PTR [ecx+12], 0
$LN1@pop_back:

; 1300 : 			}
; 1301 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1302 : 		}

  00011	c3		 ret	 0
?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
_TEXT	ENDS
PUBLIC	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy, COMDAT
; _this$ = ecx

; 1638 : 		{	// free all storage

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 1639 : 		while (!empty())

  00004	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00007	33 db		 xor	 ebx, ebx
  00009	3b c3		 cmp	 eax, ebx
  0000b	74 12		 je	 SHORT $LN5@Tidy@4
$LL6@Tidy@4:

; 1640 : 			pop_back();

  0000d	3b c3		 cmp	 eax, ebx
  0000f	74 09		 je	 SHORT $LN11@Tidy@4
  00011	48		 dec	 eax
  00012	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00015	75 03		 jne	 SHORT $LN11@Tidy@4
  00017	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
$LN11@Tidy@4:

; 1639 : 		while (!empty())

  0001a	39 5e 10	 cmp	 DWORD PTR [esi+16], ebx
  0001d	75 ee		 jne	 SHORT $LL6@Tidy@4
$LN5@Tidy@4:
  0001f	57		 push	 edi

; 1641 : 		for (size_type _Count = this->_Mapsize; 0 < _Count; )

  00020	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00023	eb 10		 jmp	 SHORT $LN36@Tidy@4
$LL4@Tidy@4:

; 1642 : 			{	// free storage for a block and destroy pointer
; 1643 : 			if (*(this->_Map + --_Count) != 0)

  00025	4f		 dec	 edi
  00026	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  00029	39 18		 cmp	 DWORD PTR [eax], ebx
  0002b	74 08		 je	 SHORT $LN36@Tidy@4

; 1644 : 				{	// free block and destroy its pointer
; 1645 : 				this->_Alval.deallocate(*(this->_Map + _Count), _DEQUESIZ);

  0002d	ff 30		 push	 DWORD PTR [eax]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00034	59		 pop	 ecx
$LN36@Tidy@4:

; 1646 : 				_Dest_val(this->_Almap, this->_Map + _Count);
; 1647 : 				}
; 1648 : 			}
; 1649 : 
; 1650 : 		if (this->_Map != 0)

  00035	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00038	3b fb		 cmp	 edi, ebx
  0003a	77 e9		 ja	 SHORT $LL4@Tidy@4
  0003c	5f		 pop	 edi
  0003d	3b c3		 cmp	 eax, ebx
  0003f	74 07		 je	 SHORT $LN32@Tidy@4

; 1651 : 			this->_Almap.deallocate(this->_Map,
; 1652 : 				this->_Mapsize);	// free storage for map

  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00047	59		 pop	 ecx
$LN32@Tidy@4:

; 1653 : 		this->_Mapsize = 0;

  00048	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 1654 : 		this->_Map = 0;

  0004b	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx

; 1655 : 		}

  00050	c3		 ret	 0
?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
_TEXT	ENDS
PUBLIC	??1?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::~_Deque_val<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::~_Deque_val<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 742  : 		{	// destroy proxy

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 743  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 744  : 			_Alproxy(_Alval);
; 745  : 		this->_Orphan_all();
; 746  : 		_Dest_val(_Alproxy, this->_Myproxy);
; 747  : 		_Alproxy.deallocate(this->_Myproxy, 1);

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 748  : 		this->_Myproxy = 0;

  0000a	83 26 00	 and	 DWORD PTR [esi], 0
  0000d	59		 pop	 ecx
  0000e	5e		 pop	 esi

; 749  : 		}

  0000f	c3		 ret	 0
??1?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::~_Deque_val<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
PUBLIC	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
; Function compile flags: /Ogsp
;	COMDAT ?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T43630 = -8						; size = 4
$T43605 = -8						; size = 4
$T43565 = -8						; size = 4
__Newmap$ = -4						; size = 4
__Cat$43655 = 8						; size = 1
$T43683 = 8						; size = 4
__Cat$43641 = 8						; size = 1
__Cat$43577 = 8						; size = 1
__Cat$43563 = 8						; size = 1
__Myboff$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap, COMDAT
; _this$ = ecx

; 1589 : 		{	// grow map by _Count pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx

; 1590 : 		if (max_size() / _DEQUESIZ - this->_Mapsize < _Count)

  00006	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000f	ba 5d 74 d1 05	 mov	 edx, 97612893		; 05d1745dH
  00014	8b ca		 mov	 ecx, edx
  00016	2b c8		 sub	 ecx, eax
  00018	3b cb		 cmp	 ecx, ebx
  0001a	73 0a		 jae	 SHORT $LN6@Growmap

; 1591 : 			_Xlen();	// result too long

  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  00021	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN75@Growmap:
$LN6@Growmap:

; 1592 : 
; 1593 : 		size_type _Inc = this->_Mapsize / 2;	// try to grow by 50%

  00026	8b c8		 mov	 ecx, eax
  00028	d1 e9		 shr	 ecx, 1

; 1594 : 		if (_Inc < _DEQUEMAPSIZ)

  0002a	83 f9 08	 cmp	 ecx, 8
  0002d	73 03		 jae	 SHORT $LN5@Growmap

; 1595 : 			_Inc = _DEQUEMAPSIZ;

  0002f	6a 08		 push	 8
  00031	59		 pop	 ecx
$LN5@Growmap:

; 1596 : 		if (_Count < _Inc && this->_Mapsize <= max_size() / _DEQUESIZ - _Inc)

  00032	3b d9		 cmp	 ebx, ecx
  00034	73 08		 jae	 SHORT $LN4@Growmap
  00036	2b d1		 sub	 edx, ecx
  00038	3b c2		 cmp	 eax, edx
  0003a	77 02		 ja	 SHORT $LN4@Growmap

; 1597 : 			_Count = _Inc;

  0003c	8b d9		 mov	 ebx, ecx
$LN4@Growmap:
  0003e	57		 push	 edi

; 1598 : 		size_type _Myboff = this->_Myoff / _DEQUESIZ;

  0003f	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]

; 1599 : 		_Mapptr _Newmap = this->_Almap.allocate(this->_Mapsize + _Count);

  00042	03 c3		 add	 eax, ebx
  00044	6a 00		 push	 0
  00046	50		 push	 eax
  00047	89 7d 08	 mov	 DWORD PTR __Myboff$[ebp], edi
  0004a	e8 00 00 00 00	 call	 ??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo *>

; 1600 : 		_Mapptr _Myptr = _Newmap + _Myboff;
; 1601 : 
; 1602 : 		_Myptr = _Uninitialized_copy(this->_Map + _Myboff,
; 1603 : 			this->_Map + this->_Mapsize,
; 1604 : 			_Myptr, this->_Almap);	// copy initial to end

  0004f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00052	ff 75 08	 push	 DWORD PTR __Cat$43563[ebp]
  00055	8b c8		 mov	 ecx, eax
  00057	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0005a	8d 14 90	 lea	 edx, DWORD PTR [eax+edx*4]
  0005d	c1 e7 02	 shl	 edi, 2
  00060	03 c7		 add	 eax, edi
  00062	89 45 f8	 mov	 DWORD PTR $T43565[ebp], eax
  00065	8d 46 15	 lea	 eax, DWORD PTR [esi+21]
  00068	50		 push	 eax
  00069	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  0006c	50		 push	 eax
  0006d	52		 push	 edx
  0006e	ff 75 f8	 push	 DWORD PTR $T43565[ebp]
  00071	89 4d fc	 mov	 DWORD PTR __Newmap$[ebp], ecx
  00074	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>

; 1605 : 		if (_Myboff <= _Count)
; 1606 : 			{	// increment greater than offset of initial block
; 1607 : 			_Myptr = _Uninitialized_copy(this->_Map,
; 1608 : 				this->_Map + _Myboff,
; 1609 : 				_Myptr, this->_Almap);	// copy rest of old

  00079	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0007c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0007f	39 5d 08	 cmp	 DWORD PTR __Myboff$[ebp], ebx
  00082	77 40		 ja	 SHORT $LN3@Growmap

; 1610 : 			_Uninitialized_default_fill_n(_Myptr, _Count - _Myboff,
; 1611 : 				(pointer *)0, this->_Almap);	// clear suffix of new

  00084	83 65 f8 00	 and	 DWORD PTR $T43605[ebp], 0
  00088	8d 55 f8	 lea	 edx, DWORD PTR $T43605[ebp]
  0008b	52		 push	 edx
  0008c	8b d3		 mov	 edx, ebx
  0008e	2b 55 08	 sub	 edx, DWORD PTR __Myboff$[ebp]
  00091	03 f9		 add	 edi, ecx
  00093	52		 push	 edx
  00094	ff 75 08	 push	 DWORD PTR __Cat$43577[ebp]
  00097	8d 56 15	 lea	 edx, DWORD PTR [esi+21]
  0009a	52		 push	 edx
  0009b	50		 push	 eax
  0009c	57		 push	 edi
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
  000a3	83 c4 14	 add	 esp, 20			; 00000014H
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>

; 1612 : 			_Uninitialized_default_fill_n(_Newmap, _Myboff,
; 1613 : 				(pointer *)0, this->_Almap);	// clear prefix of new

  000ac	83 65 f8 00	 and	 DWORD PTR $T43630[ebp], 0
  000b0	8d 45 f8	 lea	 eax, DWORD PTR $T43630[ebp]
  000b3	50		 push	 eax
  000b4	ff 75 08	 push	 DWORD PTR __Myboff$[ebp]
  000b7	ff 75 fc	 push	 DWORD PTR __Newmap$[ebp]
  000ba	e8 00 00 00 00	 call	 ??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
  000bf	83 c4 18	 add	 esp, 24			; 00000018H

; 1614 : 			}
; 1615 : 		else

  000c2	eb 43		 jmp	 SHORT $LN64@Growmap
$LN3@Growmap:

; 1616 : 			{	// increment not greater than offset of initial block
; 1617 : 			_Uninitialized_copy(this->_Map,
; 1618 : 				this->_Map + _Count,
; 1619 : 				_Myptr, this->_Almap);	// copy more old

  000c4	ff 75 08	 push	 DWORD PTR __Cat$43641[ebp]
  000c7	8d 56 15	 lea	 edx, DWORD PTR [esi+21]
  000ca	52		 push	 edx
  000cb	50		 push	 eax
  000cc	8d 04 99	 lea	 eax, DWORD PTR [ecx+ebx*4]
  000cf	50		 push	 eax
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>

; 1620 : 			_Myptr = _Uninitialized_copy(this->_Map + _Count,
; 1621 : 				this->_Map + _Myboff,
; 1622 : 				_Newmap, this->_Almap);	// copy rest of old
; 1623 : 			_Uninitialized_default_fill_n(_Myptr, _Count,
; 1624 : 				(pointer *)0, this->_Almap);	// clear rest to initial block

  000d6	83 65 08 00	 and	 DWORD PTR $T43683[ebp], 0
  000da	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000dd	83 c4 14	 add	 esp, 20			; 00000014H
  000e0	8d 4d 08	 lea	 ecx, DWORD PTR $T43683[ebp]
  000e3	51		 push	 ecx
  000e4	53		 push	 ebx
  000e5	ff 75 08	 push	 DWORD PTR __Cat$43655[ebp]
  000e8	8d 4e 15	 lea	 ecx, DWORD PTR [esi+21]
  000eb	51		 push	 ecx
  000ec	ff 75 fc	 push	 DWORD PTR __Newmap$[ebp]
  000ef	03 f8		 add	 edi, eax
  000f1	8d 04 98	 lea	 eax, DWORD PTR [eax+ebx*4]
  000f4	57		 push	 edi
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
  000fb	83 c4 14	 add	 esp, 20			; 00000014H
  000fe	50		 push	 eax
  000ff	e8 00 00 00 00	 call	 ??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
  00104	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN64@Growmap:

; 1625 : 			}
; 1626 : 
; 1627 : 		_Destroy_range(this->_Map + _Myboff, this->_Map + this->_Mapsize,
; 1628 : 			this->_Almap);
; 1629 : 		if (this->_Map != 0)

  00107	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0010a	5f		 pop	 edi
  0010b	85 c0		 test	 eax, eax
  0010d	74 07		 je	 SHORT $LN72@Growmap

; 1630 : 			this->_Almap.deallocate(this->_Map,
; 1631 : 				this->_Mapsize);	// free storage for old

  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00115	59		 pop	 ecx
$LN72@Growmap:

; 1632 : 
; 1633 : 		this->_Map = _Newmap;	// point at new

  00116	8b 45 fc	 mov	 eax, DWORD PTR __Newmap$[ebp]

; 1634 : 		this->_Mapsize += _Count;

  00119	01 5e 08	 add	 DWORD PTR [esi+8], ebx
  0011c	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0011f	5e		 pop	 esi
  00120	5b		 pop	 ebx

; 1635 : 		}

  00121	c9		 leave
  00122	c2 04 00	 ret	 4
$LN74@Growmap:
?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
_TEXT	ENDS
PUBLIC	??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
$T43746 = -16						; size = 12
$T43729 = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 728  : 		{	// construct allocators from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	33 ff		 xor	 edi, edi

; 729  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 730  : 			_Alproxy(_Alval);
; 731  : 		this->_Myproxy = _Alproxy.allocate(1);

  0000c	6a 08		 push	 8
  0000e	89 3e		 mov	 DWORD PTR [esi], edi
  00010	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00015	59		 pop	 ecx
  00016	3b c7		 cmp	 eax, edi
  00018	74 23		 je	 SHORT $LN13@Deque_val
  0001a	89 06		 mov	 DWORD PTR [esi], eax

; 732  : 		_Cons_val(_Alproxy, this->_Myproxy, _Container_proxy());

  0001c	33 c9		 xor	 ecx, ecx
  0001e	89 08		 mov	 DWORD PTR [eax], ecx
  00020	33 d2		 xor	 edx, edx
  00022	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 733  : 		this->_Myproxy->_Mycont = this;

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	89 30		 mov	 DWORD PTR [eax], esi

; 734  : 
; 735  : 		_Map = 0;

  00029	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 736  : 		_Mapsize = 0;

  0002c	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 737  : 		_Myoff = 0;

  0002f	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 738  : 		_Mysize = 0;

  00032	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00035	5f		 pop	 edi

; 739  : 		}

  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi
  00039	c9		 leave
  0003a	c2 04 00	 ret	 4

; 729  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 730  : 			_Alproxy(_Alval);
; 731  : 		this->_Myproxy = _Alproxy.allocate(1);

$LN13@Deque_val:
  0003d	8d 45 fc	 lea	 eax, DWORD PTR $T43729[ebp]
  00040	50		 push	 eax
  00041	8d 4d f0	 lea	 ecx, DWORD PTR $T43746[ebp]
  00044	89 7d fc	 mov	 DWORD PTR $T43729[ebp], edi
  00047	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0004c	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00051	8d 45 f0	 lea	 eax, DWORD PTR $T43746[ebp]
  00054	50		 push	 eax
  00055	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T43746[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0005c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN38@Deque_val:
$LN37@Deque_val:
  00061	cc		 int	 3
??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
PUBLIC	??1?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 742  : 		{	// destroy proxy

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 743  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 744  : 			_Alproxy(_Alval);
; 745  : 		this->_Orphan_all();
; 746  : 		_Dest_val(_Alproxy, this->_Myproxy);
; 747  : 		_Alproxy.deallocate(this->_Myproxy, 1);

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 748  : 		this->_Myproxy = 0;

  0000a	83 26 00	 and	 DWORD PTR [esi], 0
  0000d	59		 pop	 ecx
  0000e	5e		 pop	 esi

; 749  : 		}

  0000f	c3		 ret	 0
??1?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
PUBLIC	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator+
; Function compile flags: /Ogsp
;	COMDAT ??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator+, COMDAT
; _this$ = ecx

; 660  : 		{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi

; 661  : 		_Myiter _Tmp = *this;

  0000a	56		 push	 esi
  0000b	8d 4d f4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12

; 662  : 		return (_Tmp += _Off);

  00013	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00016	03 75 0c	 add	 esi, DWORD PTR __Off$[ebp]
  00019	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __Tmp$[ebp]
  0001f	50		 push	 eax
  00020	8b cf		 mov	 ecx, edi
  00022	89 75 fc	 mov	 DWORD PTR __Tmp$[ebp+8], esi
  00025	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0002a	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002d	8b c7		 mov	 eax, edi
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi

; 663  : 		}

  00031	c9		 leave
  00032	c2 08 00	 ret	 8
??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator+
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 798  : 		{	// append _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 799  : 		if (_Right.size() < _Roff)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	3b 45 0c	 cmp	 eax, DWORD PTR __Roff$[ebp]
  00010	73 0a		 jae	 SHORT $LN4@append

; 800  : 			_Xran();	// _Roff off end

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00017	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN36@append:
$LN4@append:

; 801  : 		size_type _Num = _Right.size() - _Roff;

  0001c	2b 45 0c	 sub	 eax, DWORD PTR __Roff$[ebp]

; 802  : 		if (_Num < _Count)

  0001f	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp]
  00022	3b c3		 cmp	 eax, ebx
  00024	73 02		 jae	 SHORT $LN3@append

; 803  : 			_Count = _Num;	// trim _Count to size

  00026	8b d8		 mov	 ebx, eax
$LN3@append:

; 804  : 		if (npos - this->_Mysize <= _Count)

  00028	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002b	83 c9 ff	 or	 ecx, -1
  0002e	2b c8		 sub	 ecx, eax
  00030	3b cb		 cmp	 ecx, ebx
  00032	77 0a		 ja	 SHORT $LN2@append

; 805  : 			_Xlen();	// result too long

  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00039	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN37@append:
$LN2@append:

; 806  : 
; 807  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

  0003e	85 db		 test	 ebx, ebx
  00040	74 50		 je	 SHORT $LN32@append
  00042	57		 push	 edi
  00043	8d 3c 18	 lea	 edi, DWORD PTR [eax+ebx]
  00046	6a 00		 push	 0
  00048	57		 push	 edi
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00050	84 c0		 test	 al, al
  00052	74 3d		 je	 SHORT $LN34@append

; 808  : 			{	// make room and append new stuff
; 809  : 			_Traits::copy(_Myptr() + this->_Mysize,
; 810  : 				_Right._Myptr() + _Roff, _Count);

  00054	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00057	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0005b	72 02		 jb	 SHORT $LN18@append
  0005d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN18@append:
  0005f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00063	72 04		 jb	 SHORT $LN22@append
  00065	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00067	eb 02		 jmp	 SHORT $LN23@append
$LN22@append:
  00069	8b ce		 mov	 ecx, esi
$LN23@append:
  0006b	03 45 0c	 add	 eax, DWORD PTR __Roff$[ebp]
  0006e	53		 push	 ebx
  0006f	50		 push	 eax
  00070	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00073	03 c1		 add	 eax, ecx
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _memcpy
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 811  : 			_Eos(_Num);

  0007e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00082	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00085	72 04		 jb	 SHORT $LN30@append
  00087	8b 06		 mov	 eax, DWORD PTR [esi]
  00089	eb 02		 jmp	 SHORT $LN31@append
$LN30@append:
  0008b	8b c6		 mov	 eax, esi
$LN31@append:
  0008d	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN34@append:
  00091	5f		 pop	 edi
$LN32@append:

; 812  : 			}
; 813  : 		return (*this);

  00092	8b c6		 mov	 eax, esi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx

; 814  : 		}

  00096	5d		 pop	 ebp
  00097	c2 0c 00	 ret	 12			; 0000000cH
$LN35@append:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogsp
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 817  : 		{	// append [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 818  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 819  : 		if (_Count != 0)
; 820  : 			_DEBUG_POINTER(_Ptr);
; 821  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 822  : 
; 823  : 		if (_Inside(_Ptr))

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
  00010	84 c0		 test	 al, al
  00012	74 1c		 je	 SHORT $LN3@append@2

; 824  : 			return (append(*this, _Ptr - _Myptr(), _Count));	// substring

  00014	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00018	72 04		 jb	 SHORT $LN8@append@2
  0001a	8b 06		 mov	 eax, DWORD PTR [esi]
  0001c	eb 02		 jmp	 SHORT $LN9@append@2
$LN8@append@2:
  0001e	8b c6		 mov	 eax, esi
$LN9@append@2:
  00020	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00023	2b f8		 sub	 edi, eax
  00025	57		 push	 edi
  00026	56		 push	 esi
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0002e	eb 63		 jmp	 SHORT $LN4@append@2
$LN3@append@2:

; 825  : 		if (npos - this->_Mysize <= _Count)

  00030	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00033	83 c9 ff	 or	 ecx, -1
  00036	53		 push	 ebx
  00037	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0003a	2b c8		 sub	 ecx, eax
  0003c	3b cb		 cmp	 ecx, ebx
  0003e	77 0a		 ja	 SHORT $LN2@append@2

; 826  : 			_Xlen();	// result too long

  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00045	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN28@append@2:
$LN2@append@2:

; 827  : 
; 828  : 		size_type _Num;
; 829  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

  0004a	85 db		 test	 ebx, ebx
  0004c	74 42		 je	 SHORT $LN25@append@2
  0004e	8d 3c 18	 lea	 edi, DWORD PTR [eax+ebx]
  00051	6a 00		 push	 0
  00053	57		 push	 edi
  00054	8b ce		 mov	 ecx, esi
  00056	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  0005b	84 c0		 test	 al, al
  0005d	74 31		 je	 SHORT $LN25@append@2

; 830  : 			{	// make room and append new stuff
; 831  : 			_Traits::copy(_Myptr() + this->_Mysize, _Ptr, _Count);

  0005f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00063	72 04		 jb	 SHORT $LN15@append@2
  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	eb 02		 jmp	 SHORT $LN16@append@2
$LN15@append@2:
  00069	8b c6		 mov	 eax, esi
$LN16@append@2:
  0006b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0006e	53		 push	 ebx
  0006f	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00072	03 c8		 add	 ecx, eax
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _memcpy
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 832  : 			_Eos(_Num);

  0007d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00081	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00084	72 04		 jb	 SHORT $LN23@append@2
  00086	8b 06		 mov	 eax, DWORD PTR [esi]
  00088	eb 02		 jmp	 SHORT $LN24@append@2
$LN23@append@2:
  0008a	8b c6		 mov	 eax, esi
$LN24@append@2:
  0008c	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN25@append@2:

; 833  : 			}
; 834  : 		return (*this);

  00090	8b c6		 mov	 eax, esi
  00092	5b		 pop	 ebx
$LN4@append@2:
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi

; 835  : 		}

  00095	5d		 pop	 ebp
  00096	c2 08 00	 ret	 8
$LN27@append@2:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogsp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 892  : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 893  : 		if (_Right.size() < _Roff)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  00010	57		 push	 edi
  00011	3b c1		 cmp	 eax, ecx
  00013	73 0a		 jae	 SHORT $LN5@assign

; 894  : 			_Xran();	// _Roff off end

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0001a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN34@assign:
$LN5@assign:

; 895  : 		size_type _Num = _Right.size() - _Roff;

  0001f	2b c1		 sub	 eax, ecx
  00021	8b f8		 mov	 edi, eax

; 896  : 		if (_Count < _Num)

  00023	39 7d 10	 cmp	 DWORD PTR __Count$[ebp], edi
  00026	73 03		 jae	 SHORT $LN4@assign

; 897  : 			_Num = _Count;	// trim _Num to size

  00028	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
$LN4@assign:

; 898  : 
; 899  : 		if (this == &_Right)

  0002b	3b f3		 cmp	 esi, ebx
  0002d	75 1a		 jne	 SHORT $LN3@assign

; 900  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0002f	03 f9		 add	 edi, ecx
  00031	6a ff		 push	 -1
  00033	57		 push	 edi
  00034	8b ce		 mov	 ecx, esi
  00036	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0003b	ff 75 0c	 push	 DWORD PTR __Roff$[ebp]
  0003e	8b ce		 mov	 ecx, esi
  00040	6a 00		 push	 0
  00042	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00047	eb 47		 jmp	 SHORT $LN31@assign
$LN3@assign:

; 901  : 		else if (_Grow(_Num))

  00049	6a 00		 push	 0
  0004b	57		 push	 edi
  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00053	84 c0		 test	 al, al
  00055	74 39		 je	 SHORT $LN31@assign

; 902  : 			{	// make room and assign new stuff
; 903  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

  00057	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  0005b	72 04		 jb	 SHORT $LN17@assign
  0005d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0005f	eb 02		 jmp	 SHORT $LN18@assign
$LN17@assign:
  00061	8b c3		 mov	 eax, ebx
$LN18@assign:
  00063	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00067	72 04		 jb	 SHORT $LN21@assign
  00069	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0006b	eb 02		 jmp	 SHORT $LN22@assign
$LN21@assign:
  0006d	8b ce		 mov	 ecx, esi
$LN22@assign:
  0006f	03 45 0c	 add	 eax, DWORD PTR __Roff$[ebp]
  00072	57		 push	 edi
  00073	50		 push	 eax
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _memcpy
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 904  : 			_Eos(_Num);

  0007d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00081	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00084	72 04		 jb	 SHORT $LN29@assign
  00086	8b 06		 mov	 eax, DWORD PTR [esi]
  00088	eb 02		 jmp	 SHORT $LN30@assign
$LN29@assign:
  0008a	8b c6		 mov	 eax, esi
$LN30@assign:
  0008c	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN31@assign:

; 905  : 			}
; 906  : 		return (*this);

  00090	5f		 pop	 edi
  00091	8b c6		 mov	 eax, esi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx

; 907  : 		}

  00095	5d		 pop	 ebp
  00096	c2 0c 00	 ret	 12			; 0000000cH
$LN33@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@2@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end, COMDAT
; _this$ = ecx

; 1060 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1061 : 		return (iterator(this->_Myoff + this->_Mysize, this));

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
  00009	51		 push	 ecx
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1062 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@2@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
_TEXT	ENDS
PUBLIC	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
; Function compile flags: /Ogsp
;	COMDAT ?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T44212 = -12						; size = 4
$T44159 = -12						; size = 4
__Myptr$ = -12						; size = 4
$T44134 = -8						; size = 4
$T44096 = -8						; size = 4
__Newmap$ = -4						; size = 4
__Cat$44186 = 8						; size = 1
__Cat$44172 = 8						; size = 1
__Cat$44108 = 8						; size = 1
__Cat$44094 = 8						; size = 1
__Count$ = 8						; size = 4
?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap, COMDAT
; _this$ = ecx

; 1589 : 		{	// grow map by _Count pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1590 : 		if (max_size() / _DEQUESIZ - this->_Mapsize < _Count)

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	ba ff ff ff 0f	 mov	 edx, 268435455		; 0fffffffH
  00011	8b ca		 mov	 ecx, edx
  00013	2b c8		 sub	 ecx, eax
  00015	3b 4d 08	 cmp	 ecx, DWORD PTR __Count$[ebp]
  00018	73 0a		 jae	 SHORT $LN6@Growmap@2

; 1591 : 			_Xlen();	// result too long

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  0001f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN75@Growmap@2:
$LN6@Growmap@2:

; 1592 : 
; 1593 : 		size_type _Inc = this->_Mapsize / 2;	// try to grow by 50%

  00024	8b c8		 mov	 ecx, eax
  00026	d1 e9		 shr	 ecx, 1

; 1594 : 		if (_Inc < _DEQUEMAPSIZ)

  00028	83 f9 08	 cmp	 ecx, 8
  0002b	73 03		 jae	 SHORT $LN5@Growmap@2

; 1595 : 			_Inc = _DEQUEMAPSIZ;

  0002d	6a 08		 push	 8
  0002f	59		 pop	 ecx
$LN5@Growmap@2:

; 1596 : 		if (_Count < _Inc && this->_Mapsize <= max_size() / _DEQUESIZ - _Inc)

  00030	39 4d 08	 cmp	 DWORD PTR __Count$[ebp], ecx
  00033	73 09		 jae	 SHORT $LN4@Growmap@2
  00035	2b d1		 sub	 edx, ecx
  00037	3b c2		 cmp	 eax, edx
  00039	77 03		 ja	 SHORT $LN4@Growmap@2

; 1597 : 			_Count = _Inc;

  0003b	89 4d 08	 mov	 DWORD PTR __Count$[ebp], ecx
$LN4@Growmap@2:

; 1598 : 		size_type _Myboff = this->_Myoff / _DEQUESIZ;
; 1599 : 		_Mapptr _Newmap = this->_Almap.allocate(this->_Mapsize + _Count);

  0003e	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00041	53		 push	 ebx
  00042	57		 push	 edi
  00043	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  00046	6a 00		 push	 0
  00048	50		 push	 eax
  00049	c1 ef 02	 shr	 edi, 2
  0004c	e8 00 00 00 00	 call	 ??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z ; std::_Allocate<Json::Value * *>

; 1600 : 		_Mapptr _Myptr = _Newmap + _Myboff;
; 1601 : 
; 1602 : 		_Myptr = _Uninitialized_copy(this->_Map + _Myboff,
; 1603 : 			this->_Map + this->_Mapsize,
; 1604 : 			_Myptr, this->_Almap);	// copy initial to end

  00051	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00054	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00057	ff 75 08	 push	 DWORD PTR __Cat$44094[ebp]
  0005a	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  0005d	8b df		 mov	 ebx, edi
  0005f	c1 e3 02	 shl	 ebx, 2
  00062	03 cb		 add	 ecx, ebx
  00064	89 4d f8	 mov	 DWORD PTR $T44096[ebp], ecx
  00067	8d 4e 15	 lea	 ecx, DWORD PTR [esi+21]
  0006a	51		 push	 ecx
  0006b	89 45 fc	 mov	 DWORD PTR __Newmap$[ebp], eax
  0006e	03 c3		 add	 eax, ebx
  00070	50		 push	 eax
  00071	52		 push	 edx
  00072	ff 75 f8	 push	 DWORD PTR $T44096[ebp]
  00075	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Value * *,Json::Value * *>

; 1605 : 		if (_Myboff <= _Count)

  0007a	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]

; 1606 : 			{	// increment greater than offset of initial block
; 1607 : 			_Myptr = _Uninitialized_copy(this->_Map,
; 1608 : 				this->_Map + _Myboff,
; 1609 : 				_Myptr, this->_Almap);	// copy rest of old

  0007d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00080	83 c4 1c	 add	 esp, 28			; 0000001cH
  00083	89 45 f4	 mov	 DWORD PTR __Myptr$[ebp], eax
  00086	3b fa		 cmp	 edi, edx
  00088	77 3d		 ja	 SHORT $LN3@Growmap@2

; 1610 : 			_Uninitialized_default_fill_n(_Myptr, _Count - _Myboff,
; 1611 : 				(pointer *)0, this->_Almap);	// clear suffix of new

  0008a	83 65 f8 00	 and	 DWORD PTR $T44134[ebp], 0
  0008e	8d 45 f8	 lea	 eax, DWORD PTR $T44134[ebp]
  00091	50		 push	 eax
  00092	2b d7		 sub	 edx, edi
  00094	52		 push	 edx
  00095	ff 75 08	 push	 DWORD PTR __Cat$44108[ebp]
  00098	8d 56 15	 lea	 edx, DWORD PTR [esi+21]
  0009b	52		 push	 edx
  0009c	ff 75 f4	 push	 DWORD PTR __Myptr$[ebp]
  0009f	03 d9		 add	 ebx, ecx
  000a1	53		 push	 ebx
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Value * *,Json::Value * *>
  000a8	83 c4 14	 add	 esp, 20			; 00000014H
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>

; 1612 : 			_Uninitialized_default_fill_n(_Newmap, _Myboff,
; 1613 : 				(pointer *)0, this->_Almap);	// clear prefix of new

  000b1	83 65 f4 00	 and	 DWORD PTR $T44159[ebp], 0
  000b5	8d 45 f4	 lea	 eax, DWORD PTR $T44159[ebp]
  000b8	50		 push	 eax
  000b9	57		 push	 edi
  000ba	ff 75 fc	 push	 DWORD PTR __Newmap$[ebp]
  000bd	e8 00 00 00 00	 call	 ??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
  000c2	83 c4 18	 add	 esp, 24			; 00000018H

; 1614 : 			}
; 1615 : 		else

  000c5	eb 49		 jmp	 SHORT $LN64@Growmap@2
$LN3@Growmap@2:

; 1616 : 			{	// increment not greater than offset of initial block
; 1617 : 			_Uninitialized_copy(this->_Map,
; 1618 : 				this->_Map + _Count,
; 1619 : 				_Myptr, this->_Almap);	// copy more old

  000c7	ff 75 08	 push	 DWORD PTR __Cat$44172[ebp]
  000ca	8b fa		 mov	 edi, edx
  000cc	8d 56 15	 lea	 edx, DWORD PTR [esi+21]
  000cf	52		 push	 edx
  000d0	50		 push	 eax
  000d1	c1 e7 02	 shl	 edi, 2
  000d4	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  000d7	50		 push	 eax
  000d8	51		 push	 ecx
  000d9	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Value * *,Json::Value * *>

; 1620 : 			_Myptr = _Uninitialized_copy(this->_Map + _Count,
; 1621 : 				this->_Map + _Myboff,
; 1622 : 				_Newmap, this->_Almap);	// copy rest of old

  000de	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 1623 : 			_Uninitialized_default_fill_n(_Myptr, _Count,
; 1624 : 				(pointer *)0, this->_Almap);	// clear rest to initial block

  000e1	83 65 f4 00	 and	 DWORD PTR $T44212[ebp], 0
  000e5	83 c4 14	 add	 esp, 20			; 00000014H
  000e8	03 d8		 add	 ebx, eax
  000ea	03 f8		 add	 edi, eax
  000ec	8d 45 f4	 lea	 eax, DWORD PTR $T44212[ebp]
  000ef	50		 push	 eax
  000f0	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  000f3	8d 46 15	 lea	 eax, DWORD PTR [esi+21]
  000f6	ff 75 08	 push	 DWORD PTR __Cat$44186[ebp]
  000f9	50		 push	 eax
  000fa	ff 75 fc	 push	 DWORD PTR __Newmap$[ebp]
  000fd	53		 push	 ebx
  000fe	57		 push	 edi
  000ff	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Value * *,Json::Value * *>
  00104	83 c4 14	 add	 esp, 20			; 00000014H
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 ??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
  0010d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN64@Growmap@2:

; 1625 : 			}
; 1626 : 
; 1627 : 		_Destroy_range(this->_Map + _Myboff, this->_Map + this->_Mapsize,
; 1628 : 			this->_Almap);
; 1629 : 		if (this->_Map != 0)

  00110	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00113	5f		 pop	 edi
  00114	5b		 pop	 ebx
  00115	85 c0		 test	 eax, eax
  00117	74 07		 je	 SHORT $LN72@Growmap@2

; 1630 : 			this->_Almap.deallocate(this->_Map,
; 1631 : 				this->_Mapsize);	// free storage for old

  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0011f	59		 pop	 ecx
$LN72@Growmap@2:

; 1632 : 
; 1633 : 		this->_Map = _Newmap;	// point at new

  00120	8b 45 fc	 mov	 eax, DWORD PTR __Newmap$[ebp]
  00123	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1634 : 		this->_Mapsize += _Count;

  00126	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00129	01 46 08	 add	 DWORD PTR [esi+8], eax
  0012c	5e		 pop	 esi

; 1635 : 		}

  0012d	c9		 leave
  0012e	c2 04 00	 ret	 4
$LN74@Growmap@2:
?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
_TEXT	ENDS
PUBLIC	??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@V?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::_Deque_val<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@V?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
$T44276 = -16						; size = 12
$T44260 = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@V?$allocator@PAVValue@Json@@@1@@Z PROC ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::_Deque_val<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 728  : 		{	// construct allocators from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	33 ff		 xor	 edi, edi

; 729  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 730  : 			_Alproxy(_Alval);
; 731  : 		this->_Myproxy = _Alproxy.allocate(1);

  0000c	6a 08		 push	 8
  0000e	89 3e		 mov	 DWORD PTR [esi], edi
  00010	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00015	59		 pop	 ecx
  00016	3b c7		 cmp	 eax, edi
  00018	74 23		 je	 SHORT $LN13@Deque_val@2
  0001a	89 06		 mov	 DWORD PTR [esi], eax

; 732  : 		_Cons_val(_Alproxy, this->_Myproxy, _Container_proxy());

  0001c	33 c9		 xor	 ecx, ecx
  0001e	89 08		 mov	 DWORD PTR [eax], ecx
  00020	33 d2		 xor	 edx, edx
  00022	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 733  : 		this->_Myproxy->_Mycont = this;

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	89 30		 mov	 DWORD PTR [eax], esi

; 734  : 
; 735  : 		_Map = 0;

  00029	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 736  : 		_Mapsize = 0;

  0002c	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 737  : 		_Myoff = 0;

  0002f	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 738  : 		_Mysize = 0;

  00032	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00035	5f		 pop	 edi

; 739  : 		}

  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi
  00039	c9		 leave
  0003a	c2 04 00	 ret	 4

; 729  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 730  : 			_Alproxy(_Alval);
; 731  : 		this->_Myproxy = _Alproxy.allocate(1);

$LN13@Deque_val@2:
  0003d	8d 45 fc	 lea	 eax, DWORD PTR $T44260[ebp]
  00040	50		 push	 eax
  00041	8d 4d f0	 lea	 ecx, DWORD PTR $T44276[ebp]
  00044	89 7d fc	 mov	 DWORD PTR $T44260[ebp], edi
  00047	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0004c	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00051	8d 45 f0	 lea	 eax, DWORD PTR $T44276[ebp]
  00054	50		 push	 eax
  00055	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T44276[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0005c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN38@Deque_val@2:
$LN37@Deque_val@2:
  00061	cc		 int	 3
??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@V?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::_Deque_val<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
PUBLIC	??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  00010	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00013	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00016	5f		 pop	 edi
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z
_TEXT	SEGMENT
__Num$ = 8						; size = 4
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
__Roff$ = 16						; size = 4
__Count$ = 20						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 981  : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 982  : 		if (this->_Mysize < _Off || _Right.size() < _Roff)

  00007	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR __Off$[ebp]
  0000e	3b cf		 cmp	 ecx, edi
  00010	0f 82 fb 00 00
	00		 jb	 $LN6@insert
  00016	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00019	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0001c	3b 45 10	 cmp	 eax, DWORD PTR __Roff$[ebp]
  0001f	0f 82 ec 00 00
	00		 jb	 $LN6@insert

; 984  : 		size_type _Num = _Right.size() - _Roff;

  00025	2b 45 10	 sub	 eax, DWORD PTR __Roff$[ebp]

; 985  : 		if (_Num < _Count)

  00028	8b 5d 14	 mov	 ebx, DWORD PTR __Count$[ebp]
  0002b	3b c3		 cmp	 eax, ebx
  0002d	73 05		 jae	 SHORT $LN5@insert

; 986  : 			_Count = _Num;	// trim _Count to size

  0002f	8b d8		 mov	 ebx, eax
  00031	89 5d 14	 mov	 DWORD PTR __Count$[ebp], ebx
$LN5@insert:

; 987  : 		if (npos - this->_Mysize <= _Count)

  00034	83 c8 ff	 or	 eax, -1
  00037	2b c1		 sub	 eax, ecx
  00039	3b c3		 cmp	 eax, ebx
  0003b	77 0a		 ja	 SHORT $LN4@insert

; 988  : 			_Xlen();	// result too long

  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00042	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN61@insert:
$LN4@insert:

; 989  : 
; 990  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

  00047	85 db		 test	 ebx, ebx
  00049	0f 84 b9 00 00
	00		 je	 $LN57@insert
  0004f	03 cb		 add	 ecx, ebx
  00051	6a 00		 push	 0
  00053	89 4d 08	 mov	 DWORD PTR __Num$[ebp], ecx
  00056	51		 push	 ecx
  00057	8b ce		 mov	 ecx, esi
  00059	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  0005e	84 c0		 test	 al, al
  00060	0f 84 a2 00 00
	00		 je	 $LN57@insert

; 991  : 			{	// make room and insert new stuff
; 992  : 			_Traits::move(_Myptr() + _Off + _Count,
; 993  : 				_Myptr() + _Off, this->_Mysize - _Off);	// empty out hole

  00066	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00069	83 f8 10	 cmp	 eax, 16			; 00000010H
  0006c	72 04		 jb	 SHORT $LN23@insert
  0006e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00070	eb 02		 jmp	 SHORT $LN24@insert
$LN23@insert:
  00072	8b ce		 mov	 ecx, esi
$LN24@insert:
  00074	83 f8 10	 cmp	 eax, 16			; 00000010H
  00077	72 04		 jb	 SHORT $LN27@insert
  00079	8b 06		 mov	 eax, DWORD PTR [esi]
  0007b	eb 02		 jmp	 SHORT $LN28@insert
$LN27@insert:
  0007d	8b c6		 mov	 eax, esi
$LN28@insert:
  0007f	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00082	2b d7		 sub	 edx, edi
  00084	52		 push	 edx
  00085	03 cf		 add	 ecx, edi
  00087	03 c7		 add	 eax, edi
  00089	51		 push	 ecx
  0008a	03 c3		 add	 eax, ebx
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _memmove

; 994  : 			if (this == &_Right)

  00092	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH
  00098	3b f1		 cmp	 esi, ecx
  0009a	75 32		 jne	 SHORT $LN2@insert

; 995  : 				_Traits::move(_Myptr() + _Off,
; 996  : 					_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 997  : 						_Count);	// substring

  0009c	8b 55 10	 mov	 edx, DWORD PTR __Roff$[ebp]
  0009f	3b fa		 cmp	 edi, edx
  000a1	73 02		 jae	 SHORT $LN10@insert
  000a3	03 d3		 add	 edx, ebx
$LN10@insert:
  000a5	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000a8	83 f8 10	 cmp	 eax, 16			; 00000010H
  000ab	72 04		 jb	 SHORT $LN33@insert
  000ad	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000af	eb 02		 jmp	 SHORT $LN34@insert
$LN33@insert:
  000b1	8b ce		 mov	 ecx, esi
$LN34@insert:
  000b3	83 f8 10	 cmp	 eax, 16			; 00000010H
  000b6	72 04		 jb	 SHORT $LN37@insert
  000b8	8b 06		 mov	 eax, DWORD PTR [esi]
  000ba	eb 02		 jmp	 SHORT $LN38@insert
$LN37@insert:
  000bc	8b c6		 mov	 eax, esi
$LN38@insert:
  000be	ff 75 14	 push	 DWORD PTR __Count$[ebp]
  000c1	03 ca		 add	 ecx, edx
  000c3	51		 push	 ecx
  000c4	03 c7		 add	 eax, edi
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _memmove

; 998  : 			else

  000cc	eb 21		 jmp	 SHORT $LN60@insert
$LN2@insert:

; 999  : 				_Traits::copy(_Myptr() + _Off,
; 1000 : 					_Right._Myptr() + _Roff, _Count);	// fill hole

  000ce	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  000d2	72 02		 jb	 SHORT $LN43@insert
  000d4	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN43@insert:
  000d6	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000da	72 04		 jb	 SHORT $LN47@insert
  000dc	8b 06		 mov	 eax, DWORD PTR [esi]
  000de	eb 02		 jmp	 SHORT $LN48@insert
$LN47@insert:
  000e0	8b c6		 mov	 eax, esi
$LN48@insert:
  000e2	03 4d 10	 add	 ecx, DWORD PTR __Roff$[ebp]
  000e5	53		 push	 ebx
  000e6	51		 push	 ecx
  000e7	03 c7		 add	 eax, edi
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 _memcpy
$LN60@insert:

; 1001 : 			_Eos(_Num);

  000ef	8b 4d 08	 mov	 ecx, DWORD PTR __Num$[ebp]
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f5	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000f9	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  000fc	72 04		 jb	 SHORT $LN55@insert
  000fe	8b 06		 mov	 eax, DWORD PTR [esi]
  00100	eb 02		 jmp	 SHORT $LN56@insert
$LN55@insert:
  00102	8b c6		 mov	 eax, esi
$LN56@insert:
  00104	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
$LN57@insert:

; 1002 : 			}
; 1003 : 		return (*this);

  00108	5f		 pop	 edi
  00109	8b c6		 mov	 eax, esi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx

; 1004 : 		}

  0010d	5d		 pop	 ebp
  0010e	c2 10 00	 ret	 16			; 00000010H
$LN6@insert:

; 983  : 			_Xran();	// _Off or _Roff off end

  00111	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00116	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN62@insert:
$LN59@insert:
  0011b	cc		 int	 3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
PUBLIC	??_GErrorInfo@Reader@Json@@QAEPAXI@Z		; Json::Reader::ErrorInfo::`scalar deleting destructor'
; Function compile flags: /Ogsp
;	COMDAT ??_GErrorInfo@Reader@Json@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GErrorInfo@Reader@Json@@QAEPAXI@Z PROC		; Json::Reader::ErrorInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	6a 00		 push	 0
  00008	6a 01		 push	 1
  0000a	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0000d	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00012	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00016	74 07		 je	 SHORT $LN1@scalar@8
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001e	59		 pop	 ecx
$LN1@scalar@8:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GErrorInfo@Reader@Json@@QAEPAXI@Z ENDP		; Json::Reader::ErrorInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 543  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 544  : 		_Tidy();

  00004	33 c0		 xor	 eax, eax

; 545  : 		assign(_Right, 0, npos);

  00006	6a ff		 push	 -1
  00008	8b f1		 mov	 esi, ecx
  0000a	50		 push	 eax
  0000b	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000e	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00015	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00018	88 06		 mov	 BYTE PTR [esi], al
  0001a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 546  : 		}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
; Function compile flags: /Ogsp
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx

; 1539 : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1540 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Newcap$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f8		 cmp	 edi, eax
  0000f	77 20		 ja	 SHORT $LN11@reserve
  00011	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  00014	74 1b		 je	 SHORT $LN11@reserve

; 1541 : 			{	// change reservation
; 1542 : 			size_type _Size = this->_Mysize;
; 1543 : 			if (_Grow(_Newcap, true))

  00016	6a 01		 push	 1
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  0001e	84 c0		 test	 al, al
  00020	74 0f		 je	 SHORT $LN11@reserve

; 1544 : 				_Eos(_Size);

  00022	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00026	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00029	72 02		 jb	 SHORT $LN9@reserve
  0002b	8b 36		 mov	 esi, DWORD PTR [esi]
$LN9@reserve:
  0002d	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
$LN11@reserve:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi

; 1545 : 			}
; 1546 : 		}

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 99   : 			{	// construct locking and calling _Ipfx

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	ff 75 08	 push	 DWORD PTR __Istr$[ebp]
  00014	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base

; 100  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  00019	ff 75 0c	 push	 DWORD PTR __Noskip$[ebp]
  0001c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00022	e8 00 00 00 00	 call	 ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
  00027	88 46 04	 mov	 BYTE PTR [esi+4], al

; 101  : 			}

  0002a	8b c6		 mov	 eax, esi
  0002c	e8 00 00 00 00	 call	 __EH_epilog3
  00031	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stack
;	COMDAT ?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop, COMDAT
; _this$ = ecx

; 104  : 		c.pop_back();

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	85 c0		 test	 eax, eax
  00005	74 0a		 je	 SHORT $LN3@pop
  00007	48		 dec	 eax
  00008	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000b	75 04		 jne	 SHORT $LN3@pop
  0000d	83 61 0c 00	 and	 DWORD PTR [ecx+12], 0
$LN3@pop:

; 105  : 		}

  00011	c3		 ret	 0
?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop
_TEXT	ENDS
PUBLIC	??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 1021 : 		{	// destroy the deque

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1022 : 		_Tidy();

  00003	e8 00 00 00 00	 call	 ?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy

; 1023 : 		}

  00008	ff 36		 push	 DWORD PTR [esi]
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 26 00	 and	 DWORD PTR [esi], 0
  00012	59		 pop	 ecx
  00013	5e		 pop	 esi
  00014	c3		 ret	 0
??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
PUBLIC	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T44649 = -4						; size = 4
$T44644 = -4						; size = 4
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 799  : 		{	// construct empty deque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	51		 push	 ecx
  00006	89 65 fc	 mov	 DWORD PTR $T44644[ebp], esp
  00009	8b f1		 mov	 esi, ecx
  0000b	89 65 fc	 mov	 DWORD PTR $T44649[ebp], esp
  0000e	e8 00 00 00 00	 call	 ??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >

; 800  : 		}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c9		 leave
  00017	c3		 ret	 0
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 792  : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 793  : 		return (append(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 794  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogsp
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 838  : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 839  : 		_DEBUG_POINTER(_Ptr);
; 840  : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00004	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 _strlen
  0000e	59		 pop	 ecx
  0000f	50		 push	 eax
  00010	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0001a	5e		 pop	 esi

; 841  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogsp
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 844  : 		{	// append _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 845  : 		if (npos - this->_Mysize <= _Count)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000d	83 c9 ff	 or	 ecx, -1
  00010	2b c8		 sub	 ecx, eax
  00012	3b cb		 cmp	 ecx, ebx
  00014	77 0a		 ja	 SHORT $LN2@append@3

; 846  : 			_Xlen();	// result too long

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0001b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN18@append@3:
$LN2@append@3:

; 847  : 
; 848  : 		size_type _Num;
; 849  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

  00020	85 db		 test	 ebx, ebx
  00022	74 34		 je	 SHORT $LN14@append@3
  00024	57		 push	 edi
  00025	8d 3c 18	 lea	 edi, DWORD PTR [eax+ebx]
  00028	6a 00		 push	 0
  0002a	57		 push	 edi
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00032	84 c0		 test	 al, al
  00034	74 21		 je	 SHORT $LN16@append@3

; 850  : 			{	// make room and append new stuff using assign
; 851  : 			_Chassign(this->_Mysize, _Count, _Ch);

  00036	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  00039	8b ce		 mov	 ecx, esi
  0003b	53		 push	 ebx
  0003c	ff 76 10	 push	 DWORD PTR [esi+16]
  0003f	e8 00 00 00 00	 call	 ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 852  : 			_Eos(_Num);

  00044	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00048	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0004b	72 04		 jb	 SHORT $LN12@append@3
  0004d	8b 06		 mov	 eax, DWORD PTR [esi]
  0004f	eb 02		 jmp	 SHORT $LN13@append@3
$LN12@append@3:
  00051	8b c6		 mov	 eax, esi
$LN13@append@3:
  00053	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN16@append@3:
  00057	5f		 pop	 edi
$LN14@append@3:

; 853  : 			}
; 854  : 		return (*this);

  00058	8b c6		 mov	 eax, esi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx

; 855  : 		}

  0005c	5d		 pop	 ebp
  0005d	c2 08 00	 ret	 8
$LN17@append@3:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogsp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 886  : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 887  : 		return (assign(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 888  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogsp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 910  : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 911  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 912  : 		if (_Count != 0)
; 913  : 			_DEBUG_POINTER(_Ptr);
; 914  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 915  : 
; 916  : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	53		 push	 ebx
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
  00010	84 c0		 test	 al, al
  00012	74 1c		 je	 SHORT $LN2@assign@2

; 917  : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

  00014	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00018	72 04		 jb	 SHORT $LN7@assign@2
  0001a	8b 06		 mov	 eax, DWORD PTR [esi]
  0001c	eb 02		 jmp	 SHORT $LN8@assign@2
$LN7@assign@2:
  0001e	8b c6		 mov	 eax, esi
$LN8@assign@2:
  00020	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00023	2b d8		 sub	 ebx, eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0002e	eb 3f		 jmp	 SHORT $LN3@assign@2
$LN2@assign@2:
  00030	57		 push	 edi

; 918  : 
; 919  : 		if (_Grow(_Count))

  00031	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00034	6a 00		 push	 0
  00036	57		 push	 edi
  00037	8b ce		 mov	 ecx, esi
  00039	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  0003e	84 c0		 test	 al, al
  00040	74 2a		 je	 SHORT $LN21@assign@2

; 920  : 			{	// make room and assign new stuff
; 921  : 			_Traits::copy(_Myptr(), _Ptr, _Count);

  00042	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00046	72 04		 jb	 SHORT $LN11@assign@2
  00048	8b 06		 mov	 eax, DWORD PTR [esi]
  0004a	eb 02		 jmp	 SHORT $LN12@assign@2
$LN11@assign@2:
  0004c	8b c6		 mov	 eax, esi
$LN12@assign@2:
  0004e	57		 push	 edi
  0004f	53		 push	 ebx
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _memcpy
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 922  : 			_Eos(_Count);

  00059	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0005d	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00060	72 04		 jb	 SHORT $LN19@assign@2
  00062	8b 06		 mov	 eax, DWORD PTR [esi]
  00064	eb 02		 jmp	 SHORT $LN20@assign@2
$LN19@assign@2:
  00066	8b c6		 mov	 eax, esi
$LN20@assign@2:
  00068	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN21@assign@2:

; 923  : 			}
; 924  : 		return (*this);

  0006c	8b c6		 mov	 eax, esi
  0006e	5f		 pop	 edi
$LN3@assign@2:
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx

; 925  : 		}

  00071	5d		 pop	 ebp
  00072	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogsp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 928  : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 929  : 		_DEBUG_POINTER(_Ptr);
; 930  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00004	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 _strlen
  0000e	59		 pop	 ecx
  0000f	50		 push	 eax
  00010	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0001a	5e		 pop	 esi

; 931  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; Function compile flags: /Ogsp
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Ch$ = 12						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1526 : 		{	// determine new length, padding with _Ch elements as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1527 : 		if (_Newsize <= this->_Mysize)

  00003	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00009	3b c2		 cmp	 eax, edx
  0000b	77 0a		 ja	 SHORT $LN2@resize

; 1528 : 			erase(_Newsize);

  0000d	6a ff		 push	 -1
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1529 : 		else

  00015	eb 0b		 jmp	 SHORT $LN1@resize
$LN2@resize:

; 1530 : 			append(_Newsize - this->_Mysize, _Ch);

  00017	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  0001a	2b c2		 sub	 eax, edx
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN1@resize:

; 1531 : 		}

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
PUBLIC	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T44746 = -4						; size = 4
$T44741 = -4						; size = 4
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 799  : 		{	// construct empty deque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	51		 push	 ecx
  00006	89 65 fc	 mov	 DWORD PTR $T44741[ebp], esp
  00009	8b f1		 mov	 esi, ecx
  0000b	89 65 fc	 mov	 DWORD PTR $T44746[ebp], esp
  0000e	e8 00 00 00 00	 call	 ??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@V?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::_Deque_val<Json::Value *,std::allocator<Json::Value *> >

; 800  : 		}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c9		 leave
  00017	c3		 ret	 0
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
PUBLIC	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
; Function compile flags: /Ogsp
;	COMDAT ?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z
_TEXT	SEGMENT
$T44775 = -16						; size = 12
$T44758 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back, COMDAT
; _this$ = ecx

; 955  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 956  : 		this->_Orphan_all();
; 957  : 		_PUSH_BACK_BEGIN;

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0000f	03 c8		 add	 ecx, eax
  00011	57		 push	 edi
  00012	f6 c1 03	 test	 cl, 3
  00015	75 14		 jne	 SHORT $LN3@push_back
  00017	83 c0 04	 add	 eax, 4
  0001a	c1 e8 02	 shr	 eax, 2
  0001d	39 46 08	 cmp	 DWORD PTR [esi+8], eax
  00020	77 09		 ja	 SHORT $LN3@push_back
  00022	6a 01		 push	 1
  00024	8b ce		 mov	 ecx, esi
  00026	e8 00 00 00 00	 call	 ?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
$LN3@push_back:
  0002b	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  0002e	03 7e 10	 add	 edi, DWORD PTR [esi+16]
  00031	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00034	8b c7		 mov	 eax, edi
  00036	c1 e8 02	 shr	 eax, 2
  00039	3b c8		 cmp	 ecx, eax
  0003b	77 02		 ja	 SHORT $LN2@push_back
  0003d	2b c1		 sub	 eax, ecx
$LN2@push_back:
  0003f	53		 push	 ebx
  00040	8b d8		 mov	 ebx, eax
  00042	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00045	83 3c 98 00	 cmp	 DWORD PTR [eax+ebx*4], 0
  00049	75 12		 jne	 SHORT $LN1@push_back
  0004b	6a 10		 push	 16			; 00000010H
  0004d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00052	59		 pop	 ecx
  00053	85 c0		 test	 eax, eax
  00055	74 27		 je	 SHORT $LN10@push_back
  00057	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005a	89 04 99	 mov	 DWORD PTR [ecx+ebx*4], eax
$LN1@push_back:

; 958  : 		_Cons_val(this->_Alval,
; 959  : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 960  : 			_STD forward<_Ty>(_Val));

  0005d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00060	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]
  00063	83 e7 03	 and	 edi, 3
  00066	8d 3c b8	 lea	 edi, DWORD PTR [eax+edi*4]
  00069	5b		 pop	 ebx
  0006a	85 ff		 test	 edi, edi
  0006c	74 07		 je	 SHORT $LN28@push_back
  0006e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00071	8b 00		 mov	 eax, DWORD PTR [eax]
  00073	89 07		 mov	 DWORD PTR [edi], eax
$LN28@push_back:

; 961  : 		_PUSH_BACK_END;

  00075	ff 46 10	 inc	 DWORD PTR [esi+16]
  00078	5f		 pop	 edi
  00079	5e		 pop	 esi

; 962  : 		}

  0007a	c9		 leave
  0007b	c2 04 00	 ret	 4

; 956  : 		this->_Orphan_all();
; 957  : 		_PUSH_BACK_BEGIN;

$LN10@push_back:
  0007e	83 65 fc 00	 and	 DWORD PTR $T44758[ebp], 0
  00082	8d 45 fc	 lea	 eax, DWORD PTR $T44758[ebp]
  00085	50		 push	 eax
  00086	8d 4d f0	 lea	 ecx, DWORD PTR $T44775[ebp]
  00089	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0008e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00093	8d 45 f0	 lea	 eax, DWORD PTR $T44775[ebp]
  00096	50		 push	 eax
  00097	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T44775[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0009e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN35@push_back:
$LN34@push_back:
  000a3	cc		 int	 3
?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
_TEXT	ENDS
PUBLIC	??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::operator-
; Function compile flags: /Ogsp
;	COMDAT ??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::operator-, COMDAT
; _this$ = ecx

; 671  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi

; 672  : 		_Myiter _Tmp = *this;

  0000a	56		 push	 esi
  0000b	8d 4d f4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12

; 673  : 		return (_Tmp -= _Off);

  00013	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00016	2b 75 0c	 sub	 esi, DWORD PTR __Off$[ebp]
  00019	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __Tmp$[ebp]
  0001f	50		 push	 eax
  00020	8b cf		 mov	 ecx, edi
  00022	89 75 fc	 mov	 DWORD PTR __Tmp$[ebp+8], esi
  00025	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0002a	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0002d	8b c7		 mov	 eax, edi
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi

; 674  : 		}

  00031	c9		 leave
  00032	c2 08 00	 ret	 8
??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::operator-
_TEXT	ENDS
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1008 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1009 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1010 : 		if (_Count != 0)
; 1011 : 			_DEBUG_POINTER(_Ptr);
; 1012 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1013 : 
; 1014 : 		if (_Inside(_Ptr))

  00005	8b 7d 0c	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
  00010	84 c0		 test	 al, al
  00012	74 22		 je	 SHORT $LN4@insert@2

; 1015 : 			return (insert(_Off, *this,
; 1016 : 				_Ptr - _Myptr(), _Count));	// substring

  00014	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00018	72 04		 jb	 SHORT $LN9@insert@2
  0001a	8b 06		 mov	 eax, DWORD PTR [esi]
  0001c	eb 02		 jmp	 SHORT $LN10@insert@2
$LN9@insert@2:
  0001e	8b c6		 mov	 eax, esi
$LN10@insert@2:
  00020	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00023	2b f8		 sub	 edi, eax
  00025	57		 push	 edi
  00026	56		 push	 esi
  00027	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  0002a	8b ce		 mov	 ecx, esi
  0002c	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00031	e9 a3 00 00 00	 jmp	 $LN5@insert@2
$LN4@insert@2:

; 1017 : 		if (this->_Mysize < _Off)

  00036	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00039	8b 7d 08	 mov	 edi, DWORD PTR __Off$[ebp]
  0003c	3b c7		 cmp	 eax, edi
  0003e	73 0a		 jae	 SHORT $LN3@insert@2

; 1018 : 			_Xran();	// _Off off end

  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00045	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN42@insert@2:
$LN3@insert@2:

; 1019 : 		if (npos - this->_Mysize <= _Count)

  0004a	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0004d	83 ca ff	 or	 edx, -1
  00050	2b d0		 sub	 edx, eax
  00052	3b d1		 cmp	 edx, ecx
  00054	77 0a		 ja	 SHORT $LN2@insert@2

; 1020 : 			_Xlen();	// result too long

  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0005b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN43@insert@2:
$LN2@insert@2:

; 1021 : 		size_type _Num;
; 1022 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

  00060	85 c9		 test	 ecx, ecx
  00062	74 73		 je	 SHORT $LN38@insert@2
  00064	53		 push	 ebx
  00065	8d 1c 08	 lea	 ebx, DWORD PTR [eax+ecx]
  00068	6a 00		 push	 0
  0006a	53		 push	 ebx
  0006b	8b ce		 mov	 ecx, esi
  0006d	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00072	84 c0		 test	 al, al
  00074	74 60		 je	 SHORT $LN40@insert@2

; 1023 : 			{	// make room and insert new stuff
; 1024 : 			_Traits::move(_Myptr() + _Off + _Count,
; 1025 : 				_Myptr() + _Off, this->_Mysize - _Off);	// empty out hole

  00076	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00079	83 f8 10	 cmp	 eax, 16			; 00000010H
  0007c	72 04		 jb	 SHORT $LN18@insert@2
  0007e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00080	eb 02		 jmp	 SHORT $LN19@insert@2
$LN18@insert@2:
  00082	8b ce		 mov	 ecx, esi
$LN19@insert@2:
  00084	83 f8 10	 cmp	 eax, 16			; 00000010H
  00087	72 04		 jb	 SHORT $LN22@insert@2
  00089	8b 06		 mov	 eax, DWORD PTR [esi]
  0008b	eb 02		 jmp	 SHORT $LN23@insert@2
$LN22@insert@2:
  0008d	8b c6		 mov	 eax, esi
$LN23@insert@2:
  0008f	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00092	2b d7		 sub	 edx, edi
  00094	52		 push	 edx
  00095	03 c7		 add	 eax, edi
  00097	03 45 10	 add	 eax, DWORD PTR __Count$[ebp]
  0009a	03 cf		 add	 ecx, edi
  0009c	51		 push	 ecx
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _memmove
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1026 : 			_Traits::copy(_Myptr() + _Off, _Ptr, _Count);	// fill hole

  000a6	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000aa	72 04		 jb	 SHORT $LN28@insert@2
  000ac	8b 06		 mov	 eax, DWORD PTR [esi]
  000ae	eb 02		 jmp	 SHORT $LN29@insert@2
$LN28@insert@2:
  000b0	8b c6		 mov	 eax, esi
$LN29@insert@2:
  000b2	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  000b5	03 c7		 add	 eax, edi
  000b7	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _memcpy
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1027 : 			_Eos(_Num);

  000c3	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000c7	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000ca	72 04		 jb	 SHORT $LN36@insert@2
  000cc	8b 06		 mov	 eax, DWORD PTR [esi]
  000ce	eb 02		 jmp	 SHORT $LN37@insert@2
$LN36@insert@2:
  000d0	8b c6		 mov	 eax, esi
$LN37@insert@2:
  000d2	c6 04 18 00	 mov	 BYTE PTR [eax+ebx], 0
$LN40@insert@2:
  000d6	5b		 pop	 ebx
$LN38@insert@2:

; 1028 : 			}
; 1029 : 		return (*this);

  000d7	8b c6		 mov	 eax, esi
$LN5@insert@2:
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi

; 1030 : 		}

  000db	5d		 pop	 ebp
  000dc	c2 0c 00	 ret	 12			; 0000000cH
$LN41@insert@2:
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
PUBLIC	??$_Destroy@VErrorInfo@Reader@Json@@@std@@YAXPAVErrorInfo@Reader@Json@@@Z ; std::_Destroy<Json::Reader::ErrorInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@VErrorInfo@Reader@Json@@@std@@YAXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VErrorInfo@Reader@Json@@@std@@YAXPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Destroy<Json::Reader::ErrorInfo>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	_Ptr->~_Ty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	6a 00		 push	 0
  00008	e8 00 00 00 00	 call	 ??_GErrorInfo@Reader@Json@@QAEPAXI@Z

; 64   : 	}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy@VErrorInfo@Reader@Json@@@std@@YAXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Destroy<Json::Reader::ErrorInfo>
_TEXT	ENDS
PUBLIC	??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z		; Json::Reader::ErrorInfo::ErrorInfo
; Function compile flags: /Ogsp
;	COMDAT ??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z PROC		; Json::Reader::ErrorInfo::ErrorInfo, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b d9		 mov	 ebx, ecx
  0000b	8b f0		 mov	 esi, eax
  0000d	8b fb		 mov	 edi, ebx
  0000f	a5		 movsd
  00010	a5		 movsd
  00011	83 c0 0c	 add	 eax, 12			; 0000000cH
  00014	50		 push	 eax
  00015	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  00018	a5		 movsd
  00019	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00021	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00024	5f		 pop	 edi
  00025	89 43 28	 mov	 DWORD PTR [ebx+40], eax
  00028	5e		 pop	 esi
  00029	8b c3		 mov	 eax, ebx
  0002b	5b		 pop	 ebx
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z ENDP		; Json::Reader::ErrorInfo::ErrorInfo
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@$$QAV345@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@$$QAV345@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@$$QAV345@@Z$0
__ehfuncinfo$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@$$QAV345@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@$$QAV345@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@$$QAV345@@Z
_TEXT	SEGMENT
$T44949 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@$$QAV345@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@$$QAV345@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR $T44949[ebp], ecx
  00012	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00016	85 c9		 test	 ecx, ecx
  00018	74 08		 je	 SHORT $LN3@construct@3
  0001a	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0001d	e8 00 00 00 00	 call	 ??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
$LN3@construct@3:

; 203  : 		}

  00022	e8 00 00 00 00	 call	 __EH_epilog3
  00027	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@$$QAV345@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T44949[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@$$QAV345@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@$$QAV345@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@$$QAV345@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::construct
PUBLIC	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
; Function compile flags: /Ogsp
;	COMDAT ??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
  00008	ff 36		 push	 DWORD PTR [esi]
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 26 00	 and	 DWORD PTR [esi], 0
  00012	59		 pop	 ecx
  00013	5e		 pop	 esi
  00014	c3		 ret	 0
??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 592  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 593  : 		_Tidy();
; 594  : 		assign(_Ptr);

  00004	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	83 66 10 00	 and	 DWORD PTR [esi+16], 0
  0000d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00014	c6 06 00	 mov	 BYTE PTR [esi], 0
  00017	e8 00 00 00 00	 call	 _strlen
  0001c	59		 pop	 ecx
  0001d	50		 push	 eax
  0001e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 595  : 		}

  00028	8b c6		 mov	 eax, esi
  0002a	5e		 pop	 esi
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 674  : 		{	// construct from [_First, _Last), const pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 675  : 		_DEBUG_RANGE(_First, _Last);
; 676  : 		_Tidy();
; 677  : 		if (_First != _Last)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	83 66 10 00	 and	 DWORD PTR [esi+16], 0
  0000d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00014	c6 06 00	 mov	 BYTE PTR [esi], 0
  00017	39 45 08	 cmp	 DWORD PTR __First$[ebp], eax
  0001a	74 0c		 je	 SHORT $LN1@basic_stri

; 678  : 			assign(&*_First, _Last - _First);

  0001c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00023	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN1@basic_stri:

; 679  : 		}

  00028	8b c6		 mov	 eax, esi
  0002a	5e		 pop	 esi
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 762  : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 763  : 		return (assign(_Right));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 764  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 767  : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 768  : 		return (assign(_Ptr));

  00004	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 _strlen
  0000e	59		 pop	 ecx
  0000f	50		 push	 eax
  00010	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0001a	5e		 pop	 esi

; 769  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogsp
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 777  : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 778  : 		return (append(_Right));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 779  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogsp
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 782  : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 783  : 		return (append(_Ptr));

  00004	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 _strlen
  0000e	59		 pop	 ecx
  0000f	50		 push	 eax
  00010	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0001a	5e		 pop	 esi

; 784  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogsp
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 787  : 		{	// append 1 * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 788  : 		return (append((size_type)1, _Ch));

  00003	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00006	6a 01		 push	 1
  00008	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 789  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; Function compile flags: /Ogsp
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1521 : 		{	// determine new length, padding with null elements as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1522 : 		resize(_Newsize, _Elem());

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  00008	e8 00 00 00 00	 call	 ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 1523 : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
PUBLIC	??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stack
;	COMDAT ??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T45228 = -4						; size = 4
$T45230 = -4						; size = 4
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx

; 26   : 		{	// construct with empty container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	51		 push	 ecx
  00006	89 65 fc	 mov	 DWORD PTR $T45230[ebp], esp
  00009	8b f1		 mov	 esi, ecx
  0000b	89 65 fc	 mov	 DWORD PTR $T45228[ebp], esp
  0000e	e8 00 00 00 00	 call	 ??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@V?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::_Deque_val<Json::Value *,std::allocator<Json::Value *> >

; 27   : 		}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c9		 leave
  00017	c3		 ret	 0
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
PUBLIC	?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push
; Function compile flags: /Ogsp
;	COMDAT ?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push, COMDAT
; _this$ = ecx

; 62   : 		{	// insert element at beginning

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 64   : 		}

  00003	5d		 pop	 ebp

; 63   : 		c.push_back(_STD move(_Val));

  00004	e9 00 00 00 00	 jmp	 ?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 713  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 714  : 		if (this == &_Right)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	3b fe		 cmp	 edi, esi
  0000c	74 41		 je	 SHORT $LN43@assign@3

; 715  : 			;
; 716  : 		else if (get_allocator() != _Right.get_allocator()
; 717  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 718  : 			*this = _Right;
; 719  : 		else
; 720  : 			{	// not same, clear this and steal from _Right
; 721  : 			_Tidy(true);

  0000e	6a 00		 push	 0
  00010	6a 01		 push	 1
  00012	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 722  : 			if (_Right._Myres < this->_BUF_SIZE)

  00017	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0001b	73 11		 jae	 SHORT $LN2@assign@3

; 723  : 				_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 724  : 					_Right._Mysize + 1);

  0001d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00020	40		 inc	 eax
  00021	50		 push	 eax
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	e8 00 00 00 00	 call	 _memmove
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH

; 725  : 			else

  0002c	eb 07		 jmp	 SHORT $LN1@assign@3
$LN2@assign@3:

; 726  : 				{	// copy pointer
; 727  : 				this->_Bx._Ptr = _Right._Bx._Ptr;

  0002e	8b 06		 mov	 eax, DWORD PTR [esi]
  00030	89 07		 mov	 DWORD PTR [edi], eax

; 728  : 				_Right._Bx._Ptr = 0;

  00032	83 26 00	 and	 DWORD PTR [esi], 0
$LN1@assign@3:

; 729  : 				}
; 730  : 			this->_Mysize = _Right._Mysize;

  00035	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00038	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 731  : 			this->_Myres = _Right._Myres;

  0003b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0003e	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 732  : 
; 733  : 			_Right._Tidy();

  00041	83 66 10 00	 and	 DWORD PTR [esi+16], 0
  00045	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0004c	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN43@assign@3:

; 734  : 			}
; 735  : 		return (*this);

  0004f	8b c7		 mov	 eax, edi
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 736  : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
$T45333 = -24						; size = 12
$T45334 = -12						; size = 12
?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back, COMDAT
; _this$ = ecx

; 1213 : 		{	// return last element of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 1214 : 		return (*(end() - 1));

  00006	6a 01		 push	 1
  00008	8d 45 f4	 lea	 eax, DWORD PTR $T45334[ebp]
  0000b	50		 push	 eax
  0000c	8d 45 e8	 lea	 eax, DWORD PTR $T45333[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *> >::operator-
  0001c	8b c8		 mov	 ecx, eax
  0001e	e8 00 00 00 00	 call	 ??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *> >::operator*

; 1215 : 		}

  00023	c9		 leave
  00024	c3		 ret	 0
?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
_TEXT	ENDS
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1033 : 		{	// insert [_Ptr, <null>) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1034 : 		_DEBUG_POINTER(_Ptr);
; 1035 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

  00004	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 _strlen
  0000e	59		 pop	 ecx
  0000f	50		 push	 eax
  00010	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00013	8b ce		 mov	 ecx, esi
  00015	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00018	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  0001d	5e		 pop	 esi

; 1036 : 		}

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo>::destroy
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 213  : 		_Destroy(_Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	6a 00		 push	 0
  00008	e8 00 00 00 00	 call	 ??_GErrorInfo@Reader@Json@@QAEPAXI@Z

; 214  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?destroy@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::destroy
_TEXT	ENDS
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\istream
xdata$x	SEGMENT
__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$14 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0
__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$14
__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\string
xdata$x	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
__Ok$ = -32						; size = 8
__State$ = -24						; size = 4
__Changed$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 399  : 	{	// get characters into string, discard delimiter

  00000	6a 14		 push	 20			; 00000014H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch

; 400  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 401  : 
; 402  : 	ios_base::iostate _State = ios_base::goodbit;
; 403  : 	bool _Changed = false;
; 404  : 	const typename _Myis::sentry _Ok(_Istr, true);

  0000c	8b 75 08	 mov	 esi, DWORD PTR __Istr$[ebp]
  0000f	33 ff		 xor	 edi, edi
  00011	56		 push	 esi
  00012	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00015	89 7d e8	 mov	 DWORD PTR __State$[ebp], edi
  00018	c6 45 ef 00	 mov	 BYTE PTR __Changed$[ebp], 0
  0001c	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00021	8b 4d e0	 mov	 ecx, DWORD PTR __Ok$[ebp]
  00024	33 db		 xor	 ebx, ebx
  00026	43		 inc	 ebx
  00027	53		 push	 ebx
  00028	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi
  0002b	e8 00 00 00 00	 call	 ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
  00030	88 45 e4	 mov	 BYTE PTR __Ok$[ebp+4], al
  00033	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx

; 405  : 
; 406  : 	if (_Ok)

  00036	84 c0		 test	 al, al
  00038	74 58		 je	 SHORT $LN125@getline

; 407  : 		{	// state okay, extract characters
; 408  : 		_TRY_IO_BEGIN
; 409  : 		_Str.erase();

  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0003d	6a ff		 push	 -1
  0003f	57		 push	 edi
  00040	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00044	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 410  : 		const typename _Traits::int_type _Metadelim =
; 411  : 			_Traits::to_int_type(_Delim);
; 412  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004e	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00052	0f b6 7d 10	 movzx	 edi, BYTE PTR __Delim$[ebp]
  00056	e8 00 00 00 00	 call	 ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
$LL10@getline:

; 413  : 
; 414  : 		for (; ; _Meta = _Istr.rdbuf()->snextc())
; 415  : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  0005b	83 f8 ff	 cmp	 eax, -1
  0005e	75 05		 jne	 SHORT $LN7@getline

; 416  : 				{	// end of file, quit
; 417  : 				_State |= ios_base::eofbit;

  00060	09 5d e8	 or	 DWORD PTR __State$[ebp], ebx

; 418  : 				break;

  00063	eb 24		 jmp	 SHORT $LN8@getline
$LN7@getline:

; 419  : 				}
; 420  : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  00065	3b c7		 cmp	 eax, edi
  00067	75 13		 jne	 SHORT $LN5@getline

; 421  : 				{	// got a delimiter, discard it and quit
; 422  : 				_Changed = true;
; 423  : 				_Istr.rdbuf()->sbumpc();

  00069	8b 06		 mov	 eax, DWORD PTR [esi]
  0006b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006e	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00072	88 5d ef	 mov	 BYTE PTR __Changed$[ebp], bl
  00075	e8 00 00 00 00	 call	 ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc

; 424  : 				break;

  0007a	eb 0d		 jmp	 SHORT $LN8@getline
$LN5@getline:

; 425  : 				}
; 426  : 			else if (_Str.max_size() <= _Str.size())

  0007c	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0007f	83 79 10 fe	 cmp	 DWORD PTR [ecx+16], -2	; fffffffeH
  00083	72 36		 jb	 SHORT $LN3@getline

; 427  : 				{	// string too large, quit
; 428  : 				_State |= ios_base::failbit;

  00085	83 4d e8 02	 or	 DWORD PTR __State$[ebp], 2
$LN8@getline:
  00089	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
$LN18@getline:

; 437  : 		}
; 438  : 
; 439  : 	if (!_Changed)

  0008c	80 7d ef 00	 cmp	 BYTE PTR __Changed$[ebp], 0
  00090	75 04		 jne	 SHORT $LN1@getline
$LN125@getline:

; 440  : 		_State |= ios_base::failbit;

  00092	83 4d e8 02	 or	 DWORD PTR __State$[ebp], 2
$LN1@getline:

; 441  : 	_Istr.setstate(_State);

  00096	8b 06		 mov	 eax, DWORD PTR [esi]
  00098	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009b	6a 00		 push	 0
  0009d	ff 75 e8	 push	 DWORD PTR __State$[ebp]
  000a0	03 ce		 add	 ecx, esi
  000a2	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 442  : 	return (_Istr);

  000a7	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  000ab	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000ae	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  000b3	8b c6		 mov	 eax, esi

; 443  : 	}

  000b5	e8 00 00 00 00	 call	 __EH_epilog3
  000ba	c3		 ret	 0
$LN3@getline:

; 429  : 				break;
; 430  : 				}
; 431  : 			else
; 432  : 				{	// got a character, add it to string
; 433  : 				_Str += _Traits::to_char_type(_Meta);

  000bb	50		 push	 eax
  000bc	53		 push	 ebx
  000bd	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  000c2	8b 06		 mov	 eax, DWORD PTR [esi]
  000c4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c7	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]

; 434  : 				_Changed = true;

  000cb	88 5d ef	 mov	 BYTE PTR __Changed$[ebp], bl
  000ce	e8 00 00 00 00	 call	 ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
  000d3	eb 86		 jmp	 SHORT $LL10@getline
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:

; 435  : 				}
; 436  : 		_CATCH_IO_(_Istr)

  000d5	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000d8	8b 01		 mov	 eax, DWORD PTR [ecx]
  000da	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dd	03 c1		 add	 eax, ecx
  000df	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000e2	33 d2		 xor	 edx, edx
  000e4	83 c9 04	 or	 ecx, 4
  000e7	39 50 38	 cmp	 DWORD PTR [eax+56], edx
  000ea	75 03		 jne	 SHORT $LN60@getline
  000ec	83 c9 04	 or	 ecx, 4
$LN60@getline:
  000ef	83 e1 17	 and	 ecx, 23			; 00000017H
  000f2	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  000f5	85 48 10	 test	 DWORD PTR [eax+16], ecx
  000f8	75 12		 jne	 SHORT $LN69@getline
  000fa	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00101	b8 00 00 00 00	 mov	 eax, $LN19@getline
  00106	c3		 ret	 0
$LN19@getline:
  00107	8b 75 08	 mov	 esi, DWORD PTR __Istr$[ebp]
  0010a	eb 80		 jmp	 SHORT $LN18@getline
$LN69@getline:
  0010c	52		 push	 edx
  0010d	52		 push	 edx
  0010e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN131@getline:
$LN130@getline:
  00113	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2:
  00008	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Construct@VErrorInfo@Reader@Json@@ABV123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Construct@VErrorInfo@Reader@Json@@ABV123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@VErrorInfo@Reader@Json@@ABV123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z$0
__ehfuncinfo$??$_Construct@VErrorInfo@Reader@Json@@ABV123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@VErrorInfo@Reader@Json@@ABV123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@VErrorInfo@Reader@Json@@ABV123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z
_TEXT	SEGMENT
$T45773 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VErrorInfo@Reader@Json@@ABV123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z PROC ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Construct@VErrorInfo@Reader@Json@@ABV123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 47   : 	void _FARQ *_Vptr = _Ptr;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000f	89 4d 08	 mov	 DWORD PTR __Vptr$[ebp], ecx

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00012	89 4d f0	 mov	 DWORD PTR $T45773[ebp], ecx
  00015	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00019	85 c9		 test	 ecx, ecx
  0001b	74 08		 je	 SHORT $LN3@Construct
  0001d	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00020	e8 00 00 00 00	 call	 ??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
$LN3@Construct:

; 49   : 	}

  00025	e8 00 00 00 00	 call	 __EH_epilog3
  0002a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@VErrorInfo@Reader@Json@@ABV123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z$0:
  00000	ff 75 08	 push	 DWORD PTR __Vptr$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T45773[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$??$_Construct@VErrorInfo@Reader@Json@@ABV123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@VErrorInfo@Reader@Json@@ABV123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@VErrorInfo@Reader@Json@@ABV123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ENDP ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
PUBLIC	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z	; Json::Reader::ErrorInfo::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z PROC	; Json::Reader::ErrorInfo::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b d9		 mov	 ebx, ecx
  0000b	8b f0		 mov	 esi, eax
  0000d	8b fb		 mov	 edi, ebx
  0000f	a5		 movsd
  00010	6a ff		 push	 -1
  00012	a5		 movsd
  00013	6a 00		 push	 0
  00015	83 c0 0c	 add	 eax, 12			; 0000000cH
  00018	50		 push	 eax
  00019	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  0001c	a5		 movsd
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00022	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00025	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00028	5f		 pop	 edi
  00029	89 43 28	 mov	 DWORD PTR [ebx+40], eax
  0002c	5e		 pop	 esi
  0002d	8b c3		 mov	 eax, ebx
  0002f	5b		 pop	 ebx
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z ENDP	; Json::Reader::ErrorInfo::operator=
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@V345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@$$QAV234@@Z ; std::_Cons_val<std::allocator<Json::Reader::ErrorInfo>,Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@V345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@$$QAV234@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@V345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@$$QAV234@@Z$0
__ehfuncinfo$??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@V345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@$$QAV234@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@V345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@$$QAV234@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@V345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@$$QAV234@@Z
_TEXT	SEGMENT
$T45819 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@V345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@$$QAV234@@Z PROC ; std::_Cons_val<std::allocator<Json::Reader::ErrorInfo>,Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>, COMDAT

; 279  : 	{	// construct using allocator

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@V345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@$$QAV234@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR $T45819[ebp], ecx
  00012	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00016	85 c9		 test	 ecx, ecx
  00018	74 08		 je	 SHORT $LN7@Cons_val@3
  0001a	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  0001d	e8 00 00 00 00	 call	 ??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
$LN7@Cons_val@3:

; 281  : 	}

  00022	e8 00 00 00 00	 call	 __EH_epilog3
  00027	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@V345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@$$QAV234@@Z$0:
  00000	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  00003	ff 75 f0	 push	 DWORD PTR $T45819[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000b	59		 pop	 ecx
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__ehhandler$??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@V345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@$$QAV234@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@V345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@$$QAV234@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@V345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@$$QAV234@@Z ENDP ; std::_Cons_val<std::allocator<Json::Reader::ErrorInfo>,Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	_end$GSCopy$
PUBLIC	_begin$GSCopy$
PUBLIC	?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ; Json::Reader::addComment
EXTRN	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z:PROC ; Json::Value::setComment
EXTRN	__EH_epilog3_GS:PROC
EXTRN	__EH_prolog3_GS:PROC
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$1
__ehfuncinfo$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
_TEXT	SEGMENT
_end$GSCopy$ = -80					; size = 4
_begin$GSCopy$ = -76					; size = 4
$T34693 = -72						; size = 28
$T34697 = -44						; size = 28
__$EHRec$ = -12						; size = 12
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
_placement$ = 16					; size = 4
?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z PROC ; Json::Reader::addComment, COMDAT
; _this$ = ecx

; 409  : {

  00000	6a 44		 push	 68			; 00000044H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 45 08	 mov	 eax, DWORD PTR _begin$[ebp]

; 410  :    assert( collectComments_ );
; 411  :    if ( placement == commentAfterOnSameLine )

  0000f	33 ff		 xor	 edi, edi
  00011	8b f1		 mov	 esi, ecx
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _end$[ebp]
  00016	47		 inc	 edi

; 419  :          commentsBefore_ += "\n";

  00017	89 45 b4	 mov	 DWORD PTR _begin$GSCopy$[ebp], eax
  0001a	89 4d b0	 mov	 DWORD PTR _end$GSCopy$[ebp], ecx
  0001d	39 7d 10	 cmp	 DWORD PTR _placement$[ebp], edi
  00020	75 1d		 jne	 SHORT $LN3@addComment

; 412  :    {
; 413  :       assert( lastValue_ != 0 );
; 414  :       lastValue_->setComment( std::string( begin, end ), placement );

  00022	51		 push	 ecx
  00023	50		 push	 eax
  00024	8d 4d b8	 lea	 ecx, DWORD PTR $T34693[ebp]
  00027	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002c	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  0002f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	57		 push	 edi
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment
  0003a	8d 4d b8	 lea	 ecx, DWORD PTR $T34693[ebp]

; 415  :    }
; 416  :    else

  0003d	eb 3d		 jmp	 SHORT $LN29@addComment
$LN3@addComment:

; 417  :    {
; 418  :       if ( !commentsBefore_.empty() )

  0003f	83 7e 70 00	 cmp	 DWORD PTR [esi+112], 0
  00043	74 16		 je	 SHORT $LN14@addComment

; 419  :          commentsBefore_ += "\n";

  00045	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  0004a	53		 push	 ebx
  0004b	e8 00 00 00 00	 call	 _strlen
  00050	59		 pop	 ecx
  00051	50		 push	 eax
  00052	53		 push	 ebx
  00053	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  00056	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN14@addComment:

; 420  :       commentsBefore_ += std::string( begin, end );

  0005b	ff 75 b0	 push	 DWORD PTR _end$GSCopy$[ebp]
  0005e	8d 4d d4	 lea	 ecx, DWORD PTR $T34697[ebp]
  00061	ff 75 b4	 push	 DWORD PTR _begin$GSCopy$[ebp]
  00064	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00069	6a ff		 push	 -1
  0006b	6a 00		 push	 0
  0006d	50		 push	 eax
  0006e	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  00071	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00074	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00079	8d 4d d4	 lea	 ecx, DWORD PTR $T34697[ebp]
$LN29@addComment:
  0007c	6a 00		 push	 0
  0007e	57		 push	 edi
  0007f	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 421  :    }
; 422  : }

  00084	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00089	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$0:
  00000	8d 4d b8	 lea	 ecx, DWORD PTR $T34693[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$1:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR $T34697[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ENDP ; Json::Reader::addComment
PUBLIC	??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
EXTRN	_sprintf:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@ DB 'Line %d, Column '
	DB	'%d', 00H					; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
_TEXT	SEGMENT
_column$ = -64						; size = 4
$T45897 = -60						; size = 4
_line$ = -60						; size = 4
_buffer$ = -56						; size = 51
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_location$ = 12						; size = 4
?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z PROC ; Json::Reader::getLocationLineAndColumn, COMDAT
; _this$ = ecx

; 848  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _location$[ebp]
  00013	83 65 c4 00	 and	 DWORD PTR $T45897[ebp], 0
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 849  :    int line, column;
; 850  :    getLocationLineAndColumn( location, line, column );

  0001b	8d 55 c0	 lea	 edx, DWORD PTR _column$[ebp]
  0001e	52		 push	 edx
  0001f	8d 55 c4	 lea	 edx, DWORD PTR _line$[ebp]
  00022	52		 push	 edx
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ; Json::Reader::getLocationLineAndColumn

; 851  :    char buffer[18+16+16+1];
; 852  :    sprintf( buffer, "Line %d, Column %d", line, column );

  00029	ff 75 c0	 push	 DWORD PTR _column$[ebp]
  0002c	8d 45 c8	 lea	 eax, DWORD PTR _buffer$[ebp]
  0002f	ff 75 c4	 push	 DWORD PTR _line$[ebp]
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _sprintf
  0003d	83 c4 10	 add	 esp, 16			; 00000010H

; 853  :    return buffer;

  00040	8d 45 c8	 lea	 eax, DWORD PTR _buffer$[ebp]
  00043	50		 push	 eax
  00044	8b ce		 mov	 ecx, esi
  00046	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 854  : }

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004e	8b c6		 mov	 eax, esi
  00050	33 cd		 xor	 ecx, ebp
  00052	5e		 pop	 esi
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	c9		 leave
  00059	c2 08 00	 ret	 8
?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ENDP ; Json::Reader::getLocationLineAndColumn
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 702  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 703  : 		_Tidy();
; 704  : 		assign(_STD forward<_Myt>(_Right));

  00004	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	83 66 10 00	 and	 DWORD PTR [esi+16], 0
  0000d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00014	c6 06 00	 mov	 BYTE PTR [esi], 0
  00017	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 705  : 		}

  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stack
;	COMDAT ?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top, COMDAT
; _this$ = ecx

; 89   : 		return (c.back());

  00000	e9 00 00 00 00	 jmp	 ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top
_TEXT	ENDS
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 472  : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 474  : 	}

  00003	5d		 pop	 ebp

; 473  : 	return (getline(_STD move(_Istr), _Str, _Delim));

  00004	e9 00 00 00 00	 jmp	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogsp
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z
_TEXT	SEGMENT
$T45989 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 126  : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 127  : 	return (_STD move(_Right.insert(0, _Left)));

  00004	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T45989[ebp], 0
  0000b	e8 00 00 00 00	 call	 _strlen
  00010	59		 pop	 ecx
  00011	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  00014	50		 push	 eax
  00015	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  00018	6a 00		 push	 0
  0001a	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 128  : 	}

  0002b	c9		 leave
  0002c	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogsp
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z
_TEXT	SEGMENT
$T46007 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 146  : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 147  : 	return (_STD move(_Left.append(_Right)));

  00004	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR $T46007[ebp], 0
  0000b	e8 00 00 00 00	 call	 _strlen
  00010	59		 pop	 ecx
  00011	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00014	50		 push	 eax
  00015	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  00018	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00026	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 148  : 	}

  00029	c9		 leave
  0002a	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z$0
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\string
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT
$T46026 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 36   : 	{	// return NTCS + string

  00000	6a 04		 push	 4
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	33 db		 xor	 ebx, ebx
  0000e	89 5d f0	 mov	 DWORD PTR $T46026[ebp], ebx

; 37   : 	basic_string<_Elem, _Traits, _Alloc> _Ans;

  00011	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001b	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  0001e	88 1e		 mov	 BYTE PTR [esi], bl

; 38   : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 39   : 	_Ans += _Left;
; 40   : 	_Ans += _Right;
; 41   : 	return (_Ans);

  00020	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  00023	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00026	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T46026[ebp], 1
  0002d	e8 00 00 00 00	 call	 _strlen
  00032	8b 7d 10	 mov	 edi, DWORD PTR __Right$[ebp]
  00035	59		 pop	 ecx
  00036	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00039	03 c8		 add	 ecx, eax
  0003b	51		 push	 ecx
  0003c	8b ce		 mov	 ecx, esi
  0003e	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
  00043	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  00046	e8 00 00 00 00	 call	 _strlen
  0004b	59		 pop	 ecx
  0004c	50		 push	 eax
  0004d	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00057	6a ff		 push	 -1
  00059	53		 push	 ebx
  0005a	57		 push	 edi
  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00062	8b c6		 mov	 eax, esi

; 42   : 	}

  00064	e8 00 00 00 00	 call	 __EH_epilog3
  00069	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T46026[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@operator@6
  0000c	83 65 f0 fe	 and	 DWORD PTR $T46026[ebp], -2 ; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@operator@6:
  00018	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Dest_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@@Z ; std::_Dest_val<std::allocator<Json::Reader::ErrorInfo>,Json::Reader::ErrorInfo>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@@Z PROC ; std::_Dest_val<std::allocator<Json::Reader::ErrorInfo>,Json::Reader::ErrorInfo>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 287  : 	_Alval.destroy(_Pdest);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00006	6a 00		 push	 0
  00008	e8 00 00 00 00	 call	 ??_GErrorInfo@Reader@Json@@QAEPAXI@Z

; 288  : 	}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Dest_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Dest_val<std::allocator<Json::Reader::ErrorInfo>,Json::Reader::ErrorInfo>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct
; Function compile flags: /Ogsp
;	COMDAT ?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00006	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Construct@VErrorInfo@Reader@Json@@ABV123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 198  : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::construct
_TEXT	ENDS
PUBLIC	__First$GSCopy$
PUBLIC	??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<Json::Reader::ErrorInfo *,int,Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,Json::Reader::ErrorInfo>
EXTRN	__EH_epilog3_catch_GS:PROC
EXTRN	__EH_prolog3_catch_GS:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$3
__unwindtable$??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -72						; size = 4
__First$GSCopy$ = -68					; size = 4
$T39017 = -64						; size = 44
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<Json::Reader::ErrorInfo *,int,Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,Json::Reader::ErrorInfo>, COMDAT

; 620  : 	{	// copy _Count * _Valty() to raw _First, using _Al, arbitrary type

  00000	6a 3c		 push	 60			; 0000003cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch_GS
  0000c	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]

; 621  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 622  : //	if (_Count < 0)
; 623  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 624  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 625  : 
; 626  : 	_FwdIt _Next = _First;
; 627  : 
; 628  : 	_TRY_BEGIN

  0000f	33 db		 xor	 ebx, ebx
  00011	89 75 b8	 mov	 DWORD PTR __Next$[ebp], esi
  00014	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
$LN62@Uninit_def:

; 629  : 	for (; 0 < _Count; --_Count, ++_First)

  00017	89 75 bc	 mov	 DWORD PTR __First$GSCopy$[ebp], esi
  0001a	39 5d 0c	 cmp	 DWORD PTR __Count$[ebp], ebx
  0001d	7e 54		 jle	 SHORT $LN4@Uninit_def

; 630  : 
; 631  : 		_Cons_val(_Al, _First, _Valty());

  0001f	c7 45 e0 0f 00
	00 00		 mov	 DWORD PTR $T39017[ebp+32], 15 ; 0000000fH
  00026	89 5d dc	 mov	 DWORD PTR $T39017[ebp+28], ebx
  00029	88 5d cc	 mov	 BYTE PTR $T39017[ebp+12], bl
  0002c	8d 45 c0	 lea	 eax, DWORD PTR $T39017[ebp]
  0002f	50		 push	 eax
  00030	56		 push	 esi
  00031	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00034	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00038	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@V345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@$$QAV234@@Z ; std::_Cons_val<std::allocator<Json::Reader::ErrorInfo>,Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	53		 push	 ebx
  00041	6a 01		 push	 1
  00043	8d 4d cc	 lea	 ecx, DWORD PTR $T39017[ebp+12]
  00046	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  00049	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  0004e	ff 4d 0c	 dec	 DWORD PTR __Count$[ebp]
  00051	83 c6 2c	 add	 esi, 44			; 0000002cH
  00054	eb c1		 jmp	 SHORT $LN62@Uninit_def
__catch$??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 632  : 
; 633  : 	_CATCH_ALL
; 634  : 	for (; _Next != _First; ++_Next)

  00056	8b 75 b8	 mov	 esi, DWORD PTR __Next$[ebp]
  00059	33 db		 xor	 ebx, ebx
$LN63@Uninit_def:

; 635  : 		_Dest_val(_Al, _Next);

  0005b	53		 push	 ebx
  0005c	3b 75 bc	 cmp	 esi, DWORD PTR __First$GSCopy$[ebp]
  0005f	74 0c		 je	 SHORT $LN1@Uninit_def
  00061	8b ce		 mov	 ecx, esi
  00063	e8 00 00 00 00	 call	 ??_GErrorInfo@Reader@Json@@QAEPAXI@Z
  00068	83 c6 2c	 add	 esi, 44			; 0000002cH
  0006b	eb ee		 jmp	 SHORT $LN63@Uninit_def
$LN1@Uninit_def:

; 636  : 	_RERAISE;

  0006d	53		 push	 ebx
  0006e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN64@Uninit_def:
$LN4@Uninit_def:

; 637  : 	_CATCH_END
; 638  : 	}

  00073	e8 00 00 00 00	 call	 __EH_epilog3_catch_GS
  00078	c3		 ret	 0
$LN61@Uninit_def:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR $T39017[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ErrorInfo@Reader@Json@@QAE@XZ
__ehhandler$??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<Json::Reader::ErrorInfo *,int,Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,Json::Reader::ErrorInfo>
PUBLIC	??$_Move_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Dest$ = 36						; size = 12
___formal$ = 48						; size = 1
??$_Move_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move_backward<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >, COMDAT

; 2617 : 	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2618 : 	while (_First != _Last)

  00003	eb 1e		 jmp	 SHORT $LN50@Move_backw
$LL2@Move_backw:

; 2619 : 		*--_Dest = _STD move(*--_Last);

  00005	ff 4d 20	 dec	 DWORD PTR __Last$[ebp+8]
  00008	8d 4d 18	 lea	 ecx, DWORD PTR __Last$[ebp]
  0000b	e8 00 00 00 00	 call	 ??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator*
  00010	ff 4d 2c	 dec	 DWORD PTR __Dest$[ebp+8]
  00013	50		 push	 eax
  00014	8d 4d 24	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00017	e8 00 00 00 00	 call	 ??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator*
  0001c	8b c8		 mov	 ecx, eax
  0001e	e8 00 00 00 00	 call	 ??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z
$LN50@Move_backw:

; 2618 : 	while (_First != _Last)

  00023	8b 45 14	 mov	 eax, DWORD PTR __First$[ebp+8]
  00026	3b 45 20	 cmp	 eax, DWORD PTR __Last$[ebp+8]
  00029	75 da		 jne	 SHORT $LL2@Move_backw

; 2620 : 	return (_Dest);

  0002b	56		 push	 esi
  0002c	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0002f	8d 45 24	 lea	 eax, DWORD PTR __Dest$[ebp]
  00032	50		 push	 eax
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0003a	8b 45 2c	 mov	 eax, DWORD PTR __Dest$[ebp+8]
  0003d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00040	8b c6		 mov	 eax, esi
  00042	5e		 pop	 esi

; 2621 : 	}

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$_Move_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move_backward<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
PUBLIC	??$_Move@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
; Function compile flags: /Ogsp
;	COMDAT ??$_Move@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Dest$ = 36						; size = 12
___formal$ = 48						; size = 1
??$_Move@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	eb 1e		 jmp	 SHORT $LN52@Move
$LL12@Move:

; 2514 : 		*_Dest = _STD move(*_First);

  00005	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00008	e8 00 00 00 00	 call	 ??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator*
  0000d	50		 push	 eax
  0000e	8d 4d 24	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00011	e8 00 00 00 00	 call	 ??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator*
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z
  0001d	ff 45 2c	 inc	 DWORD PTR __Dest$[ebp+8]
  00020	ff 45 14	 inc	 DWORD PTR __First$[ebp+8]
$LN52@Move:

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00023	8b 45 14	 mov	 eax, DWORD PTR __First$[ebp+8]
  00026	3b 45 20	 cmp	 eax, DWORD PTR __Last$[ebp+8]
  00029	75 da		 jne	 SHORT $LL12@Move

; 2515 : 	return (_Dest);

  0002b	56		 push	 esi
  0002c	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0002f	8d 45 24	 lea	 eax, DWORD PTR __Dest$[ebp]
  00032	50		 push	 eax
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0003a	8b 45 2c	 mov	 eax, DWORD PTR __Dest$[ebp+8]
  0003d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00040	8b c6		 mov	 eax, esi
  00042	5e		 pop	 esi

; 2516 : 	}

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$_Move@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z$0
__ehfuncinfo$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T46560 = 12						; size = 4
_cp$ = 12						; size = 4
?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z PROC ; Json::codePointToUTF8, COMDAT

; 70   : {

  00000	6a 00		 push	 0
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b 5d 0c	 mov	 ebx, DWORD PTR _cp$[ebp]
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00012	33 c0		 xor	 eax, eax
  00014	89 45 0c	 mov	 DWORD PTR $T46560[ebp], eax

; 71   :    std::string result;

  00017	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001e	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00021	88 06		 mov	 BYTE PTR [esi], al

; 100  :    }
; 101  : 
; 102  :    return result;

  00023	33 c9		 xor	 ecx, ecx
  00025	41		 inc	 ecx
  00026	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  00029	89 4d 0c	 mov	 DWORD PTR $T46560[ebp], ecx
  0002c	83 fb 7f	 cmp	 ebx, 127		; 0000007fH
  0002f	77 1d		 ja	 SHORT $LN7@codePointT

; 72   :    
; 73   :    // based on description from http://en.wikipedia.org/wiki/UTF-8
; 74   : 
; 75   :    if (cp <= 0x7f) 
; 76   :    {
; 77   :       result.resize(1);

  00031	50		 push	 eax
  00032	51		 push	 ecx
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 78   :       result[0] = static_cast<char>(cp);

  0003a	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0003e	72 07		 jb	 SHORT $LN44@codePointT
  00040	8b 06		 mov	 eax, DWORD PTR [esi]
  00042	e9 16 01 00 00	 jmp	 $LN45@codePointT
$LN44@codePointT:
  00047	8b c6		 mov	 eax, esi
  00049	e9 0f 01 00 00	 jmp	 $LN45@codePointT
$LN7@codePointT:

; 79   :    } 
; 80   :    else if (cp <= 0x7FF) 

  0004e	81 fb ff 07 00
	00		 cmp	 ebx, 2047		; 000007ffH
  00054	77 3b		 ja	 SHORT $LN5@codePointT

; 81   :    {
; 82   :       result.resize(2);

  00056	50		 push	 eax
  00057	6a 02		 push	 2
  00059	8b ce		 mov	 ecx, esi
  0005b	e8 00 00 00 00	 call	 ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 83   :       result[1] = static_cast<char>(0x80 | (0x3f & cp));

  00060	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00064	72 04		 jb	 SHORT $LN52@codePointT
  00066	8b 06		 mov	 eax, DWORD PTR [esi]
  00068	eb 02		 jmp	 SHORT $LN53@codePointT
$LN52@codePointT:
  0006a	8b c6		 mov	 eax, esi
$LN53@codePointT:
  0006c	8a cb		 mov	 cl, bl
  0006e	80 e1 3f	 and	 cl, 63			; 0000003fH
  00071	80 c9 80	 or	 cl, -128		; ffffff80H
  00074	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 84   :       result[0] = static_cast<char>(0xC0 | (0x1f & (cp >> 6)));

  00077	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0007b	72 04		 jb	 SHORT $LN58@codePointT
  0007d	8b 06		 mov	 eax, DWORD PTR [esi]
  0007f	eb 02		 jmp	 SHORT $LN59@codePointT
$LN58@codePointT:
  00081	8b c6		 mov	 eax, esi
$LN59@codePointT:
  00083	c1 eb 06	 shr	 ebx, 6
  00086	80 e3 1f	 and	 bl, 31			; 0000001fH
  00089	80 cb c0	 or	 bl, -64			; ffffffc0H
  0008c	e9 cc 00 00 00	 jmp	 $LN45@codePointT
$LN5@codePointT:

; 85   :    } 
; 86   :    else if (cp <= 0xFFFF) 

  00091	81 fb ff ff 00
	00		 cmp	 ebx, 65535		; 0000ffffH
  00097	77 52		 ja	 SHORT $LN3@codePointT

; 87   :    {
; 88   :       result.resize(3);

  00099	50		 push	 eax
  0009a	6a 03		 push	 3
  0009c	8b ce		 mov	 ecx, esi
  0009e	e8 00 00 00 00	 call	 ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 89   :       result[2] = static_cast<char>(0x80 | (0x3f & cp));

  000a3	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000a7	72 04		 jb	 SHORT $LN66@codePointT
  000a9	8b 06		 mov	 eax, DWORD PTR [esi]
  000ab	eb 02		 jmp	 SHORT $LN67@codePointT
$LN66@codePointT:
  000ad	8b c6		 mov	 eax, esi
$LN67@codePointT:
  000af	8a cb		 mov	 cl, bl
  000b1	80 e1 3f	 and	 cl, 63			; 0000003fH
  000b4	80 c9 80	 or	 cl, -128		; ffffff80H
  000b7	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 90   :       result[1] = 0x80 | static_cast<char>((0x3f & (cp >> 6)));

  000ba	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000be	72 04		 jb	 SHORT $LN72@codePointT
  000c0	8b 06		 mov	 eax, DWORD PTR [esi]
  000c2	eb 02		 jmp	 SHORT $LN73@codePointT
$LN72@codePointT:
  000c4	8b c6		 mov	 eax, esi
$LN73@codePointT:
  000c6	8b cb		 mov	 ecx, ebx
  000c8	c1 e9 06	 shr	 ecx, 6
  000cb	80 e1 3f	 and	 cl, 63			; 0000003fH
  000ce	80 c9 80	 or	 cl, -128		; ffffff80H
  000d1	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 91   :       result[0] = 0xE0 | static_cast<char>((0xf & (cp >> 12)));

  000d4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000d8	72 04		 jb	 SHORT $LN78@codePointT
  000da	8b 06		 mov	 eax, DWORD PTR [esi]
  000dc	eb 02		 jmp	 SHORT $LN79@codePointT
$LN78@codePointT:
  000de	8b c6		 mov	 eax, esi
$LN79@codePointT:
  000e0	c1 eb 0c	 shr	 ebx, 12			; 0000000cH
  000e3	80 e3 0f	 and	 bl, 15			; 0000000fH
  000e6	80 cb e0	 or	 bl, -32			; ffffffe0H
  000e9	eb 72		 jmp	 SHORT $LN45@codePointT
$LN3@codePointT:

; 92   :    }
; 93   :    else if (cp <= 0x10FFFF) 

  000eb	81 fb ff ff 10
	00		 cmp	 ebx, 1114111		; 0010ffffH
  000f1	77 6c		 ja	 SHORT $LN1@codePointT

; 94   :    {
; 95   :       result.resize(4);

  000f3	50		 push	 eax
  000f4	6a 04		 push	 4
  000f6	8b ce		 mov	 ecx, esi
  000f8	e8 00 00 00 00	 call	 ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 96   :       result[3] = static_cast<char>(0x80 | (0x3f & cp));

  000fd	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00101	72 04		 jb	 SHORT $LN86@codePointT
  00103	8b 06		 mov	 eax, DWORD PTR [esi]
  00105	eb 02		 jmp	 SHORT $LN87@codePointT
$LN86@codePointT:
  00107	8b c6		 mov	 eax, esi
$LN87@codePointT:
  00109	8a cb		 mov	 cl, bl
  0010b	80 e1 3f	 and	 cl, 63			; 0000003fH
  0010e	80 c9 80	 or	 cl, -128		; ffffff80H
  00111	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 97   :       result[2] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));

  00114	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00118	72 04		 jb	 SHORT $LN92@codePointT
  0011a	8b 06		 mov	 eax, DWORD PTR [esi]
  0011c	eb 02		 jmp	 SHORT $LN93@codePointT
$LN92@codePointT:
  0011e	8b c6		 mov	 eax, esi
$LN93@codePointT:
  00120	8b cb		 mov	 ecx, ebx
  00122	c1 e9 06	 shr	 ecx, 6
  00125	80 e1 3f	 and	 cl, 63			; 0000003fH
  00128	80 c9 80	 or	 cl, -128		; ffffff80H
  0012b	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 98   :       result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 12)));

  0012e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00132	72 04		 jb	 SHORT $LN98@codePointT
  00134	8b 06		 mov	 eax, DWORD PTR [esi]
  00136	eb 02		 jmp	 SHORT $LN99@codePointT
$LN98@codePointT:
  00138	8b c6		 mov	 eax, esi
$LN99@codePointT:
  0013a	8b cb		 mov	 ecx, ebx
  0013c	c1 e9 0c	 shr	 ecx, 12			; 0000000cH
  0013f	80 e1 3f	 and	 cl, 63			; 0000003fH
  00142	80 c9 80	 or	 cl, -128		; ffffff80H
  00145	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 99   :       result[0] = static_cast<char>(0xF0 | (0x7 & (cp >> 18)));

  00148	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0014c	72 04		 jb	 SHORT $LN104@codePointT
  0014e	8b 06		 mov	 eax, DWORD PTR [esi]
  00150	eb 02		 jmp	 SHORT $LN105@codePointT
$LN104@codePointT:
  00152	8b c6		 mov	 eax, esi
$LN105@codePointT:
  00154	c1 eb 12	 shr	 ebx, 18			; 00000012H
  00157	80 e3 07	 and	 bl, 7
  0015a	80 cb f0	 or	 bl, -16			; fffffff0H
$LN45@codePointT:
  0015d	88 18		 mov	 BYTE PTR [eax], bl
$LN1@codePointT:

; 100  :    }
; 101  : 
; 102  :    return result;

  0015f	8b c6		 mov	 eax, esi

; 103  : }

  00161	e8 00 00 00 00	 call	 __EH_epilog3
  00166	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR $T46560[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN11@codePointT
  0000c	83 65 0c fe	 and	 DWORD PTR $T46560[ebp], -2 ; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN11@codePointT:
  00018	c3		 ret	 0
__ehhandler$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ENDP ; Json::codePointToUTF8
PUBLIC	?readComment@Reader@Json@@AAE_NXZ		; Json::Reader::readComment
; Function compile flags: /Ogsp
;	COMDAT ?readComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
_placement$34587 = -4					; size = 4
?readComment@Reader@Json@@AAE_NXZ PROC			; Json::Reader::readComment, COMDAT
; _this$ = ecx

; 379  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx

; 380  :    Location commentBegin = current_ - 1;

  00009	8b 7e 54	 mov	 edi, DWORD PTR [esi+84]
  0000c	4f		 dec	 edi

; 381  :    Char c = getNextChar();

  0000d	e8 00 00 00 00	 call	 ?getNextChar@Reader@Json@@AAEDXZ ; Json::Reader::getNextChar
  00012	8a d8		 mov	 bl, al

; 382  :    bool successful = false;
; 383  :    if ( c == '*' )

  00014	80 fb 2a	 cmp	 bl, 42			; 0000002aH
  00017	75 07		 jne	 SHORT $LN8@readCommen

; 384  :       successful = readCStyleComment();

  00019	e8 00 00 00 00	 call	 ?readCStyleComment@Reader@Json@@AAE_NXZ ; Json::Reader::readCStyleComment
  0001e	eb 0a		 jmp	 SHORT $LN6@readCommen
$LN8@readCommen:

; 385  :    else if ( c == '/' )

  00020	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00023	75 09		 jne	 SHORT $LN31@readCommen

; 386  :       successful = readCppStyleComment();

  00025	e8 00 00 00 00	 call	 ?readCppStyleComment@Reader@Json@@AAE_NXZ ; Json::Reader::readCppStyleComment
$LN6@readCommen:

; 387  :    if ( !successful )

  0002a	84 c0		 test	 al, al
  0002c	75 04		 jne	 SHORT $LN5@readCommen
$LN31@readCommen:

; 388  :       return false;

  0002e	32 c0		 xor	 al, al
  00030	eb 5a		 jmp	 SHORT $LN9@readCommen
$LN5@readCommen:

; 389  : 
; 390  :    if ( collectComments_ )

  00032	80 7e 7e 00	 cmp	 BYTE PTR [esi+126], 0
  00036	74 52		 je	 SHORT $LN4@readCommen

; 391  :    {
; 392  :       CommentPlacement placement = commentBefore;
; 393  :       if ( lastValueEnd_  &&  !containsNewLine( lastValueEnd_, commentBegin ) )

  00038	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  0003b	83 65 fc 00	 and	 DWORD PTR _placement$34587[ebp], 0
  0003f	85 c0		 test	 eax, eax
  00041	74 39		 je	 SHORT $LN32@readCommen
  00043	eb 0d		 jmp	 SHORT $LN33@readCommen
$LL15@readCommen:
  00045	8a 08		 mov	 cl, BYTE PTR [eax]
  00047	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  0004a	74 30		 je	 SHORT $LN32@readCommen
  0004c	80 f9 0d	 cmp	 cl, 13			; 0000000dH
  0004f	74 2b		 je	 SHORT $LN32@readCommen
  00051	40		 inc	 eax
$LN33@readCommen:
  00052	3b c7		 cmp	 eax, edi
  00054	72 ef		 jb	 SHORT $LL15@readCommen

; 394  :       {
; 395  :          if ( c != '*'  ||  !containsNewLine( commentBegin, current_ ) )

  00056	80 fb 2a	 cmp	 bl, 42			; 0000002aH
  00059	75 1a		 jne	 SHORT $LN20@readCommen
  0005b	8b 56 54	 mov	 edx, DWORD PTR [esi+84]
  0005e	8b c7		 mov	 eax, edi
  00060	3b fa		 cmp	 edi, edx
  00062	73 11		 jae	 SHORT $LN20@readCommen
$LL22@readCommen:
  00064	8a 08		 mov	 cl, BYTE PTR [eax]
  00066	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  00069	74 11		 je	 SHORT $LN32@readCommen
  0006b	80 f9 0d	 cmp	 cl, 13			; 0000000dH
  0006e	74 0c		 je	 SHORT $LN32@readCommen
  00070	40		 inc	 eax
  00071	3b c2		 cmp	 eax, edx
  00073	72 ef		 jb	 SHORT $LL22@readCommen
$LN20@readCommen:

; 396  :             placement = commentAfterOnSameLine;

  00075	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _placement$34587[ebp], 1
$LN32@readCommen:

; 397  :       }
; 398  : 
; 399  :       addComment( commentBegin, current_, placement );

  0007c	ff 75 fc	 push	 DWORD PTR _placement$34587[ebp]
  0007f	8b ce		 mov	 ecx, esi
  00081	ff 76 54	 push	 DWORD PTR [esi+84]
  00084	57		 push	 edi
  00085	e8 00 00 00 00	 call	 ?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ; Json::Reader::addComment
$LN4@readCommen:

; 400  :    }
; 401  :    return true;

  0008a	b0 01		 mov	 al, 1
$LN9@readCommen:
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx

; 402  : }

  0008f	c9		 leave
  00090	c3		 ret	 0
?readComment@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readComment
_TEXT	ENDS
PUBLIC	?currentValue@Reader@Json@@AAEAAVValue@2@XZ	; Json::Reader::currentValue
; Function compile flags: /Ogsp
;	COMDAT ?currentValue@Reader@Json@@AAEAAVValue@2@XZ
_TEXT	SEGMENT
?currentValue@Reader@Json@@AAEAAVValue@2@XZ PROC	; Json::Reader::currentValue, COMDAT
; _this$ = ecx

; 803  :    return *(nodes_.top());

  00000	e8 00 00 00 00	 call	 ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
  00005	8b 00		 mov	 eax, DWORD PTR [eax]

; 804  : }

  00007	c3		 ret	 0
?currentValue@Reader@Json@@AAEAAVValue@2@XZ ENDP	; Json::Reader::currentValue
_TEXT	ENDS
PUBLIC	??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@	; `string'
PUBLIC	??_C@_04JBAOJHKB@See?5?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_02KAOAMBHJ@?$CK?5?$AA@			; `string'
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Reader::getFormatedErrorMessages
;	COMDAT ??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
CONST	SEGMENT
??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@ DB ' for detail.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JBAOJHKB@See?5?$AA@
CONST	SEGMENT
??_C@_04JBAOJHKB@See?5?$AA@ DB 'See ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAOAMBHJ@?$CK?5?$AA@
CONST	SEGMENT
??_C@_02KAOAMBHJ@?$CK?5?$AA@ DB '* ', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$8
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T46854 = -140						; size = 12
___$ReturnUdt$GSCopy$ = -128				; size = 4
$T46856 = -124						; size = 4
_itError$35142 = -120					; size = 12
_error$35165 = -108					; size = 4
_this$GSCopy$ = -104					; size = 4
$T35174 = -100						; size = 28
$T35168 = -100						; size = 28
$T35175 = -72						; size = 28
$T35170 = -72						; size = 28
$T35167 = -72						; size = 28
$T35176 = -44						; size = 28
$T35171 = -44						; size = 28
$T35166 = -44						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Json::Reader::getFormatedErrorMessages, COMDAT
; _this$ = ecx

; 859  : {

  00000	68 80 00 00 00	 push	 128			; 00000080H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
  0000a	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000f	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00012	33 db		 xor	 ebx, ebx
  00014	89 5d 84	 mov	 DWORD PTR $T46856[ebp], ebx
  00017	8b c1		 mov	 eax, ecx

; 860  :    std::string formattedMessage;

  00019	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
  00020	89 5f 10	 mov	 DWORD PTR [edi+16], ebx

; 870  :    }
; 871  :    return formattedMessage;

  00023	89 45 98	 mov	 DWORD PTR _this$GSCopy$[ebp], eax
  00026	89 7d 80	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], edi
  00029	88 1f		 mov	 BYTE PTR [edi], bl
  0002b	33 f6		 xor	 esi, esi
  0002d	8d 48 18	 lea	 ecx, DWORD PTR [eax+24]
  00030	8d 45 88	 lea	 eax, DWORD PTR _itError$35142[ebp]
  00033	46		 inc	 esi
  00034	50		 push	 eax
  00035	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00038	89 75 84	 mov	 DWORD PTR $T46856[ebp], esi
  0003b	e8 00 00 00 00	 call	 ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
  00040	e9 3c 01 00 00	 jmp	 $LN107@getFormate

; 861  :    for ( Errors::const_iterator itError = errors_.begin();
; 862  :          itError != errors_.end();
; 863  :          ++itError )

$LL43@getFormate:

; 864  :    {
; 865  :       const ErrorInfo &error = *itError;

  00045	8d 4d 88	 lea	 ecx, DWORD PTR _itError$35142[ebp]
  00048	e8 00 00 00 00	 call	 ??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator*

; 866  :       formattedMessage += "* " + getLocationLineAndColumn( error.token_.start_ ) + "\n";

  0004d	ff 70 04	 push	 DWORD PTR [eax+4]
  00050	8b 4d 98	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00053	89 45 94	 mov	 DWORD PTR _error$35165[ebp], eax
  00056	8d 45 d4	 lea	 eax, DWORD PTR $T35166[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
  0005f	50		 push	 eax
  00060	8d 45 b8	 lea	 eax, DWORD PTR $T35167[ebp]
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_02KAOAMBHJ@?$CK?5?$AA@
  00068	50		 push	 eax
  00069	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  0006c	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  00076	50		 push	 eax
  00077	8d 45 9c	 lea	 eax, DWORD PTR $T35168[ebp]
  0007a	50		 push	 eax
  0007b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0007f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00084	83 c4 18	 add	 esp, 24			; 00000018H
  00087	6a ff		 push	 -1
  00089	53		 push	 ebx
  0008a	50		 push	 eax
  0008b	8b cf		 mov	 ecx, edi
  0008d	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00091	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00096	53		 push	 ebx
  00097	56		 push	 esi
  00098	8d 4d 9c	 lea	 ecx, DWORD PTR $T35168[ebp]
  0009b	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  000a0	53		 push	 ebx
  000a1	56		 push	 esi
  000a2	8d 4d b8	 lea	 ecx, DWORD PTR $T35167[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  000aa	53		 push	 ebx
  000ab	56		 push	 esi
  000ac	8d 4d d4	 lea	 ecx, DWORD PTR $T35166[ebp]
  000af	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  000b2	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 867  :       formattedMessage += "  " + error.message_ + "\n";

  000b7	8b 45 94	 mov	 eax, DWORD PTR _error$35165[ebp]
  000ba	83 c0 0c	 add	 eax, 12			; 0000000cH
  000bd	50		 push	 eax
  000be	8d 45 b8	 lea	 eax, DWORD PTR $T35170[ebp]
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_02KNHHEEKP@?5?5?$AA@
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  000d1	50		 push	 eax
  000d2	8d 45 d4	 lea	 eax, DWORD PTR $T35171[ebp]
  000d5	50		 push	 eax
  000d6	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  000dd	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000e2	83 c4 18	 add	 esp, 24			; 00000018H
  000e5	6a ff		 push	 -1
  000e7	53		 push	 ebx
  000e8	50		 push	 eax
  000e9	8b cf		 mov	 ecx, edi
  000eb	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000ef	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  000f4	53		 push	 ebx
  000f5	56		 push	 esi
  000f6	8d 4d d4	 lea	 ecx, DWORD PTR $T35171[ebp]
  000f9	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  000fe	53		 push	 ebx
  000ff	56		 push	 esi
  00100	8d 4d b8	 lea	 ecx, DWORD PTR $T35170[ebp]
  00103	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  00106	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 868  :       if ( error.extra_ )

  0010b	8b 45 94	 mov	 eax, DWORD PTR _error$35165[ebp]
  0010e	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00111	3b c3		 cmp	 eax, ebx
  00113	74 69		 je	 SHORT $LN3@getFormate

; 869  :          formattedMessage += "See " + getLocationLineAndColumn( error.extra_ ) + " for detail.\n";

  00115	8b 4d 98	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00118	50		 push	 eax
  00119	8d 45 9c	 lea	 eax, DWORD PTR $T35174[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 ?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
  00122	50		 push	 eax
  00123	8d 45 b8	 lea	 eax, DWORD PTR $T35175[ebp]
  00126	68 00 00 00 00	 push	 OFFSET ??_C@_04JBAOJHKB@See?5?$AA@
  0012b	50		 push	 eax
  0012c	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6
  00133	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00138	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@
  0013d	50		 push	 eax
  0013e	8d 45 d4	 lea	 eax, DWORD PTR $T35176[ebp]
  00141	50		 push	 eax
  00142	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00146	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0014b	83 c4 18	 add	 esp, 24			; 00000018H
  0014e	6a ff		 push	 -1
  00150	53		 push	 ebx
  00151	50		 push	 eax
  00152	8b cf		 mov	 ecx, edi
  00154	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00158	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0015d	53		 push	 ebx
  0015e	56		 push	 esi
  0015f	8d 4d d4	 lea	 ecx, DWORD PTR $T35176[ebp]
  00162	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00167	53		 push	 ebx
  00168	56		 push	 esi
  00169	8d 4d b8	 lea	 ecx, DWORD PTR $T35175[ebp]
  0016c	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00171	53		 push	 ebx
  00172	56		 push	 esi
  00173	8d 4d 9c	 lea	 ecx, DWORD PTR $T35174[ebp]
  00176	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  00179	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
$LN3@getFormate:

; 861  :    for ( Errors::const_iterator itError = errors_.begin();
; 862  :          itError != errors_.end();
; 863  :          ++itError )

  0017e	ff 45 90	 inc	 DWORD PTR _itError$35142[ebp+8]
$LN107@getFormate:
  00181	8b 4d 98	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00184	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR $T46854[ebp]
  0018a	50		 push	 eax
  0018b	83 c1 18	 add	 ecx, 24			; 00000018H
  0018e	e8 00 00 00 00	 call	 ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
  00193	8b 4d 90	 mov	 ecx, DWORD PTR _itError$35142[ebp+8]
  00196	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00199	0f 95 c0	 setne	 al
  0019c	3a c3		 cmp	 al, bl
  0019e	0f 85 a1 fe ff
	ff		 jne	 $LL43@getFormate

; 870  :    }
; 871  :    return formattedMessage;

  001a4	8b c7		 mov	 eax, edi

; 872  : }

  001a6	e8 00 00 00 00	 call	 __EH_epilog3_GS
  001ab	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0:
  00000	8b 45 84	 mov	 eax, DWORD PTR $T46856[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN8@getFormate
  0000c	83 65 84 fe	 and	 DWORD PTR $T46856[ebp], -2 ; fffffffeH
  00010	8b 4d 80	 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@getFormate:
  00018	c3		 ret	 0
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1:
  00019	8d 4d d4	 lea	 ecx, DWORD PTR $T35166[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$2:
  00021	8d 4d b8	 lea	 ecx, DWORD PTR $T35167[ebp]
  00024	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$3:
  00029	8d 4d 9c	 lea	 ecx, DWORD PTR $T35168[ebp]
  0002c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$4:
  00031	8d 4d b8	 lea	 ecx, DWORD PTR $T35170[ebp]
  00034	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$5:
  00039	8d 4d d4	 lea	 ecx, DWORD PTR $T35171[ebp]
  0003c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$6:
  00041	8d 4d 9c	 lea	 ecx, DWORD PTR $T35174[ebp]
  00044	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$7:
  00049	8d 4d b8	 lea	 ecx, DWORD PTR $T35175[ebp]
  0004c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$8:
  00051	8d 4d d4	 lea	 ecx, DWORD PTR $T35176[ebp]
  00054	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
  00059	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0005d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00060	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00066	33 c8		 xor	 ecx, eax
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00070	33 c8		 xor	 ecx, eax
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
  0007c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Json::Reader::getFormatedErrorMessages
PUBLIC	?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front, COMDAT
; _this$ = ecx

; 1232 : 		{	// erase element at beginning

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1233 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1234 : 		if (empty())
; 1235 : 			_DEBUG_ERROR("deque empty before pop");
; 1236 : 		else
; 1237 : 			{	// something to erase, do it
; 1238 : 			_Orphan_off(this->_Myoff);
; 1239 : 			size_type _Block = this->_Myoff / _DEQUESIZ;
; 1240 : 			_Dest_val(this->_Alval,
; 1241 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1242 : 			if (this->_Mapsize * _DEQUESIZ <= ++this->_Myoff)
; 1243 : 				this->_Myoff = 0;
; 1244 : 			if (--this->_Mysize == 0)
; 1245 : 				this->_Myoff = 0;
; 1246 : 			}
; 1247 : 
; 1248 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1249 : 		if (!empty())

  00003	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00007	74 28		 je	 SHORT $LN1@pop_front

; 1250 : 			{	// something to erase, do it
; 1251 : 			size_type _Block = this->_Myoff / _DEQUESIZ;
; 1252 : 			_Dest_val(this->_Alval,
; 1253 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

  00009	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0000c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000f	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00012	6a 00		 push	 0
  00014	e8 00 00 00 00	 call	 ??_GErrorInfo@Reader@Json@@QAEPAXI@Z

; 1254 : 			if (this->_Mapsize * _DEQUESIZ <= ++this->_Myoff)

  00019	ff 46 0c	 inc	 DWORD PTR [esi+12]
  0001c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001f	39 46 08	 cmp	 DWORD PTR [esi+8], eax
  00022	77 04		 ja	 SHORT $LN2@pop_front

; 1255 : 				this->_Myoff = 0;

  00024	83 66 0c 00	 and	 DWORD PTR [esi+12], 0
$LN2@pop_front:

; 1256 : 			if (--this->_Mysize == 0)

  00028	ff 4e 10	 dec	 DWORD PTR [esi+16]
  0002b	75 04		 jne	 SHORT $LN1@pop_front

; 1257 : 				this->_Myoff = 0;

  0002d	83 66 0c 00	 and	 DWORD PTR [esi+12], 0
$LN1@pop_front:
  00031	5e		 pop	 esi

; 1258 : 			}
; 1259 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1260 : 		}

  00032	c3		 ret	 0
?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
_TEXT	ENDS
PUBLIC	?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
; Function compile flags: /Ogsp
;	COMDAT ?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back, COMDAT
; _this$ = ecx

; 1272 : 		{	// erase element at end

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1273 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1274 : 		if (empty())
; 1275 : 			_DEBUG_ERROR("deque empty before pop");
; 1276 : 		else
; 1277 : 			{	// something to erase, do it
; 1278 : 			_Orphan_off(this->_Myoff + this->_Mysize - 1);
; 1279 : 			size_type _Newoff = this->_Mysize + this->_Myoff - 1;
; 1280 : 			size_type _Block = _Newoff / _DEQUESIZ;
; 1281 : 			if (this->_Mapsize <= _Block)
; 1282 : 				_Block -= this->_Mapsize;
; 1283 : 			_Dest_val(this->_Alval,
; 1284 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1285 : 			if (--this->_Mysize == 0)
; 1286 : 				this->_Myoff = 0;
; 1287 : 			}
; 1288 : 
; 1289 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1290 : 		if (!empty())

  00003	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00006	85 c0		 test	 eax, eax
  00008	74 26		 je	 SHORT $LN1@pop_back@2

; 1291 : 			{	// something to erase, do it
; 1292 : 			size_type _Newoff = this->_Mysize + this->_Myoff - 1;
; 1293 : 			size_type _Block = _Newoff / _DEQUESIZ;

  0000a	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0000d	8d 44 08 ff	 lea	 eax, DWORD PTR [eax+ecx-1]

; 1294 : 			if (this->_Mapsize <= _Block)

  00011	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00014	3b c8		 cmp	 ecx, eax
  00016	77 02		 ja	 SHORT $LN2@pop_back@2

; 1295 : 				_Block -= this->_Mapsize;

  00018	2b c1		 sub	 eax, ecx
$LN2@pop_back@2:

; 1296 : 			_Dest_val(this->_Alval,
; 1297 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);

  0001a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001d	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00020	6a 00		 push	 0
  00022	e8 00 00 00 00	 call	 ??_GErrorInfo@Reader@Json@@QAEPAXI@Z

; 1298 : 			if (--this->_Mysize == 0)

  00027	ff 4e 10	 dec	 DWORD PTR [esi+16]
  0002a	75 04		 jne	 SHORT $LN1@pop_back@2

; 1299 : 				this->_Myoff = 0;

  0002c	83 66 0c 00	 and	 DWORD PTR [esi+12], 0
$LN1@pop_back@2:
  00030	5e		 pop	 esi

; 1300 : 			}
; 1301 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1302 : 		}

  00031	c3		 ret	 0
?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
_TEXT	ENDS
PUBLIC	??$_Uninitialized_default_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@@Z ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo *,int,Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_default_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@@Z
_TEXT	SEGMENT
__Cat$47147 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Pval$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_default_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo *,int,Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT

; 670  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 671  : 	_Uninit_def_fill_n(_First, _Count, _Pval, _Al,
; 672  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$47147[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Pval$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<Json::Reader::ErrorInfo *,int,Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,Json::Reader::ErrorInfo>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 673  : 	}

  0001d	c9		 leave
  0001e	c3		 ret	 0
??$_Uninitialized_default_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo *,int,Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@ABV345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@ABV234@@Z ; std::_Cons_val<std::allocator<Json::Reader::ErrorInfo>,Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@ABV345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@ABV234@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@ABV345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@ABV234@@Z PROC ; std::_Cons_val<std::allocator<Json::Reader::ErrorInfo>,Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	ff 75 10	 push	 DWORD PTR __Src$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Pdest$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Construct@VErrorInfo@Reader@Json@@ABV123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 281  : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Cons_val@V?$allocator@VErrorInfo@Reader@Json@@@std@@VErrorInfo@Reader@Json@@ABV345@@std@@YAXAAV?$allocator@VErrorInfo@Reader@Json@@@0@PAVErrorInfo@Reader@Json@@ABV234@@Z ENDP ; std::_Cons_val<std::allocator<Json::Reader::ErrorInfo>,Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
_TEXT	ENDS
PUBLIC	??$_Move_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00@Z ; std::_Move_backward<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T47164 = -4						; size = 4
$T47163 = -4						; size = 4
$T47162 = -4						; size = 4
__Cat$47171 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Dest$ = 36						; size = 12
??$_Move_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00@Z PROC ; std::_Move_backward<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >, COMDAT

; 2638 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 2639 : 	return (_Move_backward(_First, _Last,
; 2640 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00005	ff 75 08	 push	 DWORD PTR __Cat$47171[ebp]
  00008	8d 45 24	 lea	 eax, DWORD PTR __Dest$[ebp]
  0000b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000e	8b f4		 mov	 esi, esp
  00010	89 65 fc	 mov	 DWORD PTR $T47162[ebp], esp
  00013	50		 push	 eax
  00014	8b ce		 mov	 ecx, esi
  00016	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0001b	8b 45 2c	 mov	 eax, DWORD PTR __Dest$[ebp+8]
  0001e	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00021	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00024	8b f4		 mov	 esi, esp
  00026	8d 45 18	 lea	 eax, DWORD PTR __Last$[ebp]
  00029	89 65 fc	 mov	 DWORD PTR $T47163[ebp], esp
  0002c	50		 push	 eax
  0002d	8b ce		 mov	 ecx, esi
  0002f	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  00034	8b 45 20	 mov	 eax, DWORD PTR __Last$[ebp+8]
  00037	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0003a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003d	8b f4		 mov	 esi, esp
  0003f	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  00042	89 65 fc	 mov	 DWORD PTR $T47164[ebp], esp
  00045	50		 push	 eax
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0004d	8b 45 14	 mov	 eax, DWORD PTR __First$[ebp+8]
  00050	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00053	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00056	e8 00 00 00 00	 call	 ??$_Move_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
  0005b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005e	83 c4 2c	 add	 esp, 44			; 0000002cH

; 2641 : 	}

  00061	5e		 pop	 esi
  00062	c9		 leave
  00063	c3		 ret	 0
??$_Move_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00@Z ENDP ; std::_Move_backward<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
PUBLIC	??$_Move@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00@Z ; std::_Move<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
; Function compile flags: /Ogsp
;	COMDAT ??$_Move@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T47249 = -4						; size = 4
$T47248 = -4						; size = 4
$T47247 = -4						; size = 4
__Cat$47255 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Dest$ = 36						; size = 12
??$_Move@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00@Z PROC ; std::_Move<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00005	ff 75 08	 push	 DWORD PTR __Cat$47255[ebp]
  00008	8d 45 24	 lea	 eax, DWORD PTR __Dest$[ebp]
  0000b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000e	8b f4		 mov	 esi, esp
  00010	89 65 fc	 mov	 DWORD PTR $T47247[ebp], esp
  00013	50		 push	 eax
  00014	8b ce		 mov	 ecx, esi
  00016	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0001b	8b 45 2c	 mov	 eax, DWORD PTR __Dest$[ebp+8]
  0001e	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00021	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00024	8b f4		 mov	 esi, esp
  00026	8d 45 18	 lea	 eax, DWORD PTR __Last$[ebp]
  00029	89 65 fc	 mov	 DWORD PTR $T47248[ebp], esp
  0002c	50		 push	 eax
  0002d	8b ce		 mov	 ecx, esi
  0002f	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  00034	8b 45 20	 mov	 eax, DWORD PTR __Last$[ebp+8]
  00037	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0003a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003d	8b f4		 mov	 esi, esp
  0003f	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  00042	89 65 fc	 mov	 DWORD PTR $T47249[ebp], esp
  00045	50		 push	 eax
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0004d	8b 45 14	 mov	 eax, DWORD PTR __First$[ebp+8]
  00050	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00053	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00056	e8 00 00 00 00	 call	 ??$_Move@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
  0005b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005e	83 c4 2c	 add	 esp, 44			; 0000002cH

; 2536 : 	}

  00061	5e		 pop	 esi
  00062	c9		 leave
  00063	c3		 ret	 0
??$_Move@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00@Z ENDP ; std::_Move<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
PUBLIC	??_C@_04KCECFHEP@alse?$AA@			; `string'
PUBLIC	??_C@_03KNPGGKC@ull?$AA@			; `string'
PUBLIC	??_C@_03FFDNHNKN@rue?$AA@			; `string'
PUBLIC	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readToken
;	COMDAT ??_C@_04KCECFHEP@alse?$AA@
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
CONST	SEGMENT
??_C@_04KCECFHEP@alse?$AA@ DB 'alse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KNPGGKC@ull?$AA@
CONST	SEGMENT
??_C@_03KNPGGKC@ull?$AA@ DB 'ull', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFDNHNKN@rue?$AA@
CONST	SEGMENT
??_C@_03FFDNHNKN@rue?$AA@ DB 'rue', 00H			; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
_token$ = 8						; size = 4
?readToken@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::readToken, COMDAT
; _this$ = ecx

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 276  :    skipSpaces();

  00008	e8 00 00 00 00	 call	 ?skipSpaces@Reader@Json@@AAEXXZ ; Json::Reader::skipSpaces

; 277  :    token.start_ = current_;

  0000d	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  00010	8b 75 08	 mov	 esi, DWORD PTR _token$[ebp]
  00013	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 278  :    Char c = getNextChar();
; 279  :    bool ok = true;

  00016	b3 01		 mov	 bl, 1
  00018	e8 00 00 00 00	 call	 ?getNextChar@Reader@Json@@AAEDXZ ; Json::Reader::getNextChar

; 280  :    switch ( c )

  0001d	0f be c0	 movsx	 eax, al
  00020	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  00023	0f 8f 89 00 00
	00		 jg	 $LN20@readToken
  00029	74 7f		 je	 SHORT $LN13@readToken
  0002b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0002e	7f 39		 jg	 SHORT $LN21@readToken
  00030	74 5b		 je	 SHORT $LN9@readToken
  00032	85 c0		 test	 eax, eax
  00034	74 2b		 je	 SHORT $LN3@readToken
  00036	83 f8 22	 cmp	 eax, 34			; 00000022H
  00039	74 14		 je	 SHORT $LN11@readToken
  0003b	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  0003e	0f 85 d9 00 00
	00		 jne	 $LN22@readToken

; 328  :    case ',':
; 329  :       token.type_ = tokenArraySeparator;

  00044	c7 06 0a 00 00
	00		 mov	 DWORD PTR [esi], 10	; 0000000aH

; 330  :       break;

  0004a	e9 d4 00 00 00	 jmp	 $LN1@readToken
$LN11@readToken:

; 293  :       break;
; 294  :    case '"':
; 295  :       token.type_ = tokenString;

  0004f	c7 06 05 00 00
	00		 mov	 DWORD PTR [esi], 5

; 296  :       ok = readString();

  00055	e8 00 00 00 00	 call	 ?readString@Reader@Json@@AAE_NXZ ; Json::Reader::readString
$LN23@readToken:
  0005a	8a d8		 mov	 bl, al

; 297  :       break;

  0005c	e9 b8 00 00 00	 jmp	 $LN16@readToken
$LN3@readToken:

; 334  :    case 0:
; 335  :       token.type_ = tokenEndOfStream;

  00061	83 26 00	 and	 DWORD PTR [esi], 0

; 336  :       break;

  00064	e9 ba 00 00 00	 jmp	 $LN1@readToken
$LN21@readToken:

; 280  :    switch ( c )

  00069	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0006c	74 2f		 je	 SHORT $LN10@readToken
  0006e	0f 8e a9 00 00
	00		 jle	 $LN22@readToken
  00074	83 f8 39	 cmp	 eax, 57			; 00000039H
  00077	7e 14		 jle	 SHORT $LN9@readToken
  00079	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  0007c	0f 85 9b 00 00
	00		 jne	 $LN22@readToken

; 331  :    case ':':
; 332  :       token.type_ = tokenMemberSeparator;

  00082	c7 06 0b 00 00
	00		 mov	 DWORD PTR [esi], 11	; 0000000bH

; 333  :       break;

  00088	e9 96 00 00 00	 jmp	 $LN1@readToken
$LN9@readToken:

; 302  :    case '0':
; 303  :    case '1':
; 304  :    case '2':
; 305  :    case '3':
; 306  :    case '4':
; 307  :    case '5':
; 308  :    case '6':
; 309  :    case '7':
; 310  :    case '8':
; 311  :    case '9':
; 312  :    case '-':
; 313  :       token.type_ = tokenNumber;

  0008d	c7 06 06 00 00
	00		 mov	 DWORD PTR [esi], 6

; 314  :       readNumber();

  00093	e8 00 00 00 00	 call	 ?readNumber@Reader@Json@@AAEXXZ ; Json::Reader::readNumber

; 315  :       break;

  00098	e9 86 00 00 00	 jmp	 $LN1@readToken
$LN10@readToken:

; 298  :    case '/':
; 299  :       token.type_ = tokenComment;

  0009d	c7 06 0c 00 00
	00		 mov	 DWORD PTR [esi], 12	; 0000000cH

; 300  :       ok = readComment();

  000a3	e8 00 00 00 00	 call	 ?readComment@Reader@Json@@AAE_NXZ ; Json::Reader::readComment

; 301  :       break;

  000a8	eb b0		 jmp	 SHORT $LN23@readToken
$LN13@readToken:

; 288  :    case '[':
; 289  :       token.type_ = tokenArrayBegin;

  000aa	c7 06 03 00 00
	00		 mov	 DWORD PTR [esi], 3

; 290  :       break;

  000b0	eb 71		 jmp	 SHORT $LN1@readToken
$LN20@readToken:

; 280  :    switch ( c )

  000b2	83 e8 5d	 sub	 eax, 93			; 0000005dH
  000b5	74 5c		 je	 SHORT $LN12@readToken
  000b7	6a 09		 push	 9
  000b9	59		 pop	 ecx
  000ba	2b c1		 sub	 eax, ecx
  000bc	74 46		 je	 SHORT $LN7@readToken
  000be	83 e8 08	 sub	 eax, 8
  000c1	74 36		 je	 SHORT $LN6@readToken
  000c3	83 e8 06	 sub	 eax, 6
  000c6	74 18		 je	 SHORT $LN8@readToken
  000c8	83 e8 07	 sub	 eax, 7
  000cb	74 0b		 je	 SHORT $LN15@readToken
  000cd	6a 02		 push	 2
  000cf	59		 pop	 ecx
  000d0	2b c1		 sub	 eax, ecx
  000d2	75 49		 jne	 SHORT $LN22@readToken

; 285  :    case '}':
; 286  :       token.type_ = tokenObjectEnd;

  000d4	89 0e		 mov	 DWORD PTR [esi], ecx

; 287  :       break;

  000d6	eb 4b		 jmp	 SHORT $LN1@readToken
$LN15@readToken:

; 281  :    {
; 282  :    case '{':
; 283  :       token.type_ = tokenObjectBegin;

  000d8	c7 06 01 00 00
	00		 mov	 DWORD PTR [esi], 1

; 284  :       break;

  000de	eb 43		 jmp	 SHORT $LN1@readToken
$LN8@readToken:

; 316  :    case 't':
; 317  :       token.type_ = tokenTrue;
; 318  :       ok = match( "rue", 3 );

  000e0	6a 03		 push	 3
  000e2	c7 06 07 00 00
	00		 mov	 DWORD PTR [esi], 7
  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_03FFDNHNKN@rue?$AA@
$LN24@readToken:
  000ed	8b cf		 mov	 ecx, edi
  000ef	e8 00 00 00 00	 call	 ?match@Reader@Json@@AAE_NPBDH@Z ; Json::Reader::match

; 319  :       break;

  000f4	e9 61 ff ff ff	 jmp	 $LN23@readToken
$LN6@readToken:

; 324  :    case 'n':
; 325  :       token.type_ = tokenNull;
; 326  :       ok = match( "ull", 3 );

  000f9	6a 03		 push	 3
  000fb	89 0e		 mov	 DWORD PTR [esi], ecx
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_03KNPGGKC@ull?$AA@

; 327  :       break;

  00102	eb e9		 jmp	 SHORT $LN24@readToken
$LN7@readToken:

; 320  :    case 'f':
; 321  :       token.type_ = tokenFalse;
; 322  :       ok = match( "alse", 4 );

  00104	6a 04		 push	 4
  00106	c7 06 08 00 00
	00		 mov	 DWORD PTR [esi], 8
  0010c	68 00 00 00 00	 push	 OFFSET ??_C@_04KCECFHEP@alse?$AA@

; 323  :       break;

  00111	eb da		 jmp	 SHORT $LN24@readToken
$LN12@readToken:

; 291  :    case ']':
; 292  :       token.type_ = tokenArrayEnd;

  00113	c7 06 04 00 00
	00		 mov	 DWORD PTR [esi], 4
$LN16@readToken:

; 337  :    default:
; 338  :       ok = false;
; 339  :       break;
; 340  :    }
; 341  :    if ( !ok )

  00119	84 db		 test	 bl, bl
  0011b	75 06		 jne	 SHORT $LN1@readToken
$LN22@readToken:

; 342  :       token.type_ = tokenError;

  0011d	c7 06 0d 00 00
	00		 mov	 DWORD PTR [esi], 13	; 0000000dH
$LN1@readToken:

; 343  :    token.end_ = current_;

  00123	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  00126	5f		 pop	 edi
  00127	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0012a	5e		 pop	 esi

; 344  :    return true;

  0012b	b0 01		 mov	 al, 1
  0012d	5b		 pop	 ebx

; 345  : }

  0012e	5d		 pop	 ebp
  0012f	c2 04 00	 ret	 4
?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readToken
_TEXT	ENDS
PUBLIC	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
$T47364 = -16						; size = 12
$T47347 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back, COMDAT
; _this$ = ecx

; 1263 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1264 : 		this->_Orphan_all();
; 1265 : 		_PUSH_BACK_BEGIN;

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	40		 inc	 eax
  0000d	57		 push	 edi
  0000e	39 46 08	 cmp	 DWORD PTR [esi+8], eax
  00011	77 07		 ja	 SHORT $LN3@push_back@2
  00013	6a 01		 push	 1
  00015	e8 00 00 00 00	 call	 ?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN3@push_back@2:
  0001a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001d	03 46 10	 add	 eax, DWORD PTR [esi+16]
  00020	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00023	3b c8		 cmp	 ecx, eax
  00025	77 02		 ja	 SHORT $LN2@push_back@2
  00027	2b c1		 sub	 eax, ecx
$LN2@push_back@2:
  00029	8b f8		 mov	 edi, eax
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	83 3c b8 00	 cmp	 DWORD PTR [eax+edi*4], 0
  00032	75 12		 jne	 SHORT $LN1@push_back@2
  00034	6a 2c		 push	 44			; 0000002cH
  00036	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003b	59		 pop	 ecx
  0003c	85 c0		 test	 eax, eax
  0003e	74 1f		 je	 SHORT $LN10@push_back@2
  00040	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00043	89 04 b9	 mov	 DWORD PTR [ecx+edi*4], eax
$LN1@push_back@2:

; 1266 : 		_Cons_val(this->_Alval,
; 1267 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

  00046	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  00049	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0004c	ff 34 b8	 push	 DWORD PTR [eax+edi*4]
  0004f	e8 00 00 00 00	 call	 ??$_Construct@VErrorInfo@Reader@Json@@ABV123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>

; 1268 : 		_PUSH_BACK_END;

  00054	ff 46 10	 inc	 DWORD PTR [esi+16]
  00057	59		 pop	 ecx
  00058	59		 pop	 ecx
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi

; 1269 : 		}

  0005b	c9		 leave
  0005c	c2 04 00	 ret	 4

; 1264 : 		this->_Orphan_all();
; 1265 : 		_PUSH_BACK_BEGIN;

$LN10@push_back@2:
  0005f	83 65 fc 00	 and	 DWORD PTR $T47347[ebp], 0
  00063	8d 45 fc	 lea	 eax, DWORD PTR $T47347[ebp]
  00066	50		 push	 eax
  00067	8d 4d f0	 lea	 ecx, DWORD PTR $T47364[ebp]
  0006a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0006f	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00074	8d 45 f0	 lea	 eax, DWORD PTR $T47364[ebp]
  00077	50		 push	 eax
  00078	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T47364[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0007f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN28@push_back@2:
$LN27@push_back@2:
  00084	cc		 int	 3
?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@0@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase
; Function compile flags: /Ogsp
;	COMDAT ?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@0@Z
_TEXT	SEGMENT
$T47407 = -44						; size = 12
$T47406 = -44						; size = 12
$T47402 = -44						; size = 12
$T47398 = -44						; size = 12
$T47396 = -44						; size = 12
__Last$ = -32						; size = 12
__First$ = -20						; size = 12
$T47405 = -8						; size = 4
$T47404 = -8						; size = 4
$T47401 = -8						; size = 4
$T47400 = -8						; size = 4
$T47399 = -8						; size = 4
__Off$ = -4						; size = 4
$T47395 = -4						; size = 4
$T47394 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 12
__Last_arg$ = 24					; size = 12
?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@0@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase, COMDAT
; _this$ = ecx

; 1423 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1424 : 		iterator _First = _Make_iter(_First_arg);

  00009	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000c	8b f4		 mov	 esi, esp
  0000e	8d 45 0c	 lea	 eax, DWORD PTR __First_arg$[ebp]
  00011	8b d9		 mov	 ebx, ecx
  00013	89 65 fc	 mov	 DWORD PTR $T47394[ebp], esp
  00016	50		 push	 eax
  00017	8b ce		 mov	 ecx, esi
  00019	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0001e	8b 45 14	 mov	 eax, DWORD PTR __First_arg$[ebp+8]
  00021	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00024	8d 45 ec	 lea	 eax, DWORD PTR __First$[ebp]
  00027	50		 push	 eax
  00028	8b cb		 mov	 ecx, ebx
  0002a	e8 00 00 00 00	 call	 ?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter

; 1425 : 		iterator _Last = _Make_iter(_Last_arg);

  0002f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00032	8b f4		 mov	 esi, esp
  00034	8d 45 18	 lea	 eax, DWORD PTR __Last_arg$[ebp]
  00037	89 65 fc	 mov	 DWORD PTR $T47395[ebp], esp
  0003a	50		 push	 eax
  0003b	8b ce		 mov	 ecx, esi
  0003d	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  00042	8b 45 20	 mov	 eax, DWORD PTR __Last_arg$[ebp+8]
  00045	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00048	8d 45 e0	 lea	 eax, DWORD PTR __Last$[ebp]
  0004b	50		 push	 eax
  0004c	8b cb		 mov	 ecx, ebx
  0004e	e8 00 00 00 00	 call	 ?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter

; 1426 : 
; 1427 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1428 : 		if (_Last < _First
; 1429 : 			|| _First < begin() || end() < _Last)
; 1430 : 			_DEBUG_ERROR("deque erase iterator outside range");
; 1431 : 		_DEBUG_RANGE(_First, _Last);
; 1432 : 
; 1433 : 		size_type _Off = _First - begin();
; 1434 : 		size_type _Count = _Last - _First;
; 1435 : 		bool _Moved = 0 < _Off && _Off + _Count < this->_Mysize;
; 1436 : 
; 1437 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1438 : 		size_type _Off = _First - begin();

  00053	8d 45 d4	 lea	 eax, DWORD PTR $T47396[ebp]
  00056	50		 push	 eax
  00057	8b cb		 mov	 ecx, ebx
  00059	e8 00 00 00 00	 call	 ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
  0005e	8b 55 f4	 mov	 edx, DWORD PTR __First$[ebp+8]
  00061	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1439 : 		size_type _Count = _Last - _First;

  00064	8b 7d e8	 mov	 edi, DWORD PTR __Last$[ebp+8]
  00067	8b ca		 mov	 ecx, edx
  00069	2b c8		 sub	 ecx, eax

; 1440 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1441 : 
; 1442 : 		if (_Off < (size_type)(end() - _Last))

  0006b	8d 45 d4	 lea	 eax, DWORD PTR $T47398[ebp]
  0006e	89 4d fc	 mov	 DWORD PTR __Off$[ebp], ecx
  00071	8b f7		 mov	 esi, edi
  00073	50		 push	 eax
  00074	8b cb		 mov	 ecx, ebx
  00076	2b f2		 sub	 esi, edx
  00078	e8 00 00 00 00	 call	 ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
  0007d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00080	2b c7		 sub	 eax, edi
  00082	39 45 fc	 cmp	 DWORD PTR __Off$[ebp], eax
  00085	0f 92 c0	 setb	 al

; 1443 : 			{	// closer to front
; 1444 : 			_Move_backward(begin(), _First, _Last);	// copy over hole

  00088	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0008b	8b fc		 mov	 edi, esp
  0008d	89 65 f8	 mov	 DWORD PTR $T47399[ebp], esp
  00090	8b cf		 mov	 ecx, edi
  00092	84 c0		 test	 al, al
  00094	74 54		 je	 SHORT $LN8@erase@2
  00096	8d 45 e0	 lea	 eax, DWORD PTR __Last$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0009f	8b 45 e8	 mov	 eax, DWORD PTR __Last$[ebp+8]
  000a2	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000a5	89 47 08	 mov	 DWORD PTR [edi+8], eax
  000a8	8b fc		 mov	 edi, esp
  000aa	8d 45 ec	 lea	 eax, DWORD PTR __First$[ebp]
  000ad	89 65 f8	 mov	 DWORD PTR $T47400[ebp], esp
  000b0	50		 push	 eax
  000b1	8b cf		 mov	 ecx, edi
  000b3	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  000b8	8b 45 f4	 mov	 eax, DWORD PTR __First$[ebp+8]
  000bb	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000be	89 47 08	 mov	 DWORD PTR [edi+8], eax
  000c1	8b c4		 mov	 eax, esp
  000c3	89 65 f8	 mov	 DWORD PTR $T47401[ebp], esp
  000c6	50		 push	 eax
  000c7	8b cb		 mov	 ecx, ebx
  000c9	e8 00 00 00 00	 call	 ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
  000ce	8d 45 d4	 lea	 eax, DWORD PTR $T47402[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 ??$_Move_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00@Z ; std::_Move_backward<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
  000d7	83 c4 28	 add	 esp, 40			; 00000028H

; 1445 : 			for (; 0 < _Count; --_Count)

  000da	85 f6		 test	 esi, esi
  000dc	74 5e		 je	 SHORT $LN1@erase@2
$LL7@erase@2:

; 1446 : 				pop_front();	// pop copied elements

  000de	8b cb		 mov	 ecx, ebx
  000e0	e8 00 00 00 00	 call	 ?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
  000e5	4e		 dec	 esi
  000e6	75 f6		 jne	 SHORT $LL7@erase@2

; 1447 : 			}
; 1448 : 		else

  000e8	eb 52		 jmp	 SHORT $LN1@erase@2
$LN8@erase@2:

; 1449 : 			{	// closer to back
; 1450 : 			_Move(_Last, end(), _First);	// copy over hole

  000ea	8d 45 ec	 lea	 eax, DWORD PTR __First$[ebp]
  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  000f3	8b 45 f4	 mov	 eax, DWORD PTR __First$[ebp+8]
  000f6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000f9	89 47 08	 mov	 DWORD PTR [edi+8], eax
  000fc	8b c4		 mov	 eax, esp
  000fe	89 65 f8	 mov	 DWORD PTR $T47404[ebp], esp
  00101	50		 push	 eax
  00102	8b cb		 mov	 ecx, ebx
  00104	e8 00 00 00 00	 call	 ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
  00109	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0010c	8b fc		 mov	 edi, esp
  0010e	8d 45 e0	 lea	 eax, DWORD PTR __Last$[ebp]
  00111	89 65 f8	 mov	 DWORD PTR $T47405[ebp], esp
  00114	50		 push	 eax
  00115	8b cf		 mov	 ecx, edi
  00117	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0011c	8b 45 e8	 mov	 eax, DWORD PTR __Last$[ebp+8]
  0011f	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00122	8d 45 d4	 lea	 eax, DWORD PTR $T47406[ebp]
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 ??$_Move@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V10@00@Z ; std::_Move<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
  0012b	83 c4 28	 add	 esp, 40			; 00000028H

; 1451 : 			for (; 0 < _Count; --_Count)

  0012e	85 f6		 test	 esi, esi
  00130	74 0a		 je	 SHORT $LN1@erase@2
$LL3@erase@2:

; 1452 : 				pop_back();	// pop copied elements

  00132	8b cb		 mov	 ecx, ebx
  00134	e8 00 00 00 00	 call	 ?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
  00139	4e		 dec	 esi
  0013a	75 f6		 jne	 SHORT $LL3@erase@2
$LN1@erase@2:

; 1453 : 			}
; 1454 : 
; 1455 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1456 : 		if (_Moved)
; 1457 : 			this->_Orphan_all();
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 
; 1460 : 		return (begin() + _Off);

  0013c	ff 75 fc	 push	 DWORD PTR __Off$[ebp]
  0013f	8d 45 d4	 lea	 eax, DWORD PTR $T47407[ebp]
  00142	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00145	8b cb		 mov	 ecx, ebx
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
  0014d	8b c8		 mov	 ecx, eax
  0014f	e8 00 00 00 00	 call	 ??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator+
  00154	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1461 : 		}

  00157	5f		 pop	 edi
  00158	5e		 pop	 esi
  00159	5b		 pop	 ebx
  0015a	c9		 leave
  0015b	c2 1c 00	 ret	 28			; 0000001cH
?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@0@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
; Function compile flags: /Ogsp
;	COMDAT ?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1638 : 		{	// free all storage

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 1639 : 		while (!empty())

  00004	33 db		 xor	 ebx, ebx
  00006	eb 07		 jmp	 SHORT $LN24@Tidy@5
$LL6@Tidy@5:

; 1640 : 			pop_back();

  00008	8b ce		 mov	 ecx, esi
  0000a	e8 00 00 00 00	 call	 ?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
$LN24@Tidy@5:

; 1639 : 		while (!empty())

  0000f	39 5e 10	 cmp	 DWORD PTR [esi+16], ebx
  00012	75 f4		 jne	 SHORT $LL6@Tidy@5

; 1641 : 		for (size_type _Count = this->_Mapsize; 0 < _Count; )

  00014	57		 push	 edi
  00015	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00018	eb 10		 jmp	 SHORT $LN25@Tidy@5
$LL4@Tidy@5:

; 1642 : 			{	// free storage for a block and destroy pointer
; 1643 : 			if (*(this->_Map + --_Count) != 0)

  0001a	4f		 dec	 edi
  0001b	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  0001e	39 18		 cmp	 DWORD PTR [eax], ebx
  00020	74 08		 je	 SHORT $LN25@Tidy@5

; 1644 : 				{	// free block and destroy its pointer
; 1645 : 				this->_Alval.deallocate(*(this->_Map + _Count), _DEQUESIZ);

  00022	ff 30		 push	 DWORD PTR [eax]
  00024	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00029	59		 pop	 ecx
$LN25@Tidy@5:

; 1646 : 				_Dest_val(this->_Almap, this->_Map + _Count);
; 1647 : 				}
; 1648 : 			}
; 1649 : 
; 1650 : 		if (this->_Map != 0)

  0002a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002d	3b fb		 cmp	 edi, ebx
  0002f	77 e9		 ja	 SHORT $LL4@Tidy@5
  00031	5f		 pop	 edi
  00032	3b c3		 cmp	 eax, ebx
  00034	74 07		 je	 SHORT $LN19@Tidy@5

; 1651 : 			this->_Almap.deallocate(this->_Map,
; 1652 : 				this->_Mapsize);	// free storage for map

  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	59		 pop	 ecx
$LN19@Tidy@5:

; 1653 : 		this->_Mapsize = 0;

  0003d	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 1654 : 		this->_Map = 0;

  00040	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 1655 : 		}

  00045	c3		 ret	 0
?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
_TEXT	ENDS
PUBLIC	?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ; Json::Reader::skipCommentTokens
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
;	COMDAT ?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z
_TEXT	SEGMENT
_token$ = 8						; size = 4
?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z PROC	; Json::Reader::skipCommentTokens, COMDAT
; _this$ = ecx

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 248  :    if ( features_.allowComments_ )

  00006	80 7f 7c 00	 cmp	 BYTE PTR [edi+124], 0
  0000a	74 14		 je	 SHORT $LN5@skipCommen
  0000c	56		 push	 esi
  0000d	8b 75 08	 mov	 esi, DWORD PTR _token$[ebp]
$LL4@skipCommen:

; 249  :    {
; 250  :       do
; 251  :       {
; 252  :          readToken( token );

  00010	56		 push	 esi
  00011	8b cf		 mov	 ecx, edi
  00013	e8 00 00 00 00	 call	 ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 253  :       }
; 254  :       while ( token.type_ == tokenComment );

  00018	83 3e 0c	 cmp	 DWORD PTR [esi], 12	; 0000000cH
  0001b	74 f3		 je	 SHORT $LL4@skipCommen
  0001d	5e		 pop	 esi

; 255  :    }
; 256  :    else

  0001e	eb 08		 jmp	 SHORT $LN1@skipCommen
$LN5@skipCommen:

; 257  :    {
; 258  :       readToken( token );

  00020	ff 75 08	 push	 DWORD PTR _token$[ebp]
  00023	e8 00 00 00 00	 call	 ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
$LN1@skipCommen:
  00028	5f		 pop	 edi

; 259  :    }
; 260  : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ENDP	; Json::Reader::skipCommentTokens
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z$0
__ehfuncinfo$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
_TEXT	SEGMENT
_this$GSCopy$ = -64					; size = 4
_info$ = -60						; size = 44
__$EHRec$ = -12						; size = 12
_message$ = 8						; size = 4
_token$ = 12						; size = 4
_extra$ = 16						; size = 4
?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z PROC ; Json::Reader::addError, COMDAT
; _this$ = ecx

; 763  : {

  00000	6a 34		 push	 52			; 00000034H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 45 08	 mov	 eax, DWORD PTR _message$[ebp]
  0000f	8b 75 0c	 mov	 esi, DWORD PTR _token$[ebp]
  00012	8b 5d 10	 mov	 ebx, DWORD PTR _extra$[ebp]
  00015	89 4d c0	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx

; 764  :    ErrorInfo info;

  00018	33 c9		 xor	 ecx, ecx
  0001a	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR _info$[ebp+32], 15 ; 0000000fH
  00021	89 4d e0	 mov	 DWORD PTR _info$[ebp+28], ecx
  00024	88 4d d0	 mov	 BYTE PTR _info$[ebp+12], cl

; 765  :    info.token_ = token;

  00027	8d 7d c4	 lea	 edi, DWORD PTR _info$[ebp]
  0002a	a5		 movsd

; 766  :    info.message_ = message;

  0002b	6a ff		 push	 -1
  0002d	a5		 movsd
  0002e	51		 push	 ecx
  0002f	89 4d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ecx
  00032	50		 push	 eax
  00033	8d 4d d0	 lea	 ecx, DWORD PTR _info$[ebp+12]
  00036	a5		 movsd
  00037	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 767  :    info.extra_ = extra;
; 768  :    errors_.push_back( info );

  0003c	8b 4d c0	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0003f	8d 45 c4	 lea	 eax, DWORD PTR _info$[ebp]
  00042	50		 push	 eax
  00043	83 c1 18	 add	 ecx, 24			; 00000018H
  00046	89 5d ec	 mov	 DWORD PTR _info$[ebp+40], ebx
  00049	e8 00 00 00 00	 call	 ?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back

; 769  :    return false;

  0004e	6a 00		 push	 0
  00050	6a 01		 push	 1
  00052	8d 4d d0	 lea	 ecx, DWORD PTR _info$[ebp+12]
  00055	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  0005a	32 c0		 xor	 al, al

; 770  : }

  0005c	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00061	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z$0:
  00000	8d 4d c4	 lea	 ecx, DWORD PTR _info$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ErrorInfo@Reader@Json@@QAE@XZ
__ehhandler$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ENDP ; Json::Reader::addError
PUBLIC	??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 1021 : 		{	// destroy the deque

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1022 : 		_Tidy();

  00003	e8 00 00 00 00	 call	 ?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy

; 1023 : 		}

  00008	ff 36		 push	 DWORD PTR [esi]
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 26 00	 and	 DWORD PTR [esi], 0
  00012	59		 pop	 ecx
  00013	5e		 pop	 esi
  00014	c3		 ret	 0
??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
PUBLIC	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
; Function compile flags: /Ogsp
;	COMDAT ?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T47916 = -52						; size = 12
$T47914 = -40						; size = 12
$T47915 = -28						; size = 12
$T48021 = -16						; size = 12
$T47912 = -16						; size = 12
$T47998 = -4						; size = 4
$T47911 = -4						; size = 4
__Cat$48039 = 8						; size = 1
$T47913 = 8						; size = 4
__Newsize$ = 8						; size = 4
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize, COMDAT
; _this$ = ecx

; 1123 : 		{	// determine new length, padding with _Ty() elements as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 1124 : 		if (_Newsize < this->_Mysize)

  0000a	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000d	57		 push	 edi
  0000e	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00011	76 64		 jbe	 SHORT $LN66@resize@2

; 1125 : 			erase(begin() + _Newsize, end());

  00013	8d 45 f0	 lea	 eax, DWORD PTR $T47912[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
  0001c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001f	8b dc		 mov	 ebx, esp
  00021	8b f8		 mov	 edi, eax
  00023	89 65 fc	 mov	 DWORD PTR $T47911[ebp], esp
  00026	57		 push	 edi
  00027	8b cb		 mov	 ecx, ebx
  00029	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0002e	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00031	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  00034	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00037	8d 45 e4	 lea	 eax, DWORD PTR $T47915[ebp]
  0003a	50		 push	 eax
  0003b	8d 45 d8	 lea	 eax, DWORD PTR $T47914[ebp]
  0003e	50		 push	 eax
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
  00046	8b c8		 mov	 ecx, eax
  00048	e8 00 00 00 00	 call	 ??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator+
  0004d	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00050	8b dc		 mov	 ebx, esp
  00052	8b f8		 mov	 edi, eax
  00054	89 65 08	 mov	 DWORD PTR $T47913[ebp], esp
  00057	57		 push	 edi
  00058	8b cb		 mov	 ecx, ebx
  0005a	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0005f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00062	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00065	8d 45 cc	 lea	 eax, DWORD PTR $T47916[ebp]
  00068	50		 push	 eax
  00069	8b ce		 mov	 ecx, esi
  0006b	e8 00 00 00 00	 call	 ?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@0@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase
$LN4@resize@2:

; 1136 : 				}
; 1137 : 			}
; 1138 : 		}

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	c9		 leave
  00074	c2 04 00	 ret	 4
$LN66@resize@2:

; 1126 : 		else if (this->_Mysize < _Newsize)

  00077	73 f7		 jae	 SHORT $LN4@resize@2
  00079	33 db		 xor	 ebx, ebx
$LL5@resize@2:

; 1127 : 			{	// appemd default-constructed elements
; 1128 : 			this->_Orphan_all();
; 1129 : 			while (this->_Mysize < _Newsize)
; 1130 : 				{	// push_back default-constructed element
; 1131 : 				_PUSH_BACK_BEGIN;

  0007b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0007e	40		 inc	 eax
  0007f	39 46 08	 cmp	 DWORD PTR [esi+8], eax
  00082	77 09		 ja	 SHORT $LN3@resize@2
  00084	6a 01		 push	 1
  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 ?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN3@resize@2:
  0008d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00090	03 46 10	 add	 eax, DWORD PTR [esi+16]
  00093	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00096	3b c8		 cmp	 ecx, eax
  00098	77 02		 ja	 SHORT $LN2@resize@2
  0009a	2b c1		 sub	 eax, ecx
$LN2@resize@2:
  0009c	8b f8		 mov	 edi, eax
  0009e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000a1	39 1c b8	 cmp	 DWORD PTR [eax+edi*4], ebx
  000a4	75 12		 jne	 SHORT $LN1@resize@2
  000a6	6a 2c		 push	 44			; 0000002cH
  000a8	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ad	59		 pop	 ecx
  000ae	3b c3		 cmp	 eax, ebx
  000b0	74 2c		 je	 SHORT $LN62@resize@2
  000b2	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b5	89 04 b9	 mov	 DWORD PTR [ecx+edi*4], eax
$LN1@resize@2:

; 1132 : 				_Uninitialized_default_fill_n(
; 1133 : 					this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1134 : 					1, (_Ty *)0, this->_Alval);

  000b8	ff 75 08	 push	 DWORD PTR __Cat$48039[ebp]
  000bb	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  000be	53		 push	 ebx
  000bf	50		 push	 eax
  000c0	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c3	53		 push	 ebx
  000c4	6a 01		 push	 1
  000c6	ff 34 b8	 push	 DWORD PTR [eax+edi*4]
  000c9	e8 00 00 00 00	 call	 ??$_Uninit_def_fill_n@PAVErrorInfo@Reader@Json@@HV123@V?$allocator@VErrorInfo@Reader@Json@@@std@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@HPBV123@AAV?$allocator@VErrorInfo@Reader@Json@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<Json::Reader::ErrorInfo *,int,Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,Json::Reader::ErrorInfo>
  000ce	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000d1	83 c4 18	 add	 esp, 24			; 00000018H

; 1135 : 				_PUSH_BACK_END;

  000d4	ff 46 10	 inc	 DWORD PTR [esi+16]
  000d7	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  000da	72 9f		 jb	 SHORT $LL5@resize@2

; 1127 : 			{	// appemd default-constructed elements
; 1128 : 			this->_Orphan_all();
; 1129 : 			while (this->_Mysize < _Newsize)
; 1130 : 				{	// push_back default-constructed element
; 1131 : 				_PUSH_BACK_BEGIN;

  000dc	eb 92		 jmp	 SHORT $LN4@resize@2
$LN62@resize@2:
  000de	8d 45 fc	 lea	 eax, DWORD PTR $T47998[ebp]
  000e1	50		 push	 eax
  000e2	8d 4d f0	 lea	 ecx, DWORD PTR $T48021[ebp]
  000e5	89 5d fc	 mov	 DWORD PTR $T47998[ebp], ebx
  000e8	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000ed	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000f2	8d 45 f0	 lea	 eax, DWORD PTR $T48021[ebp]
  000f5	50		 push	 eax
  000f6	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T48021[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000fd	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN67@resize@2:
$LN65@resize@2:
  00102	cc		 int	 3
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
_TEXT	ENDS
PUBLIC	?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
; Function compile flags: /Ogsp
;	COMDAT ?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear, COMDAT
; _this$ = ecx

; 1465 : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
_TEXT	ENDS
PUBLIC	??0Reader@Json@@QAE@XZ				; Json::Reader::Reader
;	COMDAT xdata$x
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	SEGMENT
__unwindtable$??0Reader@Json@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@XZ$0
__ehfuncinfo$??0Reader@Json@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Reader@Json@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??0Reader@Json@@QAE@XZ
_TEXT	SEGMENT
$T48088 = -20						; size = 4
$T48069 = -20						; size = 4
$T48078 = -20						; size = 4
$T48091 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Reader@Json@@QAE@XZ PROC				; Json::Reader::Reader, COMDAT
; _this$ = ecx

; 111  : {

  00000	6a 08		 push	 8
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0Reader@Json@@QAE@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	51		 push	 ecx
  00012	89 65 ec	 mov	 DWORD PTR $T48078[ebp], esp
  00015	89 65 ec	 mov	 DWORD PTR $T48069[ebp], esp
  00018	e8 00 00 00 00	 call	 ??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@V?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::_Deque_val<Json::Value *,std::allocator<Json::Value *> >
  0001d	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00020	51		 push	 ecx
  00021	33 db		 xor	 ebx, ebx
  00023	89 65 ec	 mov	 DWORD PTR $T48091[ebp], esp
  00026	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00029	89 65 ec	 mov	 DWORD PTR $T48088[ebp], esp
  0002c	e8 00 00 00 00	 call	 ??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
  00031	6a 0f		 push	 15			; 0000000fH
  00033	58		 pop	 eax
  00034	89 46 44	 mov	 DWORD PTR [esi+68], eax
  00037	89 5e 40	 mov	 DWORD PTR [esi+64], ebx
  0003a	88 5e 30	 mov	 BYTE PTR [esi+48], bl
  0003d	89 46 74	 mov	 DWORD PTR [esi+116], eax
  00040	89 5e 70	 mov	 DWORD PTR [esi+112], ebx
  00043	88 5e 60	 mov	 BYTE PTR [esi+96], bl
  00046	66 c7 46 7c 01
	00		 mov	 WORD PTR [esi+124], 1

; 112  : }

  0004c	8b c6		 mov	 eax, esi
  0004e	e8 00 00 00 00	 call	 __EH_epilog3
  00053	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Reader@Json@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??0Reader@Json@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Reader@Json@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Reader@Json@@QAE@XZ ENDP				; Json::Reader::Reader
PUBLIC	??0Reader@Json@@QAE@ABVFeatures@1@@Z		; Json::Reader::Reader
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??0Reader@Json@@QAE@ABVFeatures@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$0
__ehfuncinfo$??0Reader@Json@@QAE@ABVFeatures@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Reader@Json@@QAE@ABVFeatures@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ??0Reader@Json@@QAE@ABVFeatures@1@@Z
_TEXT	SEGMENT
$T48331 = -20						; size = 4
$T48312 = -20						; size = 4
$T48320 = -20						; size = 4
$T48334 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_features$ = 8						; size = 4
??0Reader@Json@@QAE@ABVFeatures@1@@Z PROC		; Json::Reader::Reader, COMDAT
; _this$ = ecx

; 117  : {

  00000	6a 08		 push	 8
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$??0Reader@Json@@QAE@ABVFeatures@1@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00011	51		 push	 ecx
  00012	89 65 ec	 mov	 DWORD PTR $T48320[ebp], esp
  00015	89 65 ec	 mov	 DWORD PTR $T48312[ebp], esp
  00018	e8 00 00 00 00	 call	 ??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@V?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::_Deque_val<Json::Value *,std::allocator<Json::Value *> >
  0001d	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00020	51		 push	 ecx
  00021	33 db		 xor	 ebx, ebx
  00023	89 65 ec	 mov	 DWORD PTR $T48334[ebp], esp
  00026	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00029	89 65 ec	 mov	 DWORD PTR $T48331[ebp], esp
  0002c	e8 00 00 00 00	 call	 ??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
  00031	89 5e 40	 mov	 DWORD PTR [esi+64], ebx
  00034	6a 0f		 push	 15			; 0000000fH
  00036	58		 pop	 eax
  00037	89 46 44	 mov	 DWORD PTR [esi+68], eax
  0003a	88 5e 30	 mov	 BYTE PTR [esi+48], bl
  0003d	89 46 74	 mov	 DWORD PTR [esi+116], eax
  00040	8b 45 08	 mov	 eax, DWORD PTR _features$[ebp]
  00043	89 5e 70	 mov	 DWORD PTR [esi+112], ebx
  00046	88 5e 60	 mov	 BYTE PTR [esi+96], bl
  00049	66 8b 00	 mov	 ax, WORD PTR [eax]
  0004c	66 89 46 7c	 mov	 WORD PTR [esi+124], ax

; 118  : }

  00050	8b c6		 mov	 eax, esi
  00052	e8 00 00 00 00	 call	 __EH_epilog3
  00057	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??0Reader@Json@@QAE@ABVFeatures@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Reader@Json@@QAE@ABVFeatures@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Reader@Json@@QAE@ABVFeatures@1@@Z ENDP		; Json::Reader::Reader
PUBLIC	?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z ; Json::Reader::expectToken
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z$0
__ehfuncinfo$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
_TEXT	SEGMENT
$T34525 = -44						; size = 28
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 4
_token$ = 12						; size = 4
_message$ = 16						; size = 4
?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z PROC ; Json::Reader::expectToken, COMDAT
; _this$ = ecx

; 265  : {

  00000	6a 20		 push	 32			; 00000020H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _token$[ebp]
  0000f	8b 7d 10	 mov	 edi, DWORD PTR _message$[ebp]

; 266  :    readToken( token );

  00012	56		 push	 esi
  00013	8b d9		 mov	 ebx, ecx
  00015	e8 00 00 00 00	 call	 ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 267  :    if ( token.type_ != type )

  0001a	8b 06		 mov	 eax, DWORD PTR [esi]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR _type$[ebp]
  0001f	74 2c		 je	 SHORT $LN1@expectToke

; 268  :       return addError( message, token );

  00021	57		 push	 edi
  00022	8d 4d d4	 lea	 ecx, DWORD PTR $T34525[ebp]
  00025	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002a	33 ff		 xor	 edi, edi
  0002c	57		 push	 edi
  0002d	56		 push	 esi
  0002e	8d 45 d4	 lea	 eax, DWORD PTR $T34525[ebp]
  00031	50		 push	 eax
  00032	8b cb		 mov	 ecx, ebx
  00034	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00037	e8 00 00 00 00	 call	 ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
  0003c	57		 push	 edi
  0003d	6a 01		 push	 1
  0003f	8d 4d d4	 lea	 ecx, DWORD PTR $T34525[ebp]
  00042	8a d8		 mov	 bl, al
  00044	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00049	8a c3		 mov	 al, bl
  0004b	eb 02		 jmp	 SHORT $LN2@expectToke
$LN1@expectToke:

; 269  :    return true;

  0004d	b0 01		 mov	 al, 1
$LN2@expectToke:

; 270  : }

  0004f	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00054	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T34525[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z ENDP ; Json::Reader::expectToken
PUBLIC	??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@ ; `string'
PUBLIC	??_C@_01GEODFPGF@?8?$AA@			; `string'
PUBLIC	??_C@_03DLDNIBIK@?$CFlf?$AA@			; `string'
PUBLIC	_this$GSCopy$
PUBLIC	__real@0000000000000000
PUBLIC	?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeDouble
EXTRN	??1Value@Json@@QAE@XZ:PROC			; Json::Value::~Value
EXTRN	??4Value@Json@@QAEAAV01@ABV01@@Z:PROC		; Json::Value::operator=
EXTRN	??0Value@Json@@QAE@N@Z:PROC			; Json::Value::Value
EXTRN	_sscanf:PROC
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stack
CONST	SEGMENT
??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@ DB ''' is not a number.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8?$AA@
CONST	SEGMENT
??_C@_01GEODFPGF@?8?$AA@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLDNIBIK@?$CFlf?$AA@
CONST	SEGMENT
??_C@_03DLDNIBIK@?$CFlf?$AA@ DB '%lf', 00H		; `string'
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$4
__ehfuncinfo$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
$T48558 = -136						; size = 16
_value$ = -120						; size = 8
_this$GSCopy$ = -112					; size = 4
$T48557 = -105						; size = 1
$T34905 = -104						; size = 28
$T34906 = -76						; size = 28
_buffer$34902 = -76					; size = 28
_buffer$34899 = -48					; size = 32
$T34904 = -44						; size = 28
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::decodeDouble, COMDAT
; _this$ = ecx

; 621  : {

  00000	6a 7c		 push	 124			; 0000007cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 75 08	 mov	 esi, DWORD PTR _token$[ebp]

; 622  :    double value = 0;

  0000f	d9 ee		 fldz

; 623  :    const int bufferSize = 32;
; 624  :    int count;
; 625  :    int length = int(token.end_ - token.start_);

  00011	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00014	dd 5d 88	 fstp	 QWORD PTR _value$[ebp]
  00017	89 4d 90	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  0001a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0001d	8b f9		 mov	 edi, ecx
  0001f	2b f8		 sub	 edi, eax

; 626  :    if ( length <= bufferSize )

  00021	83 ff 20	 cmp	 edi, 32			; 00000020H
  00024	7f 2a		 jg	 SHORT $LN3@decodeDoub

; 627  :    {
; 628  :       Char buffer[bufferSize];
; 629  :       memcpy( buffer, token.start_, length );

  00026	57		 push	 edi
  00027	50		 push	 eax
  00028	8d 45 d0	 lea	 eax, DWORD PTR _buffer$34899[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _memcpy

; 630  :       buffer[length] = 0;
; 631  :       count = sscanf( buffer, "%lf", &value );

  00031	8d 45 88	 lea	 eax, DWORD PTR _value$[ebp]
  00034	50		 push	 eax
  00035	8d 45 d0	 lea	 eax, DWORD PTR _buffer$34899[ebp]
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_03DLDNIBIK@?$CFlf?$AA@
  0003d	33 db		 xor	 ebx, ebx
  0003f	50		 push	 eax
  00040	88 5c 3d d0	 mov	 BYTE PTR _buffer$34899[ebp+edi], bl
  00044	e8 00 00 00 00	 call	 _sscanf
  00049	83 c4 18	 add	 esp, 24			; 00000018H
  0004c	8b f8		 mov	 edi, eax

; 632  :    }
; 633  :    else

  0004e	eb 37		 jmp	 SHORT $LN17@decodeDoub
$LN3@decodeDoub:

; 634  :    {
; 635  :       std::string buffer( token.start_, token.end_ );

  00050	51		 push	 ecx
  00051	50		 push	 eax
  00052	8d 4d b4	 lea	 ecx, DWORD PTR _buffer$34902[ebp]
  00055	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 636  :       count = sscanf( buffer.c_str(), "%lf", &value );

  0005a	83 7d c8 10	 cmp	 DWORD PTR _buffer$34902[ebp+20], 16 ; 00000010H
  0005e	8b 45 b4	 mov	 eax, DWORD PTR _buffer$34902[ebp]
  00061	73 03		 jae	 SHORT $LN16@decodeDoub
  00063	8d 45 b4	 lea	 eax, DWORD PTR _buffer$34902[ebp]
$LN16@decodeDoub:
  00066	8d 4d 88	 lea	 ecx, DWORD PTR _value$[ebp]
  00069	51		 push	 ecx
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_03DLDNIBIK@?$CFlf?$AA@
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _sscanf
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 637  :    }

  00078	33 db		 xor	 ebx, ebx
  0007a	53		 push	 ebx
  0007b	6a 01		 push	 1
  0007d	8d 4d b4	 lea	 ecx, DWORD PTR _buffer$34902[ebp]
  00080	8b f8		 mov	 edi, eax
  00082	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
$LN17@decodeDoub:

; 638  : 
; 639  :    if ( count != 1 )

  00087	83 ff 01	 cmp	 edi, 1
  0008a	74 6e		 je	 SHORT $LN1@decodeDoub

; 640  :       return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

  0008c	ff 76 08	 push	 DWORD PTR [esi+8]
  0008f	8d 4d d4	 lea	 ecx, DWORD PTR $T34904[ebp]
  00092	ff 76 04	 push	 DWORD PTR [esi+4]
  00095	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0009a	50		 push	 eax
  0009b	8d 45 98	 lea	 eax, DWORD PTR $T34905[ebp]
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_01GEODFPGF@?8?$AA@
  000a3	50		 push	 eax
  000a4	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  000a7	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
  000b1	50		 push	 eax
  000b2	8d 45 b4	 lea	 eax, DWORD PTR $T34906[ebp]
  000b5	50		 push	 eax
  000b6	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000ba	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000bf	83 c4 18	 add	 esp, 24			; 00000018H
  000c2	8b 4d 90	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  000c5	53		 push	 ebx
  000c6	56		 push	 esi
  000c7	50		 push	 eax
  000c8	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000cc	e8 00 00 00 00	 call	 ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
  000d1	53		 push	 ebx
  000d2	6a 01		 push	 1
  000d4	8d 4d b4	 lea	 ecx, DWORD PTR $T34906[ebp]
  000d7	88 45 97	 mov	 BYTE PTR $T48557[ebp], al
  000da	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  000df	53		 push	 ebx
  000e0	6a 01		 push	 1
  000e2	8d 4d 98	 lea	 ecx, DWORD PTR $T34905[ebp]
  000e5	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  000ea	53		 push	 ebx
  000eb	6a 01		 push	 1
  000ed	8d 4d d4	 lea	 ecx, DWORD PTR $T34904[ebp]
  000f0	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  000f5	8a 45 97	 mov	 al, BYTE PTR $T48557[ebp]
  000f8	eb 43		 jmp	 SHORT $LN4@decodeDoub
$LN1@decodeDoub:

; 641  :    currentValue() = value;

  000fa	dd 45 88	 fld	 QWORD PTR _value$[ebp]
  000fd	51		 push	 ecx
  000fe	51		 push	 ecx
  000ff	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T48558[ebp]
  00105	dd 1c 24	 fstp	 QWORD PTR [esp]
  00108	e8 00 00 00 00	 call	 ??0Value@Json@@QAE@N@Z	; Json::Value::Value
  0010d	8b 4d 90	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00110	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00117	e8 00 00 00 00	 call	 ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
  0011c	8b 00		 mov	 eax, DWORD PTR [eax]
  0011e	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T48558[ebp]
  00124	51		 push	 ecx
  00125	8b c8		 mov	 ecx, eax
  00127	e8 00 00 00 00	 call	 ??4Value@Json@@QAEAAV01@ABV01@@Z ; Json::Value::operator=
  0012c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00130	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T48558[ebp]
  00136	e8 00 00 00 00	 call	 ??1Value@Json@@QAE@XZ	; Json::Value::~Value

; 642  :    return true;

  0013b	b0 01		 mov	 al, 1
$LN4@decodeDoub:

; 643  : }

  0013d	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00142	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$1:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T34904[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$2:
  00008	8d 4d 98	 lea	 ecx, DWORD PTR $T34905[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$3:
  00010	8d 4d b4	 lea	 ecx, DWORD PTR $T34906[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$4:
  00018	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T48558[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1Value@Json@@QAE@XZ	; Json::Value::~Value
__ehhandler$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z:
  00023	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00027	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002a	8b 8a 74 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-140]
  00030	33 c8		 xor	 ecx, eax
  00032	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00037	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0003a	33 c8		 xor	 ecx, eax
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
  00046	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeDouble
PUBLIC	??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@ ; `string'
PUBLIC	??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@ ; `string'
PUBLIC	_this$GSCopy$
PUBLIC	?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
;	COMDAT ??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
CONST	SEGMENT
??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@ DB 'Bad unicode'
	DB	' escape sequence in string: hexadecimal digit expected.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT
??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@ DB 'Bad unicode'
	DB	' escape sequence in string: four digits expected.', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1
__ehfuncinfo$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
_TEXT	SEGMENT
_this$GSCopy$ = -84					; size = 4
_index$34990 = -80					; size = 4
$T48634 = -73						; size = 1
$T34987 = -72						; size = 28
$T35001 = -44						; size = 28
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
_current$ = 12						; size = 4
_end$ = 16						; size = 4
_unicode$ = 20						; size = 4
?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z PROC ; Json::Reader::decodeUnicodeEscapeSequence, COMDAT
; _this$ = ecx

; 738  : {

  00000	6a 48		 push	 72			; 00000048H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _current$[ebp]
  0000f	8b 7d 08	 mov	 edi, DWORD PTR _token$[ebp]
  00012	8b 45 14	 mov	 eax, DWORD PTR _unicode$[ebp]
  00015	89 4d ac	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx

; 739  :    if ( end - current < 4 )

  00018	8b 4d 10	 mov	 ecx, DWORD PTR _end$[ebp]
  0001b	2b 0e		 sub	 ecx, DWORD PTR [esi]
  0001d	83 f9 04	 cmp	 ecx, 4
  00020	7d 32		 jge	 SHORT $LN10@decodeUnic

; 740  :       return addError( "Bad unicode escape sequence in string: four digits expected.", token, current );

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
  00027	8d 4d b8	 lea	 ecx, DWORD PTR $T34987[ebp]
  0002a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002f	ff 36		 push	 DWORD PTR [esi]
  00031	8b 4d ac	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00034	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00038	57		 push	 edi
  00039	8d 45 b8	 lea	 eax, DWORD PTR $T34987[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
  00042	6a 00		 push	 0
  00044	6a 01		 push	 1
  00046	8d 4d b8	 lea	 ecx, DWORD PTR $T34987[ebp]
  00049	8a d8		 mov	 bl, al
  0004b	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00050	8a c3		 mov	 al, bl
  00052	eb 53		 jmp	 SHORT $LN11@decodeUnic
$LN10@decodeUnic:

; 741  :    unicode = 0;

  00054	83 20 00	 and	 DWORD PTR [eax], 0

; 742  :    for ( int index =0; index < 4; ++index )

  00057	83 65 b0 00	 and	 DWORD PTR _index$34990[ebp], 0
$LL9@decodeUnic:

; 743  :    {
; 744  :       Char c = *current++;

  0005b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005d	8a 11		 mov	 dl, BYTE PTR [ecx]
  0005f	41		 inc	 ecx
  00060	89 0e		 mov	 DWORD PTR [esi], ecx

; 745  :       unicode *= 16;

  00062	8b 08		 mov	 ecx, DWORD PTR [eax]
  00064	c1 e1 04	 shl	 ecx, 4
  00067	89 08		 mov	 DWORD PTR [eax], ecx

; 746  :       if ( c >= '0'  &&  c <= '9' )

  00069	8d 5a d0	 lea	 ebx, DWORD PTR [edx-48]
  0006c	80 fb 09	 cmp	 bl, 9
  0006f	77 09		 ja	 SHORT $LN6@decodeUnic

; 747  :          unicode += c - '0';

  00071	0f be d2	 movsx	 edx, dl
  00074	8d 4c 0a d0	 lea	 ecx, DWORD PTR [edx+ecx-48]
  00078	eb 20		 jmp	 SHORT $LN26@decodeUnic
$LN6@decodeUnic:

; 748  :       else if ( c >= 'a'  &&  c <= 'f' )

  0007a	8d 5a 9f	 lea	 ebx, DWORD PTR [edx-97]
  0007d	80 fb 05	 cmp	 bl, 5
  00080	77 09		 ja	 SHORT $LN4@decodeUnic

; 749  :          unicode += c - 'a' + 10;

  00082	0f be d2	 movsx	 edx, dl
  00085	8d 4c 0a a9	 lea	 ecx, DWORD PTR [edx+ecx-87]
  00089	eb 0f		 jmp	 SHORT $LN26@decodeUnic
$LN4@decodeUnic:

; 750  :       else if ( c >= 'A'  &&  c <= 'F' )

  0008b	8d 5a bf	 lea	 ebx, DWORD PTR [edx-65]
  0008e	80 fb 05	 cmp	 bl, 5
  00091	77 1c		 ja	 SHORT $LN2@decodeUnic

; 751  :          unicode += c - 'A' + 10;

  00093	0f be d2	 movsx	 edx, dl
  00096	8d 4c 0a c9	 lea	 ecx, DWORD PTR [edx+ecx-55]
$LN26@decodeUnic:

; 742  :    for ( int index =0; index < 4; ++index )

  0009a	ff 45 b0	 inc	 DWORD PTR _index$34990[ebp]
  0009d	83 7d b0 04	 cmp	 DWORD PTR _index$34990[ebp], 4

; 751  :          unicode += c - 'A' + 10;

  000a1	89 08		 mov	 DWORD PTR [eax], ecx
  000a3	7c b6		 jl	 SHORT $LL9@decodeUnic

; 754  :    }
; 755  :    return true;

  000a5	b0 01		 mov	 al, 1
$LN11@decodeUnic:

; 756  : }

  000a7	e8 00 00 00 00	 call	 __EH_epilog3_GS
  000ac	c2 10 00	 ret	 16			; 00000010H
$LN2@decodeUnic:

; 752  :       else
; 753  :          return addError( "Bad unicode escape sequence in string: hexadecimal digit expected.", token, current );

  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
  000b4	8d 4d d4	 lea	 ecx, DWORD PTR $T35001[ebp]
  000b7	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000bc	ff 36		 push	 DWORD PTR [esi]
  000be	8b 4d ac	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  000c1	33 db		 xor	 ebx, ebx
  000c3	57		 push	 edi
  000c4	8d 45 d4	 lea	 eax, DWORD PTR $T35001[ebp]
  000c7	43		 inc	 ebx
  000c8	50		 push	 eax
  000c9	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  000cc	e8 00 00 00 00	 call	 ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
  000d1	6a 00		 push	 0
  000d3	53		 push	 ebx
  000d4	8d 4d d4	 lea	 ecx, DWORD PTR $T35001[ebp]
  000d7	88 45 b7	 mov	 BYTE PTR $T48634[ebp], al
  000da	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  000df	8a 45 b7	 mov	 al, BYTE PTR $T48634[ebp]
  000e2	eb c3		 jmp	 SHORT $LN11@decodeUnic
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0:
  00000	8d 4d b8	 lea	 ecx, DWORD PTR $T34987[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR $T35001[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ENDP ; Json::Reader::decodeUnicodeEscapeSequence
PUBLIC	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
; Function compile flags: /Ogsp
;	COMDAT ?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z
_TEXT	SEGMENT
_skip$ = -12						; size = 12
_skipUntilToken$ = 8					; size = 4
?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z PROC ; Json::Reader::recoverFromError, COMDAT
; _this$ = ecx

; 775  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi

; 776  :    int errorCount = int(errors_.size());

  0000a	8b 7e 28	 mov	 edi, DWORD PTR [esi+40]
$LL5@recoverFro:

; 777  :    Token skip;
; 778  :    while ( true )
; 779  :    {
; 780  :       if ( !readToken(skip) )

  0000d	8d 45 f4	 lea	 eax, DWORD PTR _skip$[ebp]
  00010	50		 push	 eax
  00011	8b ce		 mov	 ecx, esi
  00013	e8 00 00 00 00	 call	 ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
  00018	84 c0		 test	 al, al
  0001a	75 09		 jne	 SHORT $LN3@recoverFro

; 781  :          errors_.resize( errorCount ); // discard errors caused by recovery

  0001c	57		 push	 edi
  0001d	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00020	e8 00 00 00 00	 call	 ?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
$LN3@recoverFro:

; 782  :       if ( skip.type_ == skipUntilToken  ||  skip.type_ == tokenEndOfStream )

  00025	8b 45 f4	 mov	 eax, DWORD PTR _skip$[ebp]
  00028	3b 45 08	 cmp	 eax, DWORD PTR _skipUntilToken$[ebp]
  0002b	74 04		 je	 SHORT $LN11@recoverFro
  0002d	85 c0		 test	 eax, eax
  0002f	75 dc		 jne	 SHORT $LL5@recoverFro
$LN11@recoverFro:

; 783  :          break;
; 784  :    }
; 785  :    errors_.resize( errorCount );

  00031	57		 push	 edi
  00032	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00035	e8 00 00 00 00	 call	 ?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
  0003a	5f		 pop	 edi

; 786  :    return false;

  0003b	32 c0		 xor	 al, al
  0003d	5e		 pop	 esi

; 787  : }

  0003e	c9		 leave
  0003f	c2 04 00	 ret	 4
?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ENDP ; Json::Reader::recoverFromError
_TEXT	ENDS
PUBLIC	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
; Function compile flags: /Ogsp
;	COMDAT ?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z
_TEXT	SEGMENT
_message$ = 8						; size = 4
_token$ = 12						; size = 4
_skipUntilToken$ = 16					; size = 4
?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z PROC ; Json::Reader::addErrorAndRecover, COMDAT
; _this$ = ecx

; 794  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 795  :    addError( message, token );

  00004	6a 00		 push	 0
  00006	ff 75 0c	 push	 DWORD PTR _token$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	ff 75 08	 push	 DWORD PTR _message$[ebp]
  0000e	e8 00 00 00 00	 call	 ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError

; 796  :    return recoverFromError( skipUntilToken );

  00013	ff 75 10	 push	 DWORD PTR _skipUntilToken$[ebp]
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
  0001d	5e		 pop	 esi

; 797  : }

  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ENDP ; Json::Reader::addErrorAndRecover
_TEXT	ENDS
PUBLIC	??1Reader@Json@@QAE@XZ				; Json::Reader::~Reader
; Function compile flags: /Ogsp
;	COMDAT ??1Reader@Json@@QAE@XZ
_TEXT	SEGMENT
??1Reader@Json@@QAE@XZ PROC				; Json::Reader::~Reader, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx
  00004	6a 00		 push	 0
  00006	6a 01		 push	 1
  00008	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  0000b	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00010	6a 00		 push	 0
  00012	6a 01		 push	 1
  00014	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  00017	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  0001c	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  0001f	e8 00 00 00 00	 call	 ?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
  00024	ff 76 18	 push	 DWORD PTR [esi+24]
  00027	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002c	83 66 18 00	 and	 DWORD PTR [esi+24], 0
  00030	59		 pop	 ecx
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
  00038	ff 36		 push	 DWORD PTR [esi]
  0003a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003f	83 26 00	 and	 DWORD PTR [esi], 0
  00042	59		 pop	 ecx
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	c3		 ret	 0
??1Reader@Json@@QAE@XZ ENDP				; Json::Reader::~Reader
_TEXT	ENDS
PUBLIC	??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@ ; `string'
PUBLIC	?readValue@Reader@Json@@AAE_NXZ			; Json::Reader::readValue
PUBLIC	?readArray@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readArray
EXTRN	??AValue@Json@@QAEAAV01@I@Z:PROC		; Json::Value::operator[]
EXTRN	??0Value@Json@@QAE@W4ValueType@1@@Z:PROC	; Json::Value::Value
;	COMDAT ??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
CONST	SEGMENT
??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@ DB 'Mi'
	DB	'ssing '','' or '']'' in array declaration', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$1
__ehfuncinfo$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
_value$34789 = -64					; size = 4
$T48877 = -60						; size = 16
_token$34792 = -56					; size = 12
_endArray$34784 = -56					; size = 12
$T34799 = -44						; size = 28
__$EHRec$ = -12						; size = 12
_tokenStart$ = 8					; size = 4
?readArray@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::readArray, COMDAT
; _this$ = ecx

; 540  : {

  00000	6a 34		 push	 52			; 00000034H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b f1		 mov	 esi, ecx

; 541  :    currentValue() = Value( arrayValue );

  0000e	6a 06		 push	 6
  00010	8d 4d c4	 lea	 ecx, DWORD PTR $T48877[ebp]
  00013	e8 00 00 00 00	 call	 ??0Value@Json@@QAE@W4ValueType@1@@Z ; Json::Value::Value
  00018	8b f8		 mov	 edi, eax
  0001a	33 db		 xor	 ebx, ebx
  0001c	8b ce		 mov	 ecx, esi
  0001e	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00021	e8 00 00 00 00	 call	 ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	57		 push	 edi
  00029	e8 00 00 00 00	 call	 ??4Value@Json@@QAEAAV01@ABV01@@Z ; Json::Value::operator=
  0002e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00032	8d 4d c4	 lea	 ecx, DWORD PTR $T48877[ebp]
  00035	e8 00 00 00 00	 call	 ??1Value@Json@@QAE@XZ	; Json::Value::~Value

; 542  :    skipSpaces();

  0003a	8b ce		 mov	 ecx, esi
  0003c	e8 00 00 00 00	 call	 ?skipSpaces@Reader@Json@@AAEXXZ ; Json::Reader::skipSpaces

; 543  :    if ( *current_ == ']' ) // empty array

  00041	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00044	80 38 5d	 cmp	 BYTE PTR [eax], 93	; 0000005dH
  00047	75 10		 jne	 SHORT $LN9@readArray

; 544  :    {
; 545  :       Token endArray;
; 546  :       readToken( endArray );

  00049	8d 45 c8	 lea	 eax, DWORD PTR _endArray$34784[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
$LN53@readArray:

; 547  :       return true;

  00052	b0 01		 mov	 al, 1
  00054	e9 a4 00 00 00	 jmp	 $LN10@readArray
$LN9@readArray:

; 548  :    }
; 549  :    int index = 0;

  00059	33 ff		 xor	 edi, edi
$LL8@readArray:

; 550  :    while ( true )
; 551  :    {
; 552  :       Value &value = currentValue()[ index++ ];

  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
  00062	8b 08		 mov	 ecx, DWORD PTR [eax]
  00064	57		 push	 edi
  00065	e8 00 00 00 00	 call	 ??AValue@Json@@QAEAAV01@I@Z ; Json::Value::operator[]
  0006a	89 45 c0	 mov	 DWORD PTR _value$34789[ebp], eax

; 553  :       nodes_.push( &value );

  0006d	8d 45 c0	 lea	 eax, DWORD PTR _value$34789[ebp]
  00070	50		 push	 eax
  00071	8b ce		 mov	 ecx, esi
  00073	47		 inc	 edi
  00074	e8 00 00 00 00	 call	 ?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back

; 554  :       bool ok = readValue();

  00079	8b ce		 mov	 ecx, esi
  0007b	e8 00 00 00 00	 call	 ?readValue@Reader@Json@@AAE_NXZ ; Json::Reader::readValue

; 555  :       nodes_.pop();

  00080	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00083	3b cb		 cmp	 ecx, ebx
  00085	74 0b		 je	 SHORT $LN30@readArray
  00087	49		 dec	 ecx
  00088	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0008b	3b cb		 cmp	 ecx, ebx
  0008d	75 03		 jne	 SHORT $LN30@readArray
  0008f	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
$LN30@readArray:

; 558  : 
; 559  :       Token token;
; 560  :       // Accept Comment after last item in the array.
; 561  :       ok = readToken( token );

  00092	8b ce		 mov	 ecx, esi
  00094	84 c0		 test	 al, al
  00096	75 0f		 jne	 SHORT $LN57@readArray

; 556  :       if ( !ok ) // error already set
; 557  :          return recoverFromError( tokenArrayEnd );

  00098	6a 04		 push	 4
  0009a	e8 00 00 00 00	 call	 ?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
  0009f	eb 5c		 jmp	 SHORT $LN10@readArray
$LL5@readArray:

; 562  :       while ( token.type_ == tokenComment  &&  ok )

  000a1	84 c0		 test	 al, al
  000a3	74 1d		 je	 SHORT $LN2@readArray

; 563  :       {
; 564  :          ok = readToken( token );

  000a5	8b ce		 mov	 ecx, esi
$LN57@readArray:
  000a7	8d 45 c8	 lea	 eax, DWORD PTR _token$34792[ebp]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
  000b0	83 7d c8 0c	 cmp	 DWORD PTR _token$34792[ebp], 12 ; 0000000cH
  000b4	74 eb		 je	 SHORT $LL5@readArray

; 565  :       }
; 566  :       bool badTokenType = ( token.type_ == tokenArraySeparator  &&  
; 567  :                             token.type_ == tokenArrayEnd );
; 568  :       if ( !ok  ||  badTokenType )

  000b6	84 c0		 test	 al, al
  000b8	74 08		 je	 SHORT $LN2@readArray

; 573  :       }
; 574  :       if ( token.type_ == tokenArrayEnd )

  000ba	83 7d c8 04	 cmp	 DWORD PTR _token$34792[ebp], 4
  000be	75 9b		 jne	 SHORT $LL8@readArray

; 575  :          break;
; 576  :    }

  000c0	eb 90		 jmp	 SHORT $LN53@readArray
$LN2@readArray:

; 569  :       {
; 570  :          return addErrorAndRecover( "Missing ',' or ']' in array declaration", 
; 571  :                                     token, 
; 572  :                                     tokenArrayEnd );

  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
  000c7	8d 4d d4	 lea	 ecx, DWORD PTR $T34799[ebp]
  000ca	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000cf	53		 push	 ebx
  000d0	8d 45 c8	 lea	 eax, DWORD PTR _token$34792[ebp]
  000d3	50		 push	 eax
  000d4	33 ff		 xor	 edi, edi
  000d6	8d 45 d4	 lea	 eax, DWORD PTR $T34799[ebp]
  000d9	47		 inc	 edi
  000da	50		 push	 eax
  000db	8b ce		 mov	 ecx, esi
  000dd	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  000e0	e8 00 00 00 00	 call	 ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
  000e5	6a 04		 push	 4
  000e7	8b ce		 mov	 ecx, esi
  000e9	e8 00 00 00 00	 call	 ?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
  000ee	6a 00		 push	 0
  000f0	57		 push	 edi
  000f1	8d 4d d4	 lea	 ecx, DWORD PTR $T34799[ebp]
  000f4	8a d8		 mov	 bl, al
  000f6	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  000fb	8a c3		 mov	 al, bl
$LN10@readArray:

; 577  :    return true;
; 578  : }

  000fd	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00102	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$0:
  00000	8d 4d c4	 lea	 ecx, DWORD PTR $T48877[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Value@Json@@QAE@XZ	; Json::Value::~Value
__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$1:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR $T34799[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?readArray@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readArray
PUBLIC	_this$GSCopy$
PUBLIC	?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeNumber
EXTRN	??0Value@Json@@QAE@I@Z:PROC			; Json::Value::Value
EXTRN	?maxInt@Value@Json@@2HB:DWORD			; Json::Value::maxInt
EXTRN	??0Value@Json@@QAE@H@Z:PROC			; Json::Value::Value
EXTRN	?maxUInt@Value@Json@@2IB:DWORD			; Json::Value::maxUInt
EXTRN	?minInt@Value@Json@@2HB:DWORD			; Json::Value::minInt
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stack
xdata$x	SEGMENT
__ehfuncinfo$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$5
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
$T48998 = -124						; size = 16
_this$GSCopy$ = -108					; size = 4
_isNegative$ = -101					; size = 1
$T34824 = -100						; size = 28
$T34851 = -72						; size = 28
$T34878 = -44						; size = 28
$T48997 = -32						; size = 16
$T48996 = -32						; size = 16
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::decodeNumber, COMDAT
; _this$ = ecx

; 583  : {

  00000	6a 70		 push	 112			; 00000070H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 75 08	 mov	 esi, DWORD PTR _token$[ebp]

; 584  :    bool isDouble = false;
; 585  :    for ( Location inspect = token.start_; inspect != token.end_; ++inspect )

  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00015	89 4d 94	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00018	32 c9		 xor	 cl, cl
  0001a	3b c3		 cmp	 eax, ebx
  0001c	74 41		 je	 SHORT $LN11@decodeNumb
$LL14@decodeNumb:

; 586  :    {
; 587  :       isDouble = isDouble  
; 588  :                  ||  in( *inspect, '.', 'e', 'E', '+' )  
; 589  :                  ||  ( *inspect == '-'  &&  inspect != token.start_ );

  0001e	84 c9		 test	 cl, cl
  00020	75 24		 jne	 SHORT $LN17@decodeNumb
  00022	8a 08		 mov	 cl, BYTE PTR [eax]
  00024	80 f9 2e	 cmp	 cl, 46			; 0000002eH
  00027	74 1d		 je	 SHORT $LN17@decodeNumb
  00029	80 f9 65	 cmp	 cl, 101			; 00000065H
  0002c	74 18		 je	 SHORT $LN17@decodeNumb
  0002e	80 f9 45	 cmp	 cl, 69			; 00000045H
  00031	74 13		 je	 SHORT $LN17@decodeNumb
  00033	80 f9 2b	 cmp	 cl, 43			; 0000002bH
  00036	74 0e		 je	 SHORT $LN17@decodeNumb
  00038	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  0003b	75 05		 jne	 SHORT $LN18@decodeNumb
  0003d	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00040	75 04		 jne	 SHORT $LN17@decodeNumb
$LN18@decodeNumb:
  00042	32 c9		 xor	 cl, cl
  00044	eb 02		 jmp	 SHORT $LN19@decodeNumb
$LN17@decodeNumb:
  00046	b1 01		 mov	 cl, 1
$LN19@decodeNumb:

; 584  :    bool isDouble = false;
; 585  :    for ( Location inspect = token.start_; inspect != token.end_; ++inspect )

  00048	40		 inc	 eax
  00049	3b c3		 cmp	 eax, ebx
  0004b	75 d1		 jne	 SHORT $LL14@decodeNumb

; 590  :    }
; 591  :    if ( isDouble )

  0004d	84 c9		 test	 cl, cl
  0004f	74 0e		 je	 SHORT $LN11@decodeNumb
$LN59@decodeNumb:

; 592  :       return decodeDouble( token );

  00051	8b 4d 94	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00054	56		 push	 esi
  00055	e8 00 00 00 00	 call	 ?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeDouble
  0005a	e9 3d 01 00 00	 jmp	 $LN15@decodeNumb
$LN11@decodeNumb:

; 593  :    Location current = token.start_;

  0005f	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 594  :    bool isNegative = *current == '-';

  00062	80 3f 2d	 cmp	 BYTE PTR [edi], 45	; 0000002dH
  00065	0f 94 45 9b	 sete	 BYTE PTR _isNegative$[ebp]

; 595  :    if ( isNegative )

  00069	80 7d 9b 00	 cmp	 BYTE PTR _isNegative$[ebp], 0
  0006d	74 0a		 je	 SHORT $LN20@decodeNumb

; 596  :       ++current;
; 597  :    Value::UInt threshold = (isNegative ? Value::UInt(-Value::minInt) 
; 598  :                                        : Value::maxUInt) / 10;

  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?minInt@Value@Json@@2HB ; Json::Value::minInt
  00074	47		 inc	 edi
  00075	f7 d8		 neg	 eax
  00077	eb 05		 jmp	 SHORT $LN21@decodeNumb
$LN20@decodeNumb:
  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR ?maxUInt@Value@Json@@2IB ; Json::Value::maxUInt
$LN21@decodeNumb:
  0007e	6a 0a		 push	 10			; 0000000aH
  00080	33 d2		 xor	 edx, edx
  00082	59		 pop	 ecx
  00083	f7 f1		 div	 ecx

; 599  :    Value::UInt value = 0;

  00085	33 c9		 xor	 ecx, ecx
  00087	eb 1b		 jmp	 SHORT $LN64@decodeNumb
$LL9@decodeNumb:

; 601  :    {
; 602  :       Char c = *current++;

  00089	8a 17		 mov	 dl, BYTE PTR [edi]
  0008b	47		 inc	 edi

; 603  :       if ( c < '0'  ||  c > '9' )

  0008c	80 fa 30	 cmp	 dl, 48			; 00000030H
  0008f	7c 50		 jl	 SHORT $LN6@decodeNumb
  00091	80 fa 39	 cmp	 dl, 57			; 00000039H
  00094	7f 4b		 jg	 SHORT $LN6@decodeNumb

; 605  :       if ( value >= threshold )

  00096	3b c8		 cmp	 ecx, eax
  00098	73 b7		 jae	 SHORT $LN59@decodeNumb

; 606  :          return decodeDouble( token );
; 607  :       value = value * 10 + Value::UInt(c - '0');

  0009a	6b c9 0a	 imul	 ecx, 10			; 0000000aH
  0009d	0f be d2	 movsx	 edx, dl
  000a0	8d 4c 11 d0	 lea	 ecx, DWORD PTR [ecx+edx-48]
$LN64@decodeNumb:

; 600  :    while ( current < token.end_ )

  000a4	3b fb		 cmp	 edi, ebx
  000a6	72 e1		 jb	 SHORT $LL9@decodeNumb

; 608  :    }
; 609  :    if ( isNegative )

  000a8	80 7d 9b 00	 cmp	 BYTE PTR _isNegative$[ebp], 0
  000ac	0f 84 9b 00 00
	00		 je	 $LN4@decodeNumb

; 610  :       currentValue() = -Value::Int( value );

  000b2	f7 d9		 neg	 ecx
  000b4	51		 push	 ecx
  000b5	8d 4d e0	 lea	 ecx, DWORD PTR $T48996[ebp]
  000b8	e8 00 00 00 00	 call	 ??0Value@Json@@QAE@H@Z	; Json::Value::Value
  000bd	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
$LN66@decodeNumb:
  000c4	8b 4d 94	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  000c7	e8 00 00 00 00	 call	 ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
  000cc	8b 00		 mov	 eax, DWORD PTR [eax]
  000ce	8d 4d e0	 lea	 ecx, DWORD PTR $T48996[ebp]
  000d1	51		 push	 ecx
  000d2	8b c8		 mov	 ecx, eax
  000d4	e8 00 00 00 00	 call	 ??4Value@Json@@QAEAAV01@ABV01@@Z ; Json::Value::operator=
  000d9	8d 4d e0	 lea	 ecx, DWORD PTR $T48996[ebp]
  000dc	e9 b0 00 00 00	 jmp	 $LN65@decodeNumb
$LN6@decodeNumb:

; 604  :          return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

  000e1	53		 push	 ebx
  000e2	ff 76 04	 push	 DWORD PTR [esi+4]
  000e5	8d 4d 9c	 lea	 ecx, DWORD PTR $T34824[ebp]
  000e8	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000ed	50		 push	 eax
  000ee	8d 45 b8	 lea	 eax, DWORD PTR $T34851[ebp]
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_01GEODFPGF@?8?$AA@
  000f6	33 ff		 xor	 edi, edi
  000f8	50		 push	 eax
  000f9	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  000fc	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00101	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
  00106	50		 push	 eax
  00107	8d 45 d4	 lea	 eax, DWORD PTR $T34878[ebp]
  0010a	50		 push	 eax
  0010b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0010f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00114	83 c4 18	 add	 esp, 24			; 00000018H
  00117	8b 4d 94	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0011a	57		 push	 edi
  0011b	56		 push	 esi
  0011c	50		 push	 eax
  0011d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00121	e8 00 00 00 00	 call	 ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
  00126	57		 push	 edi
  00127	6a 01		 push	 1
  00129	8d 4d d4	 lea	 ecx, DWORD PTR $T34878[ebp]
  0012c	8a d8		 mov	 bl, al
  0012e	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00133	57		 push	 edi
  00134	6a 01		 push	 1
  00136	8d 4d b8	 lea	 ecx, DWORD PTR $T34851[ebp]
  00139	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  0013e	57		 push	 edi
  0013f	6a 01		 push	 1
  00141	8d 4d 9c	 lea	 ecx, DWORD PTR $T34824[ebp]
  00144	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00149	8a c3		 mov	 al, bl
  0014b	eb 4f		 jmp	 SHORT $LN15@decodeNumb
$LN4@decodeNumb:

; 611  :    else if ( value <= Value::UInt(Value::maxInt) )
; 612  :       currentValue() = Value::Int( value );

  0014d	51		 push	 ecx
  0014e	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?maxInt@Value@Json@@2HB ; Json::Value::maxInt
  00154	77 14		 ja	 SHORT $LN2@decodeNumb
  00156	8d 4d e0	 lea	 ecx, DWORD PTR $T48997[ebp]
  00159	e8 00 00 00 00	 call	 ??0Value@Json@@QAE@H@Z	; Json::Value::Value
  0015e	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4

; 613  :    else

  00165	e9 5a ff ff ff	 jmp	 $LN66@decodeNumb
$LN2@decodeNumb:

; 614  :       currentValue() = value;

  0016a	8d 4d 84	 lea	 ecx, DWORD PTR $T48998[ebp]
  0016d	e8 00 00 00 00	 call	 ??0Value@Json@@QAE@I@Z	; Json::Value::Value
  00172	8b 4d 94	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00175	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  0017c	e8 00 00 00 00	 call	 ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
  00181	8b 00		 mov	 eax, DWORD PTR [eax]
  00183	8d 4d 84	 lea	 ecx, DWORD PTR $T48998[ebp]
  00186	51		 push	 ecx
  00187	8b c8		 mov	 ecx, eax
  00189	e8 00 00 00 00	 call	 ??4Value@Json@@QAEAAV01@ABV01@@Z ; Json::Value::operator=
  0018e	8d 4d 84	 lea	 ecx, DWORD PTR $T48998[ebp]
$LN65@decodeNumb:
  00191	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00195	e8 00 00 00 00	 call	 ??1Value@Json@@QAE@XZ	; Json::Value::~Value

; 615  :    return true;

  0019a	b0 01		 mov	 al, 1
$LN15@decodeNumb:

; 616  : }

  0019c	e8 00 00 00 00	 call	 __EH_epilog3_GS
  001a1	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$3:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR $T48996[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Value@Json@@QAE@XZ	; Json::Value::~Value
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$0:
  00008	8d 4d 9c	 lea	 ecx, DWORD PTR $T34824[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$1:
  00010	8d 4d b8	 lea	 ecx, DWORD PTR $T34851[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$2:
  00018	8d 4d d4	 lea	 ecx, DWORD PTR $T34878[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$4:
  00020	8d 4d e0	 lea	 ecx, DWORD PTR $T48997[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1Value@Json@@QAE@XZ	; Json::Value::~Value
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$5:
  00028	8d 4d 84	 lea	 ecx, DWORD PTR $T48998[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1Value@Json@@QAE@XZ	; Json::Value::~Value
__ehhandler$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z:
  00030	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00034	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00037	8b 4a 80	 mov	 ecx, DWORD PTR [edx-128]
  0003a	33 c8		 xor	 ecx, eax
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00044	33 c8		 xor	 ecx, eax
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
  00050	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeNumber
PUBLIC	??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@ ; `string'
PUBLIC	??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@ ; `string'
PUBLIC	_this$GSCopy$
PUBLIC	?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeCodePoint
;	COMDAT ??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
CONST	SEGMENT
??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@ DB 'expecting '
	DB	'another \u token to begin the second half of a unicode surrog'
	DB	'ate pair', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@
CONST	SEGMENT
??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@ DB 'additional si'
	DB	'x characters expected to parse unicode surrogate pair.', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1
__ehfuncinfo$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
_TEXT	SEGMENT
_this$GSCopy$ = -76					; size = 4
_surrogatePair$34971 = -76				; size = 4
$T34976 = -72						; size = 28
$T34968 = -44						; size = 28
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
_current$ = 12						; size = 4
_end$ = 16						; size = 4
_unicode$ = 20						; size = 4
?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z PROC ; Json::Reader::decodeUnicodeCodePoint, COMDAT
; _this$ = ecx

; 708  : {

  00000	6a 40		 push	 64			; 00000040H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 7d 14	 mov	 edi, DWORD PTR _unicode$[ebp]
  0000f	8b 75 0c	 mov	 esi, DWORD PTR _current$[ebp]
  00012	8b 5d 08	 mov	 ebx, DWORD PTR _token$[ebp]

; 709  : 
; 710  :    if ( !decodeUnicodeEscapeSequence( token, current, end, unicode ) )

  00015	57		 push	 edi
  00016	ff 75 10	 push	 DWORD PTR _end$[ebp]

; 723  :          } 
; 724  :          else
; 725  :             return false;
; 726  :       } 
; 727  :       else
; 728  :          return addError( "expecting another \\u token to begin the second half of a unicode surrogate pair", token, current );

  00019	89 4d b4	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  0001c	56		 push	 esi
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 ?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
  00023	84 c0		 test	 al, al
  00025	75 07		 jne	 SHORT $LN7@decodeUnic@2
$LN3@decodeUnic@2:

; 711  :       return false;

  00027	32 c0		 xor	 al, al
  00029	e9 9d 00 00 00	 jmp	 $LN8@decodeUnic@2
$LN7@decodeUnic@2:

; 712  :    if (unicode >= 0xD800 && unicode <= 0xDBFF)

  0002e	8b 07		 mov	 eax, DWORD PTR [edi]
  00030	3d 00 d8 00 00	 cmp	 eax, 55296		; 0000d800H
  00035	0f 82 8e 00 00
	00		 jb	 $LN1@decodeUnic@2
  0003b	3d ff db 00 00	 cmp	 eax, 56319		; 0000dbffH
  00040	0f 87 83 00 00
	00		 ja	 $LN1@decodeUnic@2

; 713  :    {
; 714  :       // surrogate pairs
; 715  :       if (end - current < 6)

  00046	8b 06		 mov	 eax, DWORD PTR [esi]
  00048	8b 4d 10	 mov	 ecx, DWORD PTR _end$[ebp]
  0004b	2b c8		 sub	 ecx, eax
  0004d	83 f9 06	 cmp	 ecx, 6
  00050	7d 32		 jge	 SHORT $LN5@decodeUnic@2

; 716  :          return addError( "additional six characters expected to parse unicode surrogate pair.", token, current );

  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@
  00057	8d 4d d4	 lea	 ecx, DWORD PTR $T34968[ebp]
  0005a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0005f	ff 36		 push	 DWORD PTR [esi]
  00061	8b 4d b4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00064	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	53		 push	 ebx
  00069	8d 45 d4	 lea	 eax, DWORD PTR $T34968[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
  00072	6a 00		 push	 0
  00074	6a 01		 push	 1
  00076	8d 4d d4	 lea	 ecx, DWORD PTR $T34968[ebp]
$LN22@decodeUnic@2:
  00079	8a d8		 mov	 bl, al
  0007b	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00080	8a c3		 mov	 al, bl
  00082	eb 47		 jmp	 SHORT $LN8@decodeUnic@2
$LN5@decodeUnic@2:

; 717  :       unsigned int surrogatePair;
; 718  :       if (*(current++) == '\\' && *(current++)== 'u')

  00084	8a 08		 mov	 cl, BYTE PTR [eax]
  00086	40		 inc	 eax
  00087	89 06		 mov	 DWORD PTR [esi], eax
  00089	80 f9 5c	 cmp	 cl, 92			; 0000005cH
  0008c	75 45		 jne	 SHORT $LN4@decodeUnic@2
  0008e	8a 08		 mov	 cl, BYTE PTR [eax]
  00090	40		 inc	 eax
  00091	89 06		 mov	 DWORD PTR [esi], eax
  00093	80 f9 75	 cmp	 cl, 117			; 00000075H
  00096	75 3b		 jne	 SHORT $LN4@decodeUnic@2

; 719  :       {
; 720  :          if (decodeUnicodeEscapeSequence( token, current, end, surrogatePair ))

  00098	8b 4d b4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0009b	8d 45 b4	 lea	 eax, DWORD PTR _surrogatePair$34971[ebp]
  0009e	50		 push	 eax
  0009f	ff 75 10	 push	 DWORD PTR _end$[ebp]
  000a2	56		 push	 esi
  000a3	53		 push	 ebx
  000a4	e8 00 00 00 00	 call	 ?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
  000a9	84 c0		 test	 al, al
  000ab	0f 84 76 ff ff
	ff		 je	 $LN3@decodeUnic@2

; 721  :          {
; 722  :             unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);

  000b1	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000b3	8b 55 b4	 mov	 edx, DWORD PTR _surrogatePair$34971[ebp]
  000b6	b8 ff 03 00 00	 mov	 eax, 1023		; 000003ffH
  000bb	23 c8		 and	 ecx, eax
  000bd	83 c1 40	 add	 ecx, 64			; 00000040H
  000c0	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  000c3	23 d0		 and	 edx, eax
  000c5	03 ca		 add	 ecx, edx
  000c7	89 0f		 mov	 DWORD PTR [edi], ecx
$LN1@decodeUnic@2:

; 729  :    }
; 730  :    return true;

  000c9	b0 01		 mov	 al, 1
$LN8@decodeUnic@2:

; 731  : }

  000cb	e8 00 00 00 00	 call	 __EH_epilog3_GS
  000d0	c2 10 00	 ret	 16			; 00000010H
$LN4@decodeUnic@2:

; 723  :          } 
; 724  :          else
; 725  :             return false;
; 726  :       } 
; 727  :       else
; 728  :          return addError( "expecting another \\u token to begin the second half of a unicode surrogate pair", token, current );

  000d3	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@
  000d8	8d 4d b8	 lea	 ecx, DWORD PTR $T34976[ebp]
  000db	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000e0	ff 36		 push	 DWORD PTR [esi]
  000e2	8b 4d b4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  000e5	33 ff		 xor	 edi, edi
  000e7	53		 push	 ebx
  000e8	8d 45 b8	 lea	 eax, DWORD PTR $T34976[ebp]
  000eb	47		 inc	 edi
  000ec	50		 push	 eax
  000ed	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  000f0	e8 00 00 00 00	 call	 ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
  000f5	6a 00		 push	 0
  000f7	57		 push	 edi
  000f8	8d 4d b8	 lea	 ecx, DWORD PTR $T34976[ebp]
  000fb	e9 79 ff ff ff	 jmp	 $LN22@decodeUnic@2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T34968[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1:
  00008	8d 4d b8	 lea	 ecx, DWORD PTR $T34976[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ENDP ; Json::Reader::decodeUnicodeCodePoint
PUBLIC	??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@ ; `string'
PUBLIC	??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@ ; `string'
PUBLIC	_decoded$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
;	COMDAT ??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
CONST	SEGMENT
??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@ DB 'Bad escape '
	DB	'sequence in string', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
CONST	SEGMENT
??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@ DB 'Empty esc'
	DB	'ape sequence in string', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
__ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_c$34928 = -120						; size = 1
_unicode$34950 = -116					; size = 4
_current$ = -112					; size = 4
_this$GSCopy$ = -108					; size = 4
_decoded$GSCopy$ = -104					; size = 4
$T34952 = -100						; size = 28
$T34954 = -72						; size = 28
$T34933 = -44						; size = 28
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
_decoded$ = 12						; size = 4
?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Reader::decodeString, COMDAT
; _this$ = ecx

; 659  : {

  00000	6a 6c		 push	 108			; 0000006cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _token$[ebp]

; 660  :    decoded.reserve( token.end_ - token.start_ - 2 );

  0000f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00012	2b 47 04	 sub	 eax, DWORD PTR [edi+4]
  00015	89 4d 94	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _decoded$[ebp]
  0001b	83 e8 02	 sub	 eax, 2
  0001e	50		 push	 eax

; 661  :    Location current = token.start_ + 1; // skip '"'
; 662  :    Location end = token.end_ - 1;      // do not include '"'
; 663  :    while ( current != end )

  0001f	89 4d 98	 mov	 DWORD PTR _decoded$GSCopy$[ebp], ecx
  00022	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
  00027	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0002a	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0002d	46		 inc	 esi
  0002e	4b		 dec	 ebx
  0002f	e9 da 00 00 00	 jmp	 $LN69@decodeStri
$LL20@decodeStri:

; 664  :    {
; 665  :       Char c = *current++;

  00034	8a 06		 mov	 al, BYTE PTR [esi]
  00036	46		 inc	 esi
  00037	88 45 88	 mov	 BYTE PTR _c$34928[ebp], al

; 666  :       if ( c == '"' )

  0003a	3c 22		 cmp	 al, 34			; 00000022H
  0003c	0f 84 d4 00 00
	00		 je	 $LN19@decodeStri

; 667  :          break;
; 668  :       else if ( c == '\\' )

  00042	3c 5c		 cmp	 al, 92			; 0000005cH
  00044	0f 85 b7 00 00
	00		 jne	 $LN16@decodeStri

; 669  :       {
; 670  :          if ( current == end )

  0004a	3b f3		 cmp	 esi, ebx
  0004c	0f 84 ce 00 00
	00		 je	 $LN63@decodeStri

; 672  :          Char escape = *current++;

  00052	8a 06		 mov	 al, BYTE PTR [esi]

; 673  :          switch ( escape )

  00054	0f be c0	 movsx	 eax, al
  00057	46		 inc	 esi
  00058	89 75 90	 mov	 DWORD PTR _current$[ebp], esi
  0005b	83 f8 66	 cmp	 eax, 102		; 00000066H
  0005e	7f 31		 jg	 SHORT $LN23@decodeStri
  00060	74 2b		 je	 SHORT $LN8@decodeStri
  00062	83 f8 22	 cmp	 eax, 34			; 00000022H
  00065	74 22		 je	 SHORT $LN12@decodeStri
  00067	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0006a	74 19		 je	 SHORT $LN11@decodeStri
  0006c	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0006f	74 10		 je	 SHORT $LN10@decodeStri
  00071	83 f8 62	 cmp	 eax, 98			; 00000062H
  00074	0f 85 d7 00 00
	00		 jne	 $LN64@decodeStri

; 678  :          case 'b': decoded += '\b'; break;

  0007a	6a 08		 push	 8
  0007c	e9 83 00 00 00	 jmp	 $LN70@decodeStri
$LN10@decodeStri:

; 677  :          case '\\': decoded += '\\'; break;

  00081	6a 5c		 push	 92			; 0000005cH
  00083	eb 7f		 jmp	 SHORT $LN70@decodeStri
$LN11@decodeStri:

; 676  :          case '/': decoded += '/'; break;

  00085	6a 2f		 push	 47			; 0000002fH
  00087	eb 7b		 jmp	 SHORT $LN70@decodeStri
$LN12@decodeStri:

; 674  :          {
; 675  :          case '"': decoded += '"'; break;

  00089	6a 22		 push	 34			; 00000022H
  0008b	eb 77		 jmp	 SHORT $LN70@decodeStri
$LN8@decodeStri:

; 679  :          case 'f': decoded += '\f'; break;

  0008d	6a 0c		 push	 12			; 0000000cH
  0008f	eb 73		 jmp	 SHORT $LN70@decodeStri
$LN23@decodeStri:

; 673  :          switch ( escape )

  00091	83 e8 6e	 sub	 eax, 110		; 0000006eH
  00094	74 67		 je	 SHORT $LN7@decodeStri
  00096	83 e8 04	 sub	 eax, 4
  00099	74 5e		 je	 SHORT $LN6@decodeStri
  0009b	48		 dec	 eax
  0009c	48		 dec	 eax
  0009d	74 56		 je	 SHORT $LN5@decodeStri
  0009f	48		 dec	 eax
  000a0	0f 85 ab 00 00
	00		 jne	 $LN64@decodeStri

; 683  :          case 'u':
; 684  :             {
; 685  :                unsigned int unicode;
; 686  :                if ( !decodeUnicodeCodePoint( token, current, end, unicode ) )

  000a6	8b 4d 94	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  000a9	8d 45 8c	 lea	 eax, DWORD PTR _unicode$34950[ebp]
  000ac	50		 push	 eax
  000ad	53		 push	 ebx
  000ae	8d 45 90	 lea	 eax, DWORD PTR _current$[ebp]
  000b1	50		 push	 eax
  000b2	57		 push	 edi
  000b3	e8 00 00 00 00	 call	 ?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeCodePoint
  000b8	84 c0		 test	 al, al
  000ba	0f 84 b8 00 00
	00		 je	 $LN65@decodeStri

; 688  :                decoded += codePointToUTF8(unicode);

  000c0	ff 75 8c	 push	 DWORD PTR _unicode$34950[ebp]
  000c3	8d 45 9c	 lea	 eax, DWORD PTR $T34952[ebp]
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 ?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::codePointToUTF8
  000cc	59		 pop	 ecx
  000cd	59		 pop	 ecx
  000ce	8b 4d 98	 mov	 ecx, DWORD PTR _decoded$GSCopy$[ebp]
  000d1	6a ff		 push	 -1
  000d3	33 f6		 xor	 esi, esi
  000d5	6a 00		 push	 0
  000d7	46		 inc	 esi
  000d8	50		 push	 eax
  000d9	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  000dc	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  000e1	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000e5	6a 00		 push	 0
  000e7	56		 push	 esi
  000e8	8d 4d 9c	 lea	 ecx, DWORD PTR $T34952[ebp]
  000eb	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 689  :             }
; 690  :             break;

  000f0	8b 75 90	 mov	 esi, DWORD PTR _current$[ebp]
  000f3	eb 19		 jmp	 SHORT $LN69@decodeStri
$LN5@decodeStri:

; 682  :          case 't': decoded += '\t'; break;

  000f5	6a 09		 push	 9
  000f7	eb 0b		 jmp	 SHORT $LN70@decodeStri
$LN6@decodeStri:

; 681  :          case 'r': decoded += '\r'; break;

  000f9	6a 0d		 push	 13			; 0000000dH
  000fb	eb 07		 jmp	 SHORT $LN70@decodeStri
$LN7@decodeStri:

; 680  :          case 'n': decoded += '\n'; break;

  000fd	6a 0a		 push	 10			; 0000000aH

; 693  :          }
; 694  :       }
; 695  :       else

  000ff	eb 03		 jmp	 SHORT $LN70@decodeStri
$LN16@decodeStri:

; 696  :       {
; 697  :          decoded += c;

  00101	ff 75 88	 push	 DWORD PTR _c$34928[ebp]
$LN70@decodeStri:
  00104	8b 4d 98	 mov	 ecx, DWORD PTR _decoded$GSCopy$[ebp]
  00107	6a 01		 push	 1
  00109	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN69@decodeStri:

; 661  :    Location current = token.start_ + 1; // skip '"'
; 662  :    Location end = token.end_ - 1;      // do not include '"'
; 663  :    while ( current != end )

  0010e	3b f3		 cmp	 esi, ebx
  00110	0f 85 1e ff ff
	ff		 jne	 $LL20@decodeStri
$LN19@decodeStri:

; 698  :       }
; 699  :    }
; 700  :    return true;

  00116	b0 01		 mov	 al, 1
$LN21@decodeStri:

; 701  : }

  00118	e8 00 00 00 00	 call	 __EH_epilog3_GS
  0011d	c2 08 00	 ret	 8
$LN63@decodeStri:

; 671  :             return addError( "Empty escape sequence in string", token, current );

  00120	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
  00125	8d 4d d4	 lea	 ecx, DWORD PTR $T34933[ebp]
  00128	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0012d	8b 4d 94	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00130	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00134	56		 push	 esi
  00135	57		 push	 edi
  00136	8d 45 d4	 lea	 eax, DWORD PTR $T34933[ebp]
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
  0013f	8d 4d d4	 lea	 ecx, DWORD PTR $T34933[ebp]
$LN72@decodeStri:
  00142	6a 00		 push	 0
  00144	6a 01		 push	 1
  00146	8a d8		 mov	 bl, al
  00148	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  0014d	8a c3		 mov	 al, bl
  0014f	eb c7		 jmp	 SHORT $LN21@decodeStri
$LN64@decodeStri:

; 691  :          default:
; 692  :             return addError( "Bad escape sequence in string", token, current );

  00151	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@
  00156	8d 4d b8	 lea	 ecx, DWORD PTR $T34954[ebp]
  00159	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0015e	8b 4d 94	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00161	56		 push	 esi
  00162	57		 push	 edi
  00163	8d 45 b8	 lea	 eax, DWORD PTR $T34954[ebp]
  00166	50		 push	 eax
  00167	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0016e	e8 00 00 00 00	 call	 ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
  00173	8d 4d b8	 lea	 ecx, DWORD PTR $T34954[ebp]
  00176	eb ca		 jmp	 SHORT $LN72@decodeStri
$LN65@decodeStri:

; 687  :                   return false;

  00178	32 c0		 xor	 al, al
  0017a	eb 9c		 jmp	 SHORT $LN21@decodeStri
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
  00000	8d 4d 9c	 lea	 ecx, DWORD PTR $T34952[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR $T34933[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
  00010	8d 4d b8	 lea	 ecx, DWORD PTR $T34954[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a 84	 mov	 ecx, DWORD PTR [edx-124]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Reader::decodeString
PUBLIC	??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@ ; `string'
PUBLIC	??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@ ; `string'
PUBLIC	??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?readObject@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readObject
EXTRN	??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Json::Value::operator[]
;	COMDAT ??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
CONST	SEGMENT
??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@ DB 'Missing '
	DB	''':'' after object member name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
CONST	SEGMENT
??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@ DB 'Mi'
	DB	'ssing '','' or ''}'' in object declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
CONST	SEGMENT
??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@ DB 'Missin'
	DB	'g ''}'' or object member name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$4
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
_value$34759 = -156					; size = 4
_tokenName$ = -152					; size = 12
_comma$34763 = -140					; size = 12
$T34756 = -128						; size = 28
$T34775 = -100						; size = 28
_name$ = -72						; size = 28
$T34766 = -44						; size = 28
$T49209 = -32						; size = 16
_colon$34753 = -28					; size = 12
__$EHRec$ = -12						; size = 12
_tokenStart$ = 8					; size = 4
?readObject@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::readObject, COMDAT
; _this$ = ecx

; 481  : {

  00000	68 90 00 00 00	 push	 144			; 00000090H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3_GS

; 482  :    Token tokenName;
; 483  :    std::string name;

  0000f	33 ff		 xor	 edi, edi
  00011	8b f1		 mov	 esi, ecx
  00013	c7 45 cc 0f 00
	00 00		 mov	 DWORD PTR _name$[ebp+20], 15 ; 0000000fH
  0001a	89 7d c8	 mov	 DWORD PTR _name$[ebp+16], edi
  0001d	c6 45 b8 00	 mov	 BYTE PTR _name$[ebp], 0

; 484  :    currentValue() = Value( objectValue );

  00021	6a 07		 push	 7
  00023	8d 4d e0	 lea	 ecx, DWORD PTR $T49209[ebp]
  00026	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00029	e8 00 00 00 00	 call	 ??0Value@Json@@QAE@W4ValueType@1@@Z ; Json::Value::Value
  0002e	8b d8		 mov	 ebx, eax
  00030	8b ce		 mov	 ecx, esi
  00032	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00036	e8 00 00 00 00	 call	 ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	53		 push	 ebx
  0003e	e8 00 00 00 00	 call	 ??4Value@Json@@QAEAAV01@ABV01@@Z ; Json::Value::operator=
  00043	8d 4d e0	 lea	 ecx, DWORD PTR $T49209[ebp]
  00046	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0004a	e8 00 00 00 00	 call	 ??1Value@Json@@QAE@XZ	; Json::Value::~Value

; 485  :    while ( readToken( tokenName ) )

  0004f	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _tokenName$[ebp]
  00055	50		 push	 eax
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
  0005d	84 c0		 test	 al, al
  0005f	0f 84 5c 01 00
	00		 je	 $LN15@readObject
  00065	6a 0c		 push	 12			; 0000000cH
  00067	5b		 pop	 ebx
$LL16@readObject:

; 486  :    {
; 487  :       bool initialTokenOk = true;

  00068	b0 01		 mov	 al, 1

; 488  :       while ( tokenName.type_ == tokenComment  &&  initialTokenOk )

  0006a	39 9d 68 ff ff
	ff		 cmp	 DWORD PTR _tokenName$[ebp], ebx
  00070	75 26		 jne	 SHORT $LN144@readObject
$LL14@readObject:
  00072	84 c0		 test	 al, al
  00074	0f 84 47 01 00
	00		 je	 $LN15@readObject

; 489  :          initialTokenOk = readToken( tokenName );

  0007a	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _tokenName$[ebp]
  00080	50		 push	 eax
  00081	8b ce		 mov	 ecx, esi
  00083	e8 00 00 00 00	 call	 ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
  00088	39 9d 68 ff ff
	ff		 cmp	 DWORD PTR _tokenName$[ebp], ebx
  0008e	74 e2		 je	 SHORT $LL14@readObject

; 490  :       if  ( !initialTokenOk )

  00090	84 c0		 test	 al, al
  00092	0f 84 29 01 00
	00		 je	 $LN15@readObject
$LN144@readObject:

; 491  :          break;
; 492  :       if ( tokenName.type_ == tokenObjectEnd  &&  name.empty() )  // empty object

  00098	83 bd 68 ff ff
	ff 02		 cmp	 DWORD PTR _tokenName$[ebp], 2
  0009f	75 09		 jne	 SHORT $LN11@readObject
  000a1	39 7d c8	 cmp	 DWORD PTR _name$[ebp+16], edi
  000a4	0f 84 4c 01 00
	00		 je	 $LN135@readObject
$LN11@readObject:

; 494  :       if ( tokenName.type_ != tokenString )

  000aa	83 bd 68 ff ff
	ff 05		 cmp	 DWORD PTR _tokenName$[ebp], 5
  000b1	0f 85 0a 01 00
	00		 jne	 $LN15@readObject

; 495  :          break;
; 496  :       
; 497  :       name = "";

  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000bc	e8 00 00 00 00	 call	 _strlen
  000c1	59		 pop	 ecx
  000c2	50		 push	 eax
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000c8	8d 4d b8	 lea	 ecx, DWORD PTR _name$[ebp]
  000cb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 498  :       if ( !decodeString( tokenName, name ) )

  000d0	8d 45 b8	 lea	 eax, DWORD PTR _name$[ebp]
  000d3	50		 push	 eax
  000d4	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _tokenName$[ebp]
  000da	50		 push	 eax
  000db	8b ce		 mov	 ecx, esi
  000dd	e8 00 00 00 00	 call	 ?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString

; 500  : 
; 501  :       Token colon;
; 502  :       if ( !readToken( colon ) ||  colon.type_ != tokenMemberSeparator )

  000e2	8b ce		 mov	 ecx, esi
  000e4	84 c0		 test	 al, al
  000e6	0f 84 21 01 00
	00		 je	 $LN137@readObject
  000ec	8d 45 e4	 lea	 eax, DWORD PTR _colon$34753[ebp]
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
  000f5	84 c0		 test	 al, al
  000f7	0f 84 4d 01 00
	00		 je	 $LN7@readObject
  000fd	83 7d e4 0b	 cmp	 DWORD PTR _colon$34753[ebp], 11 ; 0000000bH
  00101	0f 85 43 01 00
	00		 jne	 $LN7@readObject

; 507  :       }
; 508  :       Value &value = currentValue()[ name ];

  00107	8b ce		 mov	 ecx, esi
  00109	e8 00 00 00 00	 call	 ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
  0010e	8b 00		 mov	 eax, DWORD PTR [eax]
  00110	8d 4d b8	 lea	 ecx, DWORD PTR _name$[ebp]
  00113	51		 push	 ecx
  00114	8b c8		 mov	 ecx, eax
  00116	e8 00 00 00 00	 call	 ??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
  0011b	89 85 64 ff ff
	ff		 mov	 DWORD PTR _value$34759[ebp], eax

; 509  :       nodes_.push( &value );

  00121	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _value$34759[ebp]
  00127	50		 push	 eax
  00128	8b ce		 mov	 ecx, esi
  0012a	e8 00 00 00 00	 call	 ?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back

; 510  :       bool ok = readValue();

  0012f	8b ce		 mov	 ecx, esi
  00131	e8 00 00 00 00	 call	 ?readValue@Reader@Json@@AAE_NXZ ; Json::Reader::readValue

; 511  :       nodes_.pop();

  00136	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00139	3b cf		 cmp	 ecx, edi
  0013b	74 0b		 je	 SHORT $LN90@readObject
  0013d	49		 dec	 ecx
  0013e	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00141	3b cf		 cmp	 ecx, edi
  00143	75 03		 jne	 SHORT $LN90@readObject
  00145	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
$LN90@readObject:

; 512  :       if ( !ok ) // error already set
; 513  :          return recoverFromError( tokenObjectEnd );
; 514  : 
; 515  :       Token comma;
; 516  :       if ( !readToken( comma )
; 517  :             ||  ( comma.type_ != tokenObjectEnd  &&  
; 518  :                   comma.type_ != tokenArraySeparator &&
; 519  : 		  comma.type_ != tokenComment ) )

  00148	8b ce		 mov	 ecx, esi
  0014a	84 c0		 test	 al, al
  0014c	0f 84 bb 00 00
	00		 je	 $LN137@readObject
  00152	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _comma$34763[ebp]
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
  0015e	84 c0		 test	 al, al
  00160	0f 84 b2 00 00
	00		 je	 $LN4@readObject
  00166	83 bd 74 ff ff
	ff 02		 cmp	 DWORD PTR _comma$34763[ebp], 2
  0016d	74 15		 je	 SHORT $LN5@readObject
  0016f	83 bd 74 ff ff
	ff 0a		 cmp	 DWORD PTR _comma$34763[ebp], 10 ; 0000000aH
  00176	74 0c		 je	 SHORT $LN5@readObject
  00178	39 9d 74 ff ff
	ff		 cmp	 DWORD PTR _comma$34763[ebp], ebx
  0017e	0f 85 94 00 00
	00		 jne	 $LN4@readObject
$LN5@readObject:

; 524  :       }
; 525  :       bool finalizeTokenOk = true;

  00184	b0 01		 mov	 al, 1
  00186	eb 12		 jmp	 SHORT $LN149@readObject
$LN3@readObject:

; 526  :       while ( comma.type_ == tokenComment &&
; 527  :               finalizeTokenOk )

  00188	84 c0		 test	 al, al
  0018a	74 16		 je	 SHORT $LN2@readObject

; 528  :          finalizeTokenOk = readToken( comma );

  0018c	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _comma$34763[ebp]
  00192	50		 push	 eax
  00193	8b ce		 mov	 ecx, esi
  00195	e8 00 00 00 00	 call	 ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
$LN149@readObject:

; 526  :       while ( comma.type_ == tokenComment &&
; 527  :               finalizeTokenOk )

  0019a	39 9d 74 ff ff
	ff		 cmp	 DWORD PTR _comma$34763[ebp], ebx
  001a0	74 e6		 je	 SHORT $LN3@readObject
$LN2@readObject:

; 529  :       if ( comma.type_ == tokenObjectEnd )

  001a2	83 bd 74 ff ff
	ff 02		 cmp	 DWORD PTR _comma$34763[ebp], 2
  001a9	74 4b		 je	 SHORT $LN135@readObject

; 485  :    while ( readToken( tokenName ) )

  001ab	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _tokenName$[ebp]
  001b1	50		 push	 eax
  001b2	8b ce		 mov	 ecx, esi
  001b4	e8 00 00 00 00	 call	 ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
  001b9	84 c0		 test	 al, al
  001bb	0f 85 a7 fe ff
	ff		 jne	 $LL16@readObject
$LN15@readObject:

; 530  :          return true;
; 531  :    }
; 532  :    return addErrorAndRecover( "Missing '}' or object member name", 
; 533  :                               tokenName, 
; 534  :                               tokenObjectEnd );

  001c1	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
  001c6	8d 4d 9c	 lea	 ecx, DWORD PTR $T34775[ebp]
  001c9	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001ce	57		 push	 edi
  001cf	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _tokenName$[ebp]
  001d5	50		 push	 eax
  001d6	8d 45 9c	 lea	 eax, DWORD PTR $T34775[ebp]
  001d9	50		 push	 eax
  001da	8b ce		 mov	 ecx, esi
  001dc	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  001e0	e8 00 00 00 00	 call	 ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
  001e5	6a 02		 push	 2
  001e7	8b ce		 mov	 ecx, esi
  001e9	e8 00 00 00 00	 call	 ?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
  001ee	8d 4d 9c	 lea	 ecx, DWORD PTR $T34775[ebp]
  001f1	e9 81 00 00 00	 jmp	 $LN151@readObject
$LN135@readObject:
  001f6	b3 01		 mov	 bl, 1
$LN145@readObject:

; 493  :          return true;

  001f8	57		 push	 edi
  001f9	6a 01		 push	 1
  001fb	8d 4d b8	 lea	 ecx, DWORD PTR _name$[ebp]
  001fe	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00203	8a c3		 mov	 al, bl

; 535  : }

  00205	e8 00 00 00 00	 call	 __EH_epilog3_GS
  0020a	c2 04 00	 ret	 4
$LN137@readObject:

; 499  :          return recoverFromError( tokenObjectEnd );

  0020d	6a 02		 push	 2
  0020f	e8 00 00 00 00	 call	 ?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
  00214	8a d8		 mov	 bl, al
  00216	eb e0		 jmp	 SHORT $LN145@readObject
$LN4@readObject:

; 520  :       {
; 521  :          return addErrorAndRecover( "Missing ',' or '}' in object declaration", 
; 522  :                                     comma, 
; 523  :                                     tokenObjectEnd );

  00218	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
  0021d	8d 4d d4	 lea	 ecx, DWORD PTR $T34766[ebp]
  00220	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00225	57		 push	 edi
  00226	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _comma$34763[ebp]
  0022c	50		 push	 eax
  0022d	8d 45 d4	 lea	 eax, DWORD PTR $T34766[ebp]
  00230	50		 push	 eax
  00231	8b ce		 mov	 ecx, esi
  00233	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00237	e8 00 00 00 00	 call	 ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
  0023c	6a 02		 push	 2
  0023e	8b ce		 mov	 ecx, esi
  00240	e8 00 00 00 00	 call	 ?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
  00245	8d 4d d4	 lea	 ecx, DWORD PTR $T34766[ebp]
  00248	eb 2d		 jmp	 SHORT $LN151@readObject
$LN7@readObject:

; 503  :       {
; 504  :          return addErrorAndRecover( "Missing ':' after object member name", 
; 505  :                                     colon, 
; 506  :                                     tokenObjectEnd );

  0024a	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
  0024f	8d 4d 80	 lea	 ecx, DWORD PTR $T34756[ebp]
  00252	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00257	57		 push	 edi
  00258	8d 45 e4	 lea	 eax, DWORD PTR _colon$34753[ebp]
  0025b	50		 push	 eax
  0025c	8d 45 80	 lea	 eax, DWORD PTR $T34756[ebp]
  0025f	50		 push	 eax
  00260	8b ce		 mov	 ecx, esi
  00262	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00266	e8 00 00 00 00	 call	 ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
  0026b	6a 02		 push	 2
  0026d	8b ce		 mov	 ecx, esi
  0026f	e8 00 00 00 00	 call	 ?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
  00274	8d 4d 80	 lea	 ecx, DWORD PTR $T34756[ebp]
$LN151@readObject:
  00277	57		 push	 edi
  00278	6a 01		 push	 1
  0027a	8a d8		 mov	 bl, al
  0027c	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00281	e9 72 ff ff ff	 jmp	 $LN145@readObject
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$0:
  00000	8d 4d b8	 lea	 ecx, DWORD PTR _name$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$1:
  00008	8d 4d e0	 lea	 ecx, DWORD PTR $T49209[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1Value@Json@@QAE@XZ	; Json::Value::~Value
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$4:
  00010	8d 4d 9c	 lea	 ecx, DWORD PTR $T34775[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$3:
  00018	8d 4d d4	 lea	 ecx, DWORD PTR $T34766[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$2:
  00020	8d 4d 80	 lea	 ecx, DWORD PTR $T34756[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z:
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 8a 60 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-160]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0003f	33 c8		 xor	 ecx, eax
  00041	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00046	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
  0004b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?readObject@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readObject
PUBLIC	?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeString
EXTRN	??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Json::Value::Value
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$1
__ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
$T49532 = -61						; size = 16
tv240 = -45						; size = 1
_decoded$ = -44						; size = 28
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::decodeString, COMDAT
; _this$ = ecx

; 648  : {

  00000	6a 34		 push	 52			; 00000034H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]

; 649  :    std::string decoded;

  0000f	33 db		 xor	 ebx, ebx
  00011	8b f1		 mov	 esi, ecx
  00013	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _decoded$[ebp+20], 15 ; 0000000fH
  0001a	89 5d e4	 mov	 DWORD PTR _decoded$[ebp+16], ebx
  0001d	88 5d d4	 mov	 BYTE PTR _decoded$[ebp], bl

; 650  :    if ( !decodeString( token, decoded ) )

  00020	8d 4d d4	 lea	 ecx, DWORD PTR _decoded$[ebp]
  00023	51		 push	 ecx
  00024	50		 push	 eax
  00025	8b ce		 mov	 ecx, esi
  00027	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0002a	e8 00 00 00 00	 call	 ?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
  0002f	84 c0		 test	 al, al
  00031	75 19		 jne	 SHORT $LN1@decodeStri@2
  00033	88 5d d3	 mov	 BYTE PTR tv240[ebp], bl
$LN44@decodeStri@2:

; 651  :       return false;

  00036	53		 push	 ebx
  00037	6a 01		 push	 1
  00039	8d 4d d4	 lea	 ecx, DWORD PTR _decoded$[ebp]
  0003c	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00041	8a 45 d3	 mov	 al, BYTE PTR tv240[ebp]

; 653  :    return true;
; 654  : }

  00044	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00049	c2 04 00	 ret	 4
$LN1@decodeStri@2:

; 652  :    currentValue() = decoded;

  0004c	8d 45 d4	 lea	 eax, DWORD PTR _decoded$[ebp]
  0004f	50		 push	 eax
  00050	8d 4d c3	 lea	 ecx, DWORD PTR $T49532[ebp]
  00053	e8 00 00 00 00	 call	 ??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::Value
  00058	8b ce		 mov	 ecx, esi
  0005a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0005e	e8 00 00 00 00	 call	 ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
  00063	8b 00		 mov	 eax, DWORD PTR [eax]
  00065	8d 4d c3	 lea	 ecx, DWORD PTR $T49532[ebp]
  00068	51		 push	 ecx
  00069	8b c8		 mov	 ecx, eax
  0006b	e8 00 00 00 00	 call	 ??4Value@Json@@QAEAAV01@ABV01@@Z ; Json::Value::operator=
  00070	8d 4d c3	 lea	 ecx, DWORD PTR $T49532[ebp]
  00073	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+8], bl
  00076	e8 00 00 00 00	 call	 ??1Value@Json@@QAE@XZ	; Json::Value::~Value
  0007b	c6 45 d3 01	 mov	 BYTE PTR tv240[ebp], 1
  0007f	eb b5		 jmp	 SHORT $LN44@decodeStri@2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _decoded$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$1:
  00008	8d 4d c3	 lea	 ecx, DWORD PTR $T49532[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1Value@Json@@QAE@XZ	; Json::Value::~Value
__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeString
PUBLIC	??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@ ; `string'
EXTRN	??0Value@Json@@QAE@_N@Z:PROC			; Json::Value::Value
;	COMDAT ??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stack
CONST	SEGMENT
??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@ DB 'Syntax err'
	DB	'or: value, object or array expected.', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?readValue@Reader@Json@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$3
__ehfuncinfo$?readValue@Reader@Json@@AAE_NXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?readValue@Reader@Json@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?readValue@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
$T49668 = -108						; size = 16
$T49666 = -92						; size = 16
$T49667 = -76						; size = 16
_token$ = -60						; size = 12
_successful$ = -45					; size = 1
$T34505 = -44						; size = 28
__$EHRec$ = -12						; size = 12
?readValue@Reader@Json@@AAE_NXZ PROC			; Json::Reader::readValue, COMDAT
; _this$ = ecx

; 196  : {

  00000	6a 60		 push	 96			; 00000060H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?readValue@Reader@Json@@AAE_NXZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS

; 197  :    Token token;
; 198  :    skipCommentTokens( token );

  0000c	8d 45 c4	 lea	 eax, DWORD PTR _token$[ebp]
  0000f	50		 push	 eax
  00010	8b f1		 mov	 esi, ecx
  00012	e8 00 00 00 00	 call	 ?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ; Json::Reader::skipCommentTokens

; 199  :    bool successful = true;
; 200  : 
; 201  :    if ( collectComments_  &&  !commentsBefore_.empty() )

  00017	33 ff		 xor	 edi, edi
  00019	80 7e 7e 00	 cmp	 BYTE PTR [esi+126], 0
  0001d	c6 45 d3 01	 mov	 BYTE PTR _successful$[ebp], 1
  00021	74 2f		 je	 SHORT $LN25@readValue
  00023	39 7e 70	 cmp	 DWORD PTR [esi+112], edi
  00026	74 2a		 je	 SHORT $LN25@readValue

; 202  :    {
; 203  :       currentValue().setComment( commentsBefore_, commentBefore );

  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	57		 push	 edi
  00032	8d 5e 60	 lea	 ebx, DWORD PTR [esi+96]
  00035	53		 push	 ebx
  00036	e8 00 00 00 00	 call	 ?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment

; 204  :       commentsBefore_ = "";

  0003b	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00040	57		 push	 edi
  00041	e8 00 00 00 00	 call	 _strlen
  00046	59		 pop	 ecx
  00047	50		 push	 eax
  00048	57		 push	 edi
  00049	8b cb		 mov	 ecx, ebx
  0004b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00050	33 ff		 xor	 edi, edi
$LN25@readValue:

; 205  :    }
; 206  : 
; 207  : 
; 208  :    switch ( token.type_ )

  00052	8b 45 c4	 mov	 eax, DWORD PTR _token$[ebp]
  00055	48		 dec	 eax
  00056	0f 84 00 01 00
	00		 je	 $LN9@readValue
  0005c	6a 02		 push	 2
  0005e	5b		 pop	 ebx
  0005f	2b c3		 sub	 eax, ebx
  00061	0f 84 e8 00 00
	00		 je	 $LN8@readValue
  00067	2b c3		 sub	 eax, ebx
  00069	0f 84 d3 00 00
	00		 je	 $LN6@readValue
  0006f	48		 dec	 eax
  00070	0f 84 bf 00 00
	00		 je	 $LN7@readValue
  00076	48		 dec	 eax
  00077	0f 84 89 00 00
	00		 je	 $LN5@readValue
  0007d	48		 dec	 eax
  0007e	74 5d		 je	 SHORT $LN4@readValue
  00080	48		 dec	 eax
  00081	74 38		 je	 SHORT $LN3@readValue

; 231  :    default:
; 232  :       return addError( "Syntax error: value, object or array expected.", token );

  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
  00088	8d 4d d4	 lea	 ecx, DWORD PTR $T34505[ebp]
  0008b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00090	57		 push	 edi
  00091	8d 45 c4	 lea	 eax, DWORD PTR _token$[ebp]
  00094	50		 push	 eax
  00095	8d 45 d4	 lea	 eax, DWORD PTR $T34505[ebp]
  00098	50		 push	 eax
  00099	8b ce		 mov	 ecx, esi
  0009b	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  000a2	e8 00 00 00 00	 call	 ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
  000a7	57		 push	 edi
  000a8	6a 01		 push	 1
  000aa	8d 4d d4	 lea	 ecx, DWORD PTR $T34505[ebp]
  000ad	8a d8		 mov	 bl, al
  000af	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  000b4	8a c3		 mov	 al, bl
  000b6	e9 ca 00 00 00	 jmp	 $LN13@readValue
$LN3@readValue:

; 228  :    case tokenNull:
; 229  :       currentValue() = Value();

  000bb	57		 push	 edi
  000bc	8d 4d 94	 lea	 ecx, DWORD PTR $T49668[ebp]
  000bf	e8 00 00 00 00	 call	 ??0Value@Json@@QAE@W4ValueType@1@@Z ; Json::Value::Value
  000c4	8b f8		 mov	 edi, eax
  000c6	8b ce		 mov	 ecx, esi
  000c8	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  000cb	e8 00 00 00 00	 call	 ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
  000d0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d2	57		 push	 edi
  000d3	e8 00 00 00 00	 call	 ??4Value@Json@@QAEAAV01@ABV01@@Z ; Json::Value::operator=
  000d8	8d 4d 94	 lea	 ecx, DWORD PTR $T49668[ebp]

; 230  :       break;

  000db	eb 4d		 jmp	 SHORT $LN55@readValue
$LN4@readValue:

; 225  :    case tokenFalse:
; 226  :       currentValue() = false;

  000dd	57		 push	 edi
  000de	8d 4d b4	 lea	 ecx, DWORD PTR $T49667[ebp]
  000e1	e8 00 00 00 00	 call	 ??0Value@Json@@QAE@_N@Z	; Json::Value::Value
  000e6	8b ce		 mov	 ecx, esi
  000e8	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000ef	e8 00 00 00 00	 call	 ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
  000f4	8b 00		 mov	 eax, DWORD PTR [eax]
  000f6	8d 4d b4	 lea	 ecx, DWORD PTR $T49667[ebp]
  000f9	51		 push	 ecx
  000fa	8b c8		 mov	 ecx, eax
  000fc	e8 00 00 00 00	 call	 ??4Value@Json@@QAEAAV01@ABV01@@Z ; Json::Value::operator=
  00101	8d 4d b4	 lea	 ecx, DWORD PTR $T49667[ebp]

; 227  :       break;

  00104	eb 24		 jmp	 SHORT $LN55@readValue
$LN5@readValue:

; 222  :    case tokenTrue:
; 223  :       currentValue() = true;

  00106	6a 01		 push	 1
  00108	8d 4d a4	 lea	 ecx, DWORD PTR $T49666[ebp]
  0010b	e8 00 00 00 00	 call	 ??0Value@Json@@QAE@_N@Z	; Json::Value::Value
  00110	8b ce		 mov	 ecx, esi
  00112	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00115	e8 00 00 00 00	 call	 ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
  0011a	8b 00		 mov	 eax, DWORD PTR [eax]
  0011c	8d 4d a4	 lea	 ecx, DWORD PTR $T49666[ebp]
  0011f	51		 push	 ecx
  00120	8b c8		 mov	 ecx, eax
  00122	e8 00 00 00 00	 call	 ??4Value@Json@@QAEAAV01@ABV01@@Z ; Json::Value::operator=
  00127	8d 4d a4	 lea	 ecx, DWORD PTR $T49666[ebp]
$LN55@readValue:
  0012a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0012e	e8 00 00 00 00	 call	 ??1Value@Json@@QAE@XZ	; Json::Value::~Value

; 224  :       break;

  00133	eb 35		 jmp	 SHORT $LN10@readValue
$LN7@readValue:

; 216  :    case tokenNumber:
; 217  :       successful = decodeNumber( token );

  00135	8d 45 c4	 lea	 eax, DWORD PTR _token$[ebp]
  00138	50		 push	 eax
  00139	8b ce		 mov	 ecx, esi
  0013b	e8 00 00 00 00	 call	 ?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeNumber

; 218  :       break;

  00140	eb 25		 jmp	 SHORT $LN53@readValue
$LN6@readValue:

; 219  :    case tokenString:
; 220  :       successful = decodeString( token );

  00142	8d 45 c4	 lea	 eax, DWORD PTR _token$[ebp]
  00145	50		 push	 eax
  00146	8b ce		 mov	 ecx, esi
  00148	e8 00 00 00 00	 call	 ?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeString

; 221  :       break;

  0014d	eb 18		 jmp	 SHORT $LN53@readValue
$LN8@readValue:

; 212  :       break;
; 213  :    case tokenArrayBegin:
; 214  :       successful = readArray( token );

  0014f	8d 45 c4	 lea	 eax, DWORD PTR _token$[ebp]
  00152	50		 push	 eax
  00153	8b ce		 mov	 ecx, esi
  00155	e8 00 00 00 00	 call	 ?readArray@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readArray

; 215  :       break;

  0015a	eb 0b		 jmp	 SHORT $LN53@readValue
$LN9@readValue:

; 209  :    {
; 210  :    case tokenObjectBegin:
; 211  :       successful = readObject( token );

  0015c	8d 45 c4	 lea	 eax, DWORD PTR _token$[ebp]
  0015f	50		 push	 eax
  00160	8b ce		 mov	 ecx, esi
  00162	e8 00 00 00 00	 call	 ?readObject@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readObject
$LN53@readValue:
  00167	88 45 d3	 mov	 BYTE PTR _successful$[ebp], al
$LN10@readValue:

; 233  :    }
; 234  : 
; 235  :    if ( collectComments_ )

  0016a	80 7e 7e 00	 cmp	 BYTE PTR [esi+126], 0
  0016e	74 12		 je	 SHORT $LN1@readValue

; 236  :    {
; 237  :       lastValueEnd_ = current_;

  00170	8b 46 54	 mov	 eax, DWORD PTR [esi+84]

; 238  :       lastValue_ = &currentValue();

  00173	8b ce		 mov	 ecx, esi
  00175	89 46 58	 mov	 DWORD PTR [esi+88], eax
  00178	e8 00 00 00 00	 call	 ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
  0017d	8b 00		 mov	 eax, DWORD PTR [eax]
  0017f	89 46 5c	 mov	 DWORD PTR [esi+92], eax
$LN1@readValue:

; 239  :    }
; 240  : 
; 241  :    return successful;

  00182	8a 45 d3	 mov	 al, BYTE PTR _successful$[ebp]
$LN13@readValue:

; 242  : }

  00185	e8 00 00 00 00	 call	 __EH_epilog3_GS
  0018a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$3:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T34505[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$2:
  00008	8d 4d 94	 lea	 ecx, DWORD PTR $T49668[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1Value@Json@@QAE@XZ	; Json::Value::~Value
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$1:
  00010	8d 4d b4	 lea	 ecx, DWORD PTR $T49667[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1Value@Json@@QAE@XZ	; Json::Value::~Value
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$0:
  00018	8d 4d a4	 lea	 ecx, DWORD PTR $T49666[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1Value@Json@@QAE@XZ	; Json::Value::~Value
__ehhandler$?readValue@Reader@Json@@AAE_NXZ:
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?readValue@Reader@Json@@AAE_NXZ
  00040	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?readValue@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readValue
PUBLIC	??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@ ; `string'
PUBLIC	_root$GSCopy$
PUBLIC	_endDoc$GSCopy$
PUBLIC	?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z	; Json::Reader::parse
EXTRN	?isObject@Value@Json@@QBE_NXZ:PROC		; Json::Value::isObject
EXTRN	?isArray@Value@Json@@QBE_NXZ:PROC		; Json::Value::isArray
;	COMDAT ??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
CONST	SEGMENT
??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@ DB 'A valid JS'
	DB	'ON document must be either an array or an object value.', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z$0
__ehfuncinfo$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
_TEXT	SEGMENT
_token$ = -68						; size = 12
_endDoc$GSCopy$ = -56					; size = 4
_root$GSCopy$ = -52					; size = 4
_successful$ = -45					; size = 1
$T34482 = -44						; size = 28
__$EHRec$ = -12						; size = 12
_beginDoc$ = 8						; size = 4
_endDoc$ = 12						; size = 4
_root$ = 16						; size = 4
_collectComments$ = 20					; size = 1
?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z PROC	; Json::Reader::parse, COMDAT
; _this$ = ecx

; 154  : {

  00000	6a 38		 push	 56			; 00000038H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 45 0c	 mov	 eax, DWORD PTR _endDoc$[ebp]
  0000f	8b 5d 08	 mov	 ebx, DWORD PTR _beginDoc$[ebp]
  00012	8b f1		 mov	 esi, ecx

; 155  :    if ( !features_.allowComments_ )

  00014	80 7e 7c 00	 cmp	 BYTE PTR [esi+124], 0

; 188  :       }
; 189  :    }
; 190  :    return successful;

  00018	8b 4d 10	 mov	 ecx, DWORD PTR _root$[ebp]
  0001b	89 45 c8	 mov	 DWORD PTR _endDoc$GSCopy$[ebp], eax
  0001e	89 4d cc	 mov	 DWORD PTR _root$GSCopy$[ebp], ecx
  00021	75 04		 jne	 SHORT $LN48@parse

; 156  :    {
; 157  :       collectComments = false;

  00023	32 c9		 xor	 cl, cl
  00025	eb 03		 jmp	 SHORT $LN6@parse
$LN48@parse:
  00027	8a 4d 14	 mov	 cl, BYTE PTR _collectComments$[ebp]
$LN6@parse:

; 158  :    }
; 159  : 
; 160  :    begin_ = beginDoc;
; 161  :    end_ = endDoc;
; 162  :    collectComments_ = collectComments;
; 163  :    current_ = begin_;
; 164  :    lastValueEnd_ = 0;

  0002a	83 66 58 00	 and	 DWORD PTR [esi+88], 0

; 165  :    lastValue_ = 0;

  0002e	83 66 5c 00	 and	 DWORD PTR [esi+92], 0

; 166  :    commentsBefore_ = "";

  00032	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00037	57		 push	 edi
  00038	89 5e 4c	 mov	 DWORD PTR [esi+76], ebx
  0003b	89 46 50	 mov	 DWORD PTR [esi+80], eax
  0003e	88 4e 7e	 mov	 BYTE PTR [esi+126], cl
  00041	89 5e 54	 mov	 DWORD PTR [esi+84], ebx
  00044	e8 00 00 00 00	 call	 _strlen
  00049	59		 pop	 ecx
  0004a	50		 push	 eax
  0004b	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  0004e	57		 push	 edi
  0004f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 167  :    errors_.clear();

  00054	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00057	e8 00 00 00 00	 call	 ?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy

; 168  :    while ( !nodes_.empty() )

  0005c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0005f	33 ff		 xor	 edi, edi
  00061	3b c7		 cmp	 eax, edi
  00063	74 12		 je	 SHORT $LN4@parse
$LL5@parse:

; 169  :       nodes_.pop();

  00065	3b c7		 cmp	 eax, edi
  00067	74 09		 je	 SHORT $LN24@parse
  00069	48		 dec	 eax
  0006a	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0006d	75 03		 jne	 SHORT $LN24@parse
  0006f	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
$LN24@parse:

; 168  :    while ( !nodes_.empty() )

  00072	39 7e 10	 cmp	 DWORD PTR [esi+16], edi
  00075	75 ee		 jne	 SHORT $LL5@parse
$LN4@parse:

; 170  :    nodes_.push( &root );

  00077	8d 45 cc	 lea	 eax, DWORD PTR _root$GSCopy$[ebp]
  0007a	50		 push	 eax
  0007b	8b ce		 mov	 ecx, esi
  0007d	e8 00 00 00 00	 call	 ?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back

; 171  :    
; 172  :    bool successful = readValue();

  00082	8b ce		 mov	 ecx, esi
  00084	e8 00 00 00 00	 call	 ?readValue@Reader@Json@@AAE_NXZ ; Json::Reader::readValue
  00089	88 45 d3	 mov	 BYTE PTR _successful$[ebp], al

; 173  :    Token token;
; 174  :    skipCommentTokens( token );

  0008c	8d 45 bc	 lea	 eax, DWORD PTR _token$[ebp]
  0008f	50		 push	 eax
  00090	8b ce		 mov	 ecx, esi
  00092	e8 00 00 00 00	 call	 ?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ; Json::Reader::skipCommentTokens

; 175  :    if ( collectComments_  &&  !commentsBefore_.empty() )

  00097	80 7e 7e 00	 cmp	 BYTE PTR [esi+126], 0
  0009b	74 13		 je	 SHORT $LN3@parse
  0009d	39 7e 70	 cmp	 DWORD PTR [esi+112], edi
  000a0	74 0e		 je	 SHORT $LN3@parse

; 176  :       root.setComment( commentsBefore_, commentAfter );

  000a2	8b 4d cc	 mov	 ecx, DWORD PTR _root$GSCopy$[ebp]
  000a5	6a 02		 push	 2
  000a7	8d 46 60	 lea	 eax, DWORD PTR [esi+96]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment
$LN3@parse:

; 177  :    if ( features_.strictRoot_ )

  000b0	80 7e 7d 00	 cmp	 BYTE PTR [esi+125], 0
  000b4	74 57		 je	 SHORT $LN1@parse

; 178  :    {
; 179  :       if ( !root.isArray()  &&  !root.isObject() )

  000b6	8b 4d cc	 mov	 ecx, DWORD PTR _root$GSCopy$[ebp]
  000b9	e8 00 00 00 00	 call	 ?isArray@Value@Json@@QBE_NXZ ; Json::Value::isArray
  000be	84 c0		 test	 al, al
  000c0	75 4b		 jne	 SHORT $LN1@parse
  000c2	8b 4d cc	 mov	 ecx, DWORD PTR _root$GSCopy$[ebp]
  000c5	e8 00 00 00 00	 call	 ?isObject@Value@Json@@QBE_NXZ ; Json::Value::isObject
  000ca	84 c0		 test	 al, al
  000cc	75 3f		 jne	 SHORT $LN1@parse

; 180  :       {
; 181  :          // Set error location to start of doc, ideally should be first token found in doc
; 182  :          token.type_ = tokenError;
; 183  :          token.start_ = beginDoc;
; 184  :          token.end_ = endDoc;

  000ce	8b 45 c8	 mov	 eax, DWORD PTR _endDoc$GSCopy$[ebp]

; 185  :          addError( "A valid JSON document must be either an array or an object value.",
; 186  :                    token );

  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@
  000d6	8d 4d d4	 lea	 ecx, DWORD PTR $T34482[ebp]
  000d9	c7 45 bc 0d 00
	00 00		 mov	 DWORD PTR _token$[ebp], 13 ; 0000000dH
  000e0	89 5d c0	 mov	 DWORD PTR _token$[ebp+4], ebx
  000e3	89 45 c4	 mov	 DWORD PTR _token$[ebp+8], eax
  000e6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000eb	57		 push	 edi
  000ec	8d 45 bc	 lea	 eax, DWORD PTR _token$[ebp]
  000ef	50		 push	 eax
  000f0	8d 45 d4	 lea	 eax, DWORD PTR $T34482[ebp]
  000f3	50		 push	 eax
  000f4	8b ce		 mov	 ecx, esi
  000f6	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  000f9	e8 00 00 00 00	 call	 ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
  000fe	57		 push	 edi
  000ff	6a 01		 push	 1
  00101	8d 4d d4	 lea	 ecx, DWORD PTR $T34482[ebp]
  00104	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 187  :          return false;

  00109	32 c0		 xor	 al, al
  0010b	eb 03		 jmp	 SHORT $LN7@parse
$LN1@parse:

; 188  :       }
; 189  :    }
; 190  :    return successful;

  0010d	8a 45 d3	 mov	 al, BYTE PTR _successful$[ebp]
$LN7@parse:

; 191  : }

  00110	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00115	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T34482[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z ENDP	; Json::Reader::parse
PUBLIC	?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z ; Json::Reader::parse
; Function compile flags: /Ogsp
;	COMDAT ?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z
_TEXT	SEGMENT
_document$ = 8						; size = 4
_root$ = 12						; size = 4
_collectComments$ = 16					; size = 1
?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z PROC ; Json::Reader::parse, COMDAT
; _this$ = ecx

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 126  :    document_ = document;

  00005	6a ff		 push	 -1
  00007	8b f9		 mov	 edi, ecx
  00009	6a 00		 push	 0
  0000b	ff 75 08	 push	 DWORD PTR _document$[ebp]
  0000e	8d 77 30	 lea	 esi, DWORD PTR [edi+48]
  00011	8b ce		 mov	 ecx, esi
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 127  :    const char *begin = document_.c_str();

  00018	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0001c	72 02		 jb	 SHORT $LN11@parse@2
  0001e	8b 36		 mov	 esi, DWORD PTR [esi]
$LN11@parse@2:

; 128  :    const char *end = begin + document_.length();
; 129  :    return parse( begin, end, root, collectComments );

  00020	ff 75 10	 push	 DWORD PTR _collectComments$[ebp]
  00023	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  00026	ff 75 0c	 push	 DWORD PTR _root$[ebp]
  00029	03 c6		 add	 eax, esi
  0002b	50		 push	 eax
  0002c	56		 push	 esi
  0002d	8b cf		 mov	 ecx, edi
  0002f	e8 00 00 00 00	 call	 ?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z ; Json::Reader::parse
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi

; 130  : }

  00036	5d		 pop	 ebp
  00037	c2 0c 00	 ret	 12			; 0000000cH
?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z ENDP ; Json::Reader::parse
_TEXT	ENDS
PUBLIC	?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z ; Json::Reader::parse
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z$0
__ehfuncinfo$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\include\json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
_TEXT	SEGMENT
$T49904 = -45						; size = 1
_doc$ = -44						; size = 28
__$EHRec$ = -12						; size = 12
_sin$ = 8						; size = 4
_root$ = 12						; size = 4
_collectComments$ = 16					; size = 1
?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z PROC ; Json::Reader::parse, COMDAT
; _this$ = ecx

; 137  : {

  00000	6a 24		 push	 36			; 00000024H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 45 08	 mov	 eax, DWORD PTR _sin$[ebp]
  0000f	8b 75 0c	 mov	 esi, DWORD PTR _root$[ebp]

; 138  :    //std::istream_iterator<char> begin(sin);
; 139  :    //std::istream_iterator<char> end;
; 140  :    // Those would allow streamed input from a file, if parse() were a
; 141  :    // template function.
; 142  : 
; 143  :    // Since std::string is reference-counted, this at least does not
; 144  :    // create an extra copy.
; 145  :    std::string doc;

  00012	83 65 e4 00	 and	 DWORD PTR _doc$[ebp+16], 0
  00016	8b f9		 mov	 edi, ecx
  00018	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _doc$[ebp+20], 15 ; 0000000fH
  0001f	c6 45 d4 00	 mov	 BYTE PTR _doc$[ebp], 0
  00023	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 146  :    std::getline(sin, doc, (char)EOF);

  00027	6a ff		 push	 -1
  00029	8d 4d d4	 lea	 ecx, DWORD PTR _doc$[ebp]
  0002c	51		 push	 ecx
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 147  :    return parse( doc, root, collectComments );

  00036	ff 75 10	 push	 DWORD PTR _collectComments$[ebp]
  00039	8d 45 d4	 lea	 eax, DWORD PTR _doc$[ebp]
  0003c	56		 push	 esi
  0003d	50		 push	 eax
  0003e	8b cf		 mov	 ecx, edi
  00040	e8 00 00 00 00	 call	 ?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z ; Json::Reader::parse
  00045	6a 00		 push	 0
  00047	6a 01		 push	 1
  00049	8d 4d d4	 lea	 ecx, DWORD PTR _doc$[ebp]
  0004c	88 45 d3	 mov	 BYTE PTR $T49904[ebp], al
  0004f	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00054	8a 45 d3	 mov	 al, BYTE PTR $T49904[ebp]

; 148  : }

  00057	e8 00 00 00 00	 call	 __EH_epilog3_GS
  0005c	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _doc$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z ENDP ; Json::Reader::parse
PUBLIC	??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z ; Json::operator>>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z$0
__ehfuncinfo$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT ??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z
_TEXT	SEGMENT
_reader$ = -144						; size = 127
__$EHRec$ = -12						; size = 12
_sin$ = 8						; size = 4
_root$ = 12						; size = 4
??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z PROC ; Json::operator>>, COMDAT

; 876  : {

  00000	68 84 00 00 00	 push	 132			; 00000084H
  00005	b8 00 00 00 00	 mov	 eax, __ehhandler$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z
  0000a	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000f	8b 75 08	 mov	 esi, DWORD PTR _sin$[ebp]
  00012	8b 7d 0c	 mov	 edi, DWORD PTR _root$[ebp]

; 877  :     Json::Reader reader;

  00015	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _reader$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0Reader@Json@@QAE@XZ	; Json::Reader::Reader
  00020	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 878  :     bool ok = reader.parse(sin, root, true);

  00024	6a 01		 push	 1
  00026	57		 push	 edi
  00027	56		 push	 esi
  00028	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _reader$[ebp]
  0002e	e8 00 00 00 00	 call	 ?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z ; Json::Reader::parse

; 879  :     //JSON_ASSERT( ok );
; 880  :     //if (!ok) throw std::runtime_error(reader.getFormatedErrorMessages());
; 881  :     return sin;

  00033	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _reader$[ebp]
  00039	e8 00 00 00 00	 call	 ??1Reader@Json@@QAE@XZ
  0003e	8b c6		 mov	 eax, esi

; 882  : }

  00040	e8 00 00 00 00	 call	 __EH_epilog3_GS
  00045	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z$0:
  00000	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _reader$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1Reader@Json@@QAE@XZ
__ehhandler$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 6c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-148]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z ENDP ; Json::operator>>
END
