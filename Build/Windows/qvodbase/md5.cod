; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	F:\Projects\Git\YFNet\trunk\Src\qvodbase\md5.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?max_digits10@?$numeric_limits@D@std@@2HB	; std::numeric_limits<char>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_W@std@@2HB	; std::numeric_limits<wchar_t>::max_digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_N@std@@2HB	; std::numeric_limits<bool>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?max_digits10@?$numeric_limits@C@std@@2HB	; std::numeric_limits<signed char>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?max_digits10@?$numeric_limits@E@std@@2HB	; std::numeric_limits<unsigned char>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?max_digits10@?$numeric_limits@F@std@@2HB	; std::numeric_limits<short>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?max_digits10@?$numeric_limits@G@std@@2HB	; std::numeric_limits<unsigned short>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?max_digits10@?$numeric_limits@H@std@@2HB	; std::numeric_limits<int>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?max_digits10@?$numeric_limits@I@std@@2HB	; std::numeric_limits<unsigned int>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?max_digits10@?$numeric_limits@J@std@@2HB	; std::numeric_limits<long>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?max_digits10@?$numeric_limits@K@std@@2HB	; std::numeric_limits<unsigned long>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_J@std@@2HB	; std::numeric_limits<__int64>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_K@std@@2HB	; std::numeric_limits<unsigned __int64>::max_digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?value@?$integral_constant@I$0A@@tr1@std@@2IB	; std::tr1::integral_constant<unsigned int,0>::value
PUBLIC	?_Rank@?$_Arithmetic_traits@_N@std@@2HB		; std::_Arithmetic_traits<bool>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@D@std@@2HB		; std::_Arithmetic_traits<char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@C@std@@2HB		; std::_Arithmetic_traits<signed char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@E@std@@2HB		; std::_Arithmetic_traits<unsigned char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@F@std@@2HB		; std::_Arithmetic_traits<short>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@G@std@@2HB		; std::_Arithmetic_traits<unsigned short>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@H@std@@2HB		; std::_Arithmetic_traits<int>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@I@std@@2HB		; std::_Arithmetic_traits<unsigned int>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@J@std@@2HB		; std::_Arithmetic_traits<long>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@K@std@@2HB		; std::_Arithmetic_traits<unsigned long>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@_J@std@@2HB		; std::_Arithmetic_traits<__int64>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@_K@std@@2HB		; std::_Arithmetic_traits<unsigned __int64>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@M@std@@2HB		; std::_Arithmetic_traits<float>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@N@std@@2HB		; std::_Arithmetic_traits<double>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@O@std@@2HB		; std::_Arithmetic_traits<long double>::_Rank
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
_DATA	SEGMENT
_PADDING DB	080H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@O@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@O@std@@2HB DD 09H		; std::_Arithmetic_traits<long double>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@N@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@N@std@@2HB DD 08H		; std::_Arithmetic_traits<double>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@M@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@M@std@@2HB DD 07H		; std::_Arithmetic_traits<float>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_K@std@@2HB DD 06H		; std::_Arithmetic_traits<unsigned __int64>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_J@std@@2HB DD 06H		; std::_Arithmetic_traits<__int64>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@K@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@K@std@@2HB DD 05H		; std::_Arithmetic_traits<unsigned long>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@J@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@J@std@@2HB DD 05H		; std::_Arithmetic_traits<long>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@I@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@I@std@@2HB DD 04H		; std::_Arithmetic_traits<unsigned int>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@H@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@H@std@@2HB DD 04H		; std::_Arithmetic_traits<int>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@G@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@G@std@@2HB DD 03H		; std::_Arithmetic_traits<unsigned short>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@F@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@F@std@@2HB DD 03H		; std::_Arithmetic_traits<short>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@E@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@E@std@@2HB DD 02H		; std::_Arithmetic_traits<unsigned char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@C@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@C@std@@2HB DD 02H		; std::_Arithmetic_traits<signed char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@D@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@D@std@@2HB DD 02H		; std::_Arithmetic_traits<char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_N@std@@2HB DD 01H		; std::_Arithmetic_traits<bool>::_Rank
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@tr1@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@tr1@std@@2IB DD 00H	; std::tr1::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 08H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_K@std@@2HB DD 015H	; std::numeric_limits<unsigned __int64>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_J@std@@2HB DD 014H	; std::numeric_limits<__int64>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@K@std@@2HB DD 0bH	; std::numeric_limits<unsigned long>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@J@std@@2HB DD 0bH	; std::numeric_limits<long>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@I@std@@2HB DD 0bH	; std::numeric_limits<unsigned int>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@H@std@@2HB DD 0bH	; std::numeric_limits<int>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@G@std@@2HB DD 06H	; std::numeric_limits<unsigned short>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@F@std@@2HB DD 06H	; std::numeric_limits<short>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@E@std@@2HB DD 04H	; std::numeric_limits<unsigned char>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@C@std@@2HB DD 04H	; std::numeric_limits<signed char>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_N@std@@2HB DD 00H	; std::numeric_limits<bool>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_W@std@@2HB DD 06H	; std::numeric_limits<wchar_t>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@D@std@@2HB DD 04H	; std::numeric_limits<char>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 01H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogsp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogsp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 07		 je	 SHORT $LN1@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	59		 pop	 ecx
$LN1@scalar:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
EXTRN	_strlen:PROC
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 490  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 492  : 		}

  00003	5d		 pop	 ebp

; 491  : 		return (_CSTD strlen(_First));

  00004	e9 00 00 00 00	 jmp	 _strlen
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
EXTRN	_memcpy:PROC
; Function compile flags: /Ogsp
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 496  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 498  : 		}

  00003	5d		 pop	 ebp

; 497  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00004	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
EXTRN	_memmove:PROC
; Function compile flags: /Ogsp
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 516  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 518  : 		}

  00003	5d		 pop	 ebp

; 517  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00004	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Ogsp
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 526  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 527  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 00		 mov	 al, BYTE PTR [eax]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000b	88 01		 mov	 BYTE PTR [ecx], al

; 528  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	??_7CMD5Checksum@@6B@				; CMD5Checksum::`vftable'
PUBLIC	??1CMD5Checksum@@MAE@XZ				; CMD5Checksum::~CMD5Checksum
PUBLIC	??_R4CMD5Checksum@@6B@				; CMD5Checksum::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMD5Checksum@@@8			; CMD5Checksum `RTTI Type Descriptor'
PUBLIC	??_R3CMD5Checksum@@8				; CMD5Checksum::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMD5Checksum@@8				; CMD5Checksum::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMD5Checksum@@8			; CMD5Checksum::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_ECMD5Checksum@@MAEPAXI@Z:PROC		; CMD5Checksum::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CMD5Checksum@@8
; File f:\projects\git\yfnet\trunk\src\include\md5.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CMD5Checksum@@8 DD FLAT:??_R0?AVCMD5Checksum@@@8 ; CMD5Checksum::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMD5Checksum@@8
rdata$r	ENDS
;	COMDAT ??_R2CMD5Checksum@@8
rdata$r	SEGMENT
??_R2CMD5Checksum@@8 DD FLAT:??_R1A@?0A@EA@CMD5Checksum@@8 ; CMD5Checksum::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMD5Checksum@@8
rdata$r	SEGMENT
??_R3CMD5Checksum@@8 DD 00H				; CMD5Checksum::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMD5Checksum@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMD5Checksum@@@8
_DATA	SEGMENT
??_R0?AVCMD5Checksum@@@8 DD FLAT:??_7type_info@@6B@	; CMD5Checksum `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMD5Checksum@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CMD5Checksum@@6B@
rdata$r	SEGMENT
??_R4CMD5Checksum@@6B@ DD 00H				; CMD5Checksum::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMD5Checksum@@@8
	DD	FLAT:??_R3CMD5Checksum@@8
rdata$r	ENDS
;	COMDAT ??_7CMD5Checksum@@6B@
CONST	SEGMENT
??_7CMD5Checksum@@6B@ DD FLAT:??_R4CMD5Checksum@@6B@	; CMD5Checksum::`vftable'
	DD	FLAT:??_ECMD5Checksum@@MAEPAXI@Z
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ??1CMD5Checksum@@MAE@XZ
_TEXT	SEGMENT
??1CMD5Checksum@@MAE@XZ PROC				; CMD5Checksum::~CMD5Checksum, COMDAT
; _this$ = ecx

; 121  : virtual ~CMD5Checksum() {};

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CMD5Checksum@@6B@
  00006	c3		 ret	 0
??1CMD5Checksum@@MAE@XZ ENDP				; CMD5Checksum::~CMD5Checksum
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??_GCMD5Checksum@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMD5Checksum@@MAEPAXI@Z PROC			; CMD5Checksum::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CMD5Checksum@@6B@
  00010	74 07		 je	 SHORT $LN1@scalar@2
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	59		 pop	 ecx
$LN1@scalar@2:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??_GCMD5Checksum@@MAEPAXI@Z ENDP			; CMD5Checksum::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?RotateLeft@CMD5Checksum@@IAEKKH@Z		; CMD5Checksum::RotateLeft
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\qvodbase\md5.cpp
;	COMDAT ?RotateLeft@CMD5Checksum@@IAEKKH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_n$ = 12						; size = 4
?RotateLeft@CMD5Checksum@@IAEKKH@Z PROC			; CMD5Checksum::RotateLeft, COMDAT
; _this$ = ecx

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	
; 48   : 	//rotate and return x
; 49   : 	return (x << n) | (x >> (32-n));

  00003	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  00009	d3 c0		 rol	 eax, cl

; 50   : }

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?RotateLeft@CMD5Checksum@@IAEKKH@Z ENDP			; CMD5Checksum::RotateLeft
_TEXT	ENDS
PUBLIC	?FF@CMD5Checksum@@IAEXAAKKKKKKK@Z		; CMD5Checksum::FF
; Function compile flags: /Ogsp
;	COMDAT ?FF@CMD5Checksum@@IAEXAAKKKKKKK@Z
_TEXT	SEGMENT
_A$ = 8							; size = 4
_B$ = 12						; size = 4
_C$ = 16						; size = 4
_D$ = 20						; size = 4
_X$ = 24						; size = 4
_S$ = 28						; size = 4
_T$ = 32						; size = 4
?FF@CMD5Checksum@@IAEXAAKKKKKKK@Z PROC			; CMD5Checksum::FF, COMDAT
; _this$ = ecx

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 53   : QVOD_DWORD F = (B & C) | (~B & D);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  00009	23 45 10	 and	 eax, DWORD PTR _C$[ebp]

; 54   : A += F + X + T;
; 55   : A = RotateLeft(A, S);

  0000c	8b 4d 1c	 mov	 ecx, DWORD PTR _S$[ebp]
  0000f	f7 d2		 not	 edx
  00011	23 55 14	 and	 edx, DWORD PTR _D$[ebp]
  00014	0b d0		 or	 edx, eax
  00016	03 55 18	 add	 edx, DWORD PTR _X$[ebp]
  00019	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  0001c	03 55 20	 add	 edx, DWORD PTR _T$[ebp]
  0001f	03 10		 add	 edx, DWORD PTR [eax]
  00021	d3 c2		 rol	 edx, cl

; 56   : A += B;

  00023	03 55 0c	 add	 edx, DWORD PTR _B$[ebp]
  00026	89 10		 mov	 DWORD PTR [eax], edx

; 57   : }

  00028	5d		 pop	 ebp
  00029	c2 1c 00	 ret	 28			; 0000001cH
?FF@CMD5Checksum@@IAEXAAKKKKKKK@Z ENDP			; CMD5Checksum::FF
_TEXT	ENDS
PUBLIC	?GG@CMD5Checksum@@IAEXAAKKKKKKK@Z		; CMD5Checksum::GG
; Function compile flags: /Ogsp
;	COMDAT ?GG@CMD5Checksum@@IAEXAAKKKKKKK@Z
_TEXT	SEGMENT
_A$ = 8							; size = 4
_B$ = 12						; size = 4
_C$ = 16						; size = 4
_D$ = 20						; size = 4
_X$ = 24						; size = 4
_S$ = 28						; size = 4
_T$ = 32						; size = 4
?GG@CMD5Checksum@@IAEXAAKKKKKKK@Z PROC			; CMD5Checksum::GG, COMDAT
; _this$ = ecx

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : QVOD_DWORD G = (B & D) | (C & ~D);

  00003	8b 55 14	 mov	 edx, DWORD PTR _D$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  00009	23 45 14	 and	 eax, DWORD PTR _D$[ebp]

; 61   : A += G + X + T;
; 62   : A = RotateLeft(A, S);

  0000c	8b 4d 1c	 mov	 ecx, DWORD PTR _S$[ebp]
  0000f	f7 d2		 not	 edx
  00011	23 55 10	 and	 edx, DWORD PTR _C$[ebp]
  00014	0b d0		 or	 edx, eax
  00016	03 55 18	 add	 edx, DWORD PTR _X$[ebp]
  00019	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  0001c	03 55 20	 add	 edx, DWORD PTR _T$[ebp]
  0001f	03 10		 add	 edx, DWORD PTR [eax]
  00021	d3 c2		 rol	 edx, cl

; 63   : A += B;

  00023	03 55 0c	 add	 edx, DWORD PTR _B$[ebp]
  00026	89 10		 mov	 DWORD PTR [eax], edx

; 64   : }

  00028	5d		 pop	 ebp
  00029	c2 1c 00	 ret	 28			; 0000001cH
?GG@CMD5Checksum@@IAEXAAKKKKKKK@Z ENDP			; CMD5Checksum::GG
_TEXT	ENDS
PUBLIC	?HH@CMD5Checksum@@IAEXAAKKKKKKK@Z		; CMD5Checksum::HH
; Function compile flags: /Ogsp
;	COMDAT ?HH@CMD5Checksum@@IAEXAAKKKKKKK@Z
_TEXT	SEGMENT
_A$ = 8							; size = 4
_B$ = 12						; size = 4
_C$ = 16						; size = 4
_D$ = 20						; size = 4
_X$ = 24						; size = 4
_S$ = 28						; size = 4
_T$ = 32						; size = 4
?HH@CMD5Checksum@@IAEXAAKKKKKKK@Z PROC			; CMD5Checksum::HH, COMDAT
; _this$ = ecx

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   : QVOD_DWORD H = (B ^ C ^ D);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _B$[ebp]
  00006	33 55 10	 xor	 edx, DWORD PTR _C$[ebp]

; 68   : A += H + X + T;

  00009	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  0000c	33 55 14	 xor	 edx, DWORD PTR _D$[ebp]

; 69   : A = RotateLeft(A, S);

  0000f	8b 4d 1c	 mov	 ecx, DWORD PTR _S$[ebp]
  00012	03 55 18	 add	 edx, DWORD PTR _X$[ebp]
  00015	03 55 20	 add	 edx, DWORD PTR _T$[ebp]
  00018	03 10		 add	 edx, DWORD PTR [eax]
  0001a	d3 c2		 rol	 edx, cl

; 70   : A += B;

  0001c	03 55 0c	 add	 edx, DWORD PTR _B$[ebp]
  0001f	89 10		 mov	 DWORD PTR [eax], edx

; 71   : }

  00021	5d		 pop	 ebp
  00022	c2 1c 00	 ret	 28			; 0000001cH
?HH@CMD5Checksum@@IAEXAAKKKKKKK@Z ENDP			; CMD5Checksum::HH
_TEXT	ENDS
PUBLIC	?II@CMD5Checksum@@IAEXAAKKKKKKK@Z		; CMD5Checksum::II
; Function compile flags: /Ogsp
;	COMDAT ?II@CMD5Checksum@@IAEXAAKKKKKKK@Z
_TEXT	SEGMENT
_A$ = 8							; size = 4
_B$ = 12						; size = 4
_C$ = 16						; size = 4
_D$ = 20						; size = 4
_X$ = 24						; size = 4
_S$ = 28						; size = 4
_T$ = 32						; size = 4
?II@CMD5Checksum@@IAEXAAKKKKKKK@Z PROC			; CMD5Checksum::II, COMDAT
; _this$ = ecx

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 74   : QVOD_DWORD I = (C ^ (B | ~D));

  00003	8b 55 14	 mov	 edx, DWORD PTR _D$[ebp]

; 75   : A += I + X + T;

  00006	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]

; 76   : A = RotateLeft(A, S);

  00009	8b 4d 1c	 mov	 ecx, DWORD PTR _S$[ebp]
  0000c	f7 d2		 not	 edx
  0000e	0b 55 0c	 or	 edx, DWORD PTR _B$[ebp]
  00011	33 55 10	 xor	 edx, DWORD PTR _C$[ebp]
  00014	03 55 18	 add	 edx, DWORD PTR _X$[ebp]
  00017	03 55 20	 add	 edx, DWORD PTR _T$[ebp]
  0001a	03 10		 add	 edx, DWORD PTR [eax]
  0001c	d3 c2		 rol	 edx, cl

; 77   : A += B;

  0001e	03 55 0c	 add	 edx, DWORD PTR _B$[ebp]
  00021	89 10		 mov	 DWORD PTR [eax], edx

; 78   : }

  00023	5d		 pop	 ebp
  00024	c2 1c 00	 ret	 28			; 0000001cH
?II@CMD5Checksum@@IAEXAAKKKKKKK@Z ENDP			; CMD5Checksum::II
_TEXT	ENDS
PUBLIC	?ByteToDWord@CMD5Checksum@@IAEXPAKPAEI@Z	; CMD5Checksum::ByteToDWord
; Function compile flags: /Ogsp
;	COMDAT ?ByteToDWord@CMD5Checksum@@IAEXPAKPAEI@Z
_TEXT	SEGMENT
_Output$ = 8						; size = 4
_Input$ = 12						; size = 4
_nLength$ = 16						; size = 4
?ByteToDWord@CMD5Checksum@@IAEXPAKPAEI@Z PROC		; CMD5Checksum::ByteToDWord, COMDAT
; _this$ = ecx

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 85   : QVOD_UINT j=0; //index to Input array
; 86   : 
; 87   : //transfer the data by shifting and copying
; 88   : for ( ; j < nLength; i++, j += 4)

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _nLength$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 3b		 je	 SHORT $LN1@ByteToDWor

; 81   : //entry invariants
; 82   : 
; 83   : //initialisations
; 84   : QVOD_UINT i=0; //index to Output array

  0000a	8b 45 0c	 mov	 eax, DWORD PTR _Input$[ebp]
  0000d	8b 55 08	 mov	 edx, DWORD PTR _Output$[ebp]
  00010	83 c0 02	 add	 eax, 2
  00013	49		 dec	 ecx
  00014	c1 e9 02	 shr	 ecx, 2
  00017	56		 push	 esi
  00018	41		 inc	 ecx
  00019	57		 push	 edi
$LL3@ByteToDWor:

; 89   : {
; 90   : Output[i] = (QVOD_ULONG)Input[j] |
; 91   : (QVOD_ULONG)Input[j+1] << 8 |
; 92   : (QVOD_ULONG)Input[j+2] << 16 |
; 93   : (QVOD_ULONG)Input[j+3] << 24;

  0001a	0f b6 70 01	 movzx	 esi, BYTE PTR [eax+1]
  0001e	0f b6 38	 movzx	 edi, BYTE PTR [eax]
  00021	c1 e6 08	 shl	 esi, 8
  00024	0b f7		 or	 esi, edi
  00026	0f b6 78 ff	 movzx	 edi, BYTE PTR [eax-1]
  0002a	c1 e6 08	 shl	 esi, 8
  0002d	0b f7		 or	 esi, edi
  0002f	0f b6 78 fe	 movzx	 edi, BYTE PTR [eax-2]
  00033	c1 e6 08	 shl	 esi, 8
  00036	0b f7		 or	 esi, edi
  00038	89 32		 mov	 DWORD PTR [edx], esi
  0003a	83 c2 04	 add	 edx, 4
  0003d	83 c0 04	 add	 eax, 4
  00040	49		 dec	 ecx
  00041	75 d7		 jne	 SHORT $LL3@ByteToDWor
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
$LN1@ByteToDWor:

; 94   : }
; 95   : }

  00045	5d		 pop	 ebp
  00046	c2 0c 00	 ret	 12			; 0000000cH
?ByteToDWord@CMD5Checksum@@IAEXPAKPAEI@Z ENDP		; CMD5Checksum::ByteToDWord
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?Transform@CMD5Checksum@@IAEXQAE@Z		; CMD5Checksum::Transform
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogsp
;	COMDAT ?Transform@CMD5Checksum@@IAEXQAE@Z
_TEXT	SEGMENT
tv1502 = -80						; size = 4
_b$ = -80						; size = 4
tv1869 = -76						; size = 4
tv1670 = -76						; size = 4
tv1511 = -76						; size = 4
_c$ = -76						; size = 4
_a$ = -72						; size = 4
_X$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_Block$ = 8						; size = 4
?Transform@CMD5Checksum@@IAEXQAE@Z PROC			; CMD5Checksum::Transform, COMDAT
; _this$ = ecx

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _Block$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 98   : //initialise local data with current checksum
; 99   : QVOD_ULONG a = m_lMD5[0];
; 100  : QVOD_ULONG b = m_lMD5[1];
; 101  : QVOD_ULONG c = m_lMD5[2];
; 102  : QVOD_ULONG d = m_lMD5[3];
; 103  : 
; 104  : //copy BYTES from input 'Block' to an array of ULONGS 'X'
; 105  : QVOD_ULONG X[16];
; 106  : ByteToDWord( X, Block, 64 );

  00016	6a 40		 push	 64			; 00000040H
  00018	50		 push	 eax
  00019	8b f1		 mov	 esi, ecx
  0001b	8b 7e 50	 mov	 edi, DWORD PTR [esi+80]
  0001e	8b 5e 54	 mov	 ebx, DWORD PTR [esi+84]
  00021	8d 45 bc	 lea	 eax, DWORD PTR _X$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?ByteToDWord@CMD5Checksum@@IAEXPAKPAEI@Z ; CMD5Checksum::ByteToDWord

; 107  : 
; 108  : //Perform Round 1 of the transformation
; 109  : FF (a, b, c, d, X[ 0], MD5_S11, MD5_T01); 

  0002a	8b 45 bc	 mov	 eax, DWORD PTR _X$[ebp]
  0002d	8b cf		 mov	 ecx, edi
  0002f	f7 d1		 not	 ecx
  00031	23 4e 58	 and	 ecx, DWORD PTR [esi+88]
  00034	8b d3		 mov	 edx, ebx
  00036	23 d7		 and	 edx, edi
  00038	0b ca		 or	 ecx, edx
  0003a	03 4e 4c	 add	 ecx, DWORD PTR [esi+76]
  0003d	8d 84 01 78 a4
	6a d7		 lea	 eax, DWORD PTR [ecx+eax-680876936]
  00044	c1 c0 07	 rol	 eax, 7
  00047	03 c7		 add	 eax, edi

; 110  : FF (d, a, b, c, X[ 1], MD5_S12, MD5_T02); 

  00049	8b d0		 mov	 edx, eax
  0004b	f7 d2		 not	 edx
  0004d	23 d3		 and	 edx, ebx
  0004f	8b cf		 mov	 ecx, edi
  00051	23 c8		 and	 ecx, eax
  00053	0b d1		 or	 edx, ecx
  00055	03 55 c0	 add	 edx, DWORD PTR _X$[ebp+4]
  00058	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  0005b	8d 8c 0a 56 b7
	c7 e8		 lea	 ecx, DWORD PTR [edx+ecx-389564586]
  00062	c1 c1 0c	 rol	 ecx, 12			; 0000000cH
  00065	03 c8		 add	 ecx, eax

; 111  : FF (c, d, a, b, X[ 2], MD5_S13, MD5_T03); 

  00067	8b d1		 mov	 edx, ecx
  00069	f7 d2		 not	 edx
  0006b	23 d7		 and	 edx, edi
  0006d	8b f9		 mov	 edi, ecx
  0006f	23 f8		 and	 edi, eax
  00071	0b d7		 or	 edx, edi
  00073	03 55 c4	 add	 edx, DWORD PTR _X$[ebp+8]
  00076	8d bc 1a db 70
	20 24		 lea	 edi, DWORD PTR [edx+ebx+606105819]
  0007d	c1 cf 0f	 ror	 edi, 15			; 0000000fH
  00080	03 f9		 add	 edi, ecx

; 112  : FF (b, c, d, a, X[ 3], MD5_S14, MD5_T04); 

  00082	8b df		 mov	 ebx, edi
  00084	f7 d3		 not	 ebx
  00086	23 d8		 and	 ebx, eax
  00088	8b d1		 mov	 edx, ecx
  0008a	23 d7		 and	 edx, edi
  0008c	0b da		 or	 ebx, edx
  0008e	03 5d c8	 add	 ebx, DWORD PTR _X$[ebp+12]
  00091	8b 56 50	 mov	 edx, DWORD PTR [esi+80]
  00094	8d 94 13 ee ce
	bd c1		 lea	 edx, DWORD PTR [ebx+edx-1044525330]
  0009b	c1 ca 0a	 ror	 edx, 10			; 0000000aH
  0009e	03 d7		 add	 edx, edi
  000a0	89 7d b4	 mov	 DWORD PTR _c$[ebp], edi

; 113  : FF (a, b, c, d, X[ 4], MD5_S11, MD5_T05); 

  000a3	23 fa		 and	 edi, edx
  000a5	8b da		 mov	 ebx, edx
  000a7	f7 d3		 not	 ebx
  000a9	23 d9		 and	 ebx, ecx
  000ab	0b df		 or	 ebx, edi
  000ad	03 5d cc	 add	 ebx, DWORD PTR _X$[ebp+16]

; 114  : FF (d, a, b, c, X[ 5], MD5_S12, MD5_T06); 

  000b0	8b fa		 mov	 edi, edx
  000b2	8d 84 03 af 0f
	7c f5		 lea	 eax, DWORD PTR [ebx+eax-176418897]
  000b9	c1 c0 07	 rol	 eax, 7
  000bc	03 c2		 add	 eax, edx
  000be	89 45 b8	 mov	 DWORD PTR _a$[ebp], eax
  000c1	23 7d b8	 and	 edi, DWORD PTR _a$[ebp]
  000c4	f7 d0		 not	 eax
  000c6	23 45 b4	 and	 eax, DWORD PTR _c$[ebp]
  000c9	0b c7		 or	 eax, edi
  000cb	03 45 d0	 add	 eax, DWORD PTR _X$[ebp+20]
  000ce	8d 8c 08 2a c6
	87 47		 lea	 ecx, DWORD PTR [eax+ecx+1200080426]
  000d5	c1 c1 0c	 rol	 ecx, 12			; 0000000cH
  000d8	03 4d b8	 add	 ecx, DWORD PTR _a$[ebp]

; 115  : FF (c, d, a, b, X[ 6], MD5_S13, MD5_T07); 

  000db	8b c1		 mov	 eax, ecx
  000dd	f7 d0		 not	 eax
  000df	8b f9		 mov	 edi, ecx
  000e1	23 7d b8	 and	 edi, DWORD PTR _a$[ebp]
  000e4	23 c2		 and	 eax, edx
  000e6	0b c7		 or	 eax, edi
  000e8	03 45 d4	 add	 eax, DWORD PTR _X$[ebp+24]
  000eb	8b 7d b4	 mov	 edi, DWORD PTR _c$[ebp]
  000ee	8d 84 38 13 46
	30 a8		 lea	 eax, DWORD PTR [eax+edi-1473231341]
  000f5	c1 c8 0f	 ror	 eax, 15			; 0000000fH
  000f8	03 c1		 add	 eax, ecx

; 116  : FF (b, c, d, a, X[ 7], MD5_S14, MD5_T08); 

  000fa	8b f8		 mov	 edi, eax
  000fc	f7 d7		 not	 edi
  000fe	23 7d b8	 and	 edi, DWORD PTR _a$[ebp]
  00101	8b d9		 mov	 ebx, ecx
  00103	23 d8		 and	 ebx, eax
  00105	0b fb		 or	 edi, ebx
  00107	03 7d d8	 add	 edi, DWORD PTR _X$[ebp+28]

; 117  : FF (a, b, c, d, X[ 8], MD5_S11, MD5_T09); 

  0010a	8b d8		 mov	 ebx, eax
  0010c	8d 94 17 01 95
	46 fd		 lea	 edx, DWORD PTR [edi+edx-45705983]
  00113	c1 ca 0a	 ror	 edx, 10			; 0000000aH
  00116	03 d0		 add	 edx, eax
  00118	23 da		 and	 ebx, edx
  0011a	8b fa		 mov	 edi, edx
  0011c	f7 d7		 not	 edi
  0011e	23 f9		 and	 edi, ecx
  00120	0b fb		 or	 edi, ebx
  00122	03 7d dc	 add	 edi, DWORD PTR _X$[ebp+32]
  00125	8b 5d b8	 mov	 ebx, DWORD PTR _a$[ebp]
  00128	8d bc 1f d8 98
	80 69		 lea	 edi, DWORD PTR [edi+ebx+1770035416]
  0012f	c1 c7 07	 rol	 edi, 7
  00132	03 fa		 add	 edi, edx
  00134	89 55 b0	 mov	 DWORD PTR _b$[ebp], edx

; 118  : FF (d, a, b, c, X[ 9], MD5_S12, MD5_T10); 

  00137	23 d7		 and	 edx, edi
  00139	8b df		 mov	 ebx, edi
  0013b	f7 d3		 not	 ebx
  0013d	23 d8		 and	 ebx, eax
  0013f	0b da		 or	 ebx, edx
  00141	03 5d e0	 add	 ebx, DWORD PTR _X$[ebp+36]
  00144	8d 8c 0b af f7
	44 8b		 lea	 ecx, DWORD PTR [ebx+ecx-1958414417]
  0014b	c1 c1 0c	 rol	 ecx, 12			; 0000000cH
  0014e	03 cf		 add	 ecx, edi

; 119  : FF (c, d, a, b, X[10], MD5_S13, MD5_T11); 

  00150	8b d1		 mov	 edx, ecx
  00152	f7 d2		 not	 edx
  00154	23 55 b0	 and	 edx, DWORD PTR _b$[ebp]
  00157	8b d9		 mov	 ebx, ecx
  00159	23 df		 and	 ebx, edi
  0015b	0b d3		 or	 edx, ebx
  0015d	03 55 e4	 add	 edx, DWORD PTR _X$[ebp+40]

; 120  : FF (b, c, d, a, X[11], MD5_S14, MD5_T12); 

  00160	8b d9		 mov	 ebx, ecx
  00162	8d 84 02 b1 5b
	ff ff		 lea	 eax, DWORD PTR [edx+eax-42063]
  00169	c1 c8 0f	 ror	 eax, 15			; 0000000fH
  0016c	03 c1		 add	 eax, ecx
  0016e	23 d8		 and	 ebx, eax
  00170	8b d0		 mov	 edx, eax
  00172	f7 d2		 not	 edx
  00174	23 d7		 and	 edx, edi
  00176	0b d3		 or	 edx, ebx
  00178	03 55 e8	 add	 edx, DWORD PTR _X$[ebp+44]
  0017b	8b 5d b0	 mov	 ebx, DWORD PTR _b$[ebp]
  0017e	8d 94 1a be d7
	5c 89		 lea	 edx, DWORD PTR [edx+ebx-1990404162]
  00185	c1 ca 0a	 ror	 edx, 10			; 0000000aH
  00188	03 d0		 add	 edx, eax
  0018a	89 45 b4	 mov	 DWORD PTR _c$[ebp], eax

; 121  : FF (a, b, c, d, X[12], MD5_S11, MD5_T13); 

  0018d	23 c2		 and	 eax, edx
  0018f	8b da		 mov	 ebx, edx
  00191	f7 d3		 not	 ebx
  00193	23 d9		 and	 ebx, ecx
  00195	0b d8		 or	 ebx, eax
  00197	03 5d ec	 add	 ebx, DWORD PTR _X$[ebp+48]

; 122  : FF (d, a, b, c, X[13], MD5_S12, MD5_T14); 

  0019a	8b c2		 mov	 eax, edx
  0019c	8d bc 3b 22 11
	90 6b		 lea	 edi, DWORD PTR [ebx+edi+1804603682]
  001a3	c1 c7 07	 rol	 edi, 7
  001a6	03 fa		 add	 edi, edx
  001a8	89 7d b8	 mov	 DWORD PTR _a$[ebp], edi
  001ab	23 45 b8	 and	 eax, DWORD PTR _a$[ebp]
  001ae	f7 d7		 not	 edi
  001b0	23 7d b4	 and	 edi, DWORD PTR _c$[ebp]
  001b3	0b f8		 or	 edi, eax
  001b5	03 7d f0	 add	 edi, DWORD PTR _X$[ebp+52]
  001b8	8d 8c 0f 93 71
	98 fd		 lea	 ecx, DWORD PTR [edi+ecx-40341101]
  001bf	c1 c1 0c	 rol	 ecx, 12			; 0000000cH
  001c2	03 4d b8	 add	 ecx, DWORD PTR _a$[ebp]

; 123  : FF (c, d, a, b, X[14], MD5_S13, MD5_T15); 

  001c5	89 4d b0	 mov	 DWORD PTR tv1502[ebp], ecx
  001c8	f7 55 b0	 not	 DWORD PTR tv1502[ebp]
  001cb	8b 45 b0	 mov	 eax, DWORD PTR tv1502[ebp]
  001ce	23 c2		 and	 eax, edx
  001d0	8b f9		 mov	 edi, ecx
  001d2	23 7d b8	 and	 edi, DWORD PTR _a$[ebp]

; 124  : FF (b, c, d, a, X[15], MD5_S14, MD5_T16); 

  001d5	8b d9		 mov	 ebx, ecx
  001d7	0b c7		 or	 eax, edi
  001d9	03 45 f4	 add	 eax, DWORD PTR _X$[ebp+56]
  001dc	8b 7d b4	 mov	 edi, DWORD PTR _c$[ebp]
  001df	8d 84 38 8e 43
	79 a6		 lea	 eax, DWORD PTR [eax+edi-1502002290]
  001e6	c1 c8 0f	 ror	 eax, 15			; 0000000fH
  001e9	03 c1		 add	 eax, ecx
  001eb	23 d8		 and	 ebx, eax
  001ed	89 45 b4	 mov	 DWORD PTR tv1511[ebp], eax
  001f0	f7 55 b4	 not	 DWORD PTR tv1511[ebp]
  001f3	8b 7d b4	 mov	 edi, DWORD PTR tv1511[ebp]
  001f6	23 7d b8	 and	 edi, DWORD PTR _a$[ebp]
  001f9	0b fb		 or	 edi, ebx
  001fb	03 7d f8	 add	 edi, DWORD PTR _X$[ebp+60]

; 125  : 
; 126  : //Perform Round 2 of the transformation
; 127  : GG (a, b, c, d, X[ 1], MD5_S21, MD5_T17); 

  001fe	8b d9		 mov	 ebx, ecx
  00200	8d 94 17 21 08
	b4 49		 lea	 edx, DWORD PTR [edi+edx+1236535329]
  00207	8b 7d b0	 mov	 edi, DWORD PTR tv1502[ebp]
  0020a	23 f8		 and	 edi, eax
  0020c	c1 ca 0a	 ror	 edx, 10			; 0000000aH
  0020f	03 d0		 add	 edx, eax
  00211	23 da		 and	 ebx, edx
  00213	0b fb		 or	 edi, ebx
  00215	03 7d c0	 add	 edi, DWORD PTR _X$[ebp+4]
  00218	8b 5d b8	 mov	 ebx, DWORD PTR _a$[ebp]
  0021b	8d bc 1f 62 25
	1e f6		 lea	 edi, DWORD PTR [edi+ebx-165796510]

; 128  : GG (d, a, b, c, X[ 6], MD5_S22, MD5_T18); 

  00222	8b 5d b4	 mov	 ebx, DWORD PTR tv1511[ebp]
  00225	c1 c7 05	 rol	 edi, 5
  00228	03 fa		 add	 edi, edx
  0022a	23 da		 and	 ebx, edx
  0022c	89 7d b8	 mov	 DWORD PTR _a$[ebp], edi
  0022f	89 5d b4	 mov	 DWORD PTR tv1869[ebp], ebx
  00232	8b d8		 mov	 ebx, eax
  00234	23 df		 and	 ebx, edi
  00236	8b 7d b4	 mov	 edi, DWORD PTR tv1869[ebp]
  00239	0b fb		 or	 edi, ebx
  0023b	03 7d d4	 add	 edi, DWORD PTR _X$[ebp+24]
  0023e	8d 8c 0f 40 b3
	40 c0		 lea	 ecx, DWORD PTR [edi+ecx-1069501632]
  00245	c1 c1 09	 rol	 ecx, 9
  00248	03 4d b8	 add	 ecx, DWORD PTR _a$[ebp]

; 129  : GG (c, d, a, b, X[11], MD5_S23, MD5_T19); 

  0024b	8b fa		 mov	 edi, edx
  0024d	f7 d7		 not	 edi
  0024f	23 7d b8	 and	 edi, DWORD PTR _a$[ebp]
  00252	8b d9		 mov	 ebx, ecx
  00254	23 da		 and	 ebx, edx
  00256	0b fb		 or	 edi, ebx
  00258	03 7d e8	 add	 edi, DWORD PTR _X$[ebp+44]

; 130  : GG (b, c, d, a, X[ 0], MD5_S24, MD5_T20); 
; 131  : GG (a, b, c, d, X[ 5], MD5_S21, MD5_T21); 

  0025b	8b d9		 mov	 ebx, ecx
  0025d	8d 84 07 51 5a
	5e 26		 lea	 eax, DWORD PTR [edi+eax+643717713]
  00264	8b 7d b8	 mov	 edi, DWORD PTR _a$[ebp]
  00267	c1 c0 0e	 rol	 eax, 14			; 0000000eH
  0026a	03 c1		 add	 eax, ecx
  0026c	89 45 b4	 mov	 DWORD PTR _c$[ebp], eax
  0026f	23 45 b8	 and	 eax, DWORD PTR _a$[ebp]
  00272	f7 d7		 not	 edi
  00274	23 f9		 and	 edi, ecx
  00276	0b f8		 or	 edi, eax
  00278	03 7d bc	 add	 edi, DWORD PTR _X$[ebp]
  0027b	8b c1		 mov	 eax, ecx
  0027d	f7 d0		 not	 eax
  0027f	8d 94 17 aa c7
	b6 e9		 lea	 edx, DWORD PTR [edi+edx-373897302]
  00286	8b 7d b4	 mov	 edi, DWORD PTR _c$[ebp]
  00289	23 c7		 and	 eax, edi
  0028b	c1 ca 0c	 ror	 edx, 12			; 0000000cH
  0028e	03 d7		 add	 edx, edi
  00290	23 da		 and	 ebx, edx
  00292	0b c3		 or	 eax, ebx
  00294	03 45 d0	 add	 eax, DWORD PTR _X$[ebp+20]
  00297	8b 5d b8	 mov	 ebx, DWORD PTR _a$[ebp]
  0029a	8d 84 18 5d 10
	2f d6		 lea	 eax, DWORD PTR [eax+ebx-701558691]
  002a1	c1 c0 05	 rol	 eax, 5
  002a4	03 c2		 add	 eax, edx
  002a6	89 45 b8	 mov	 DWORD PTR _a$[ebp], eax

; 132  : GG (d, a, b, c, X[10], MD5_S22, MD5_T22); 

  002a9	8b c7		 mov	 eax, edi
  002ab	f7 d0		 not	 eax
  002ad	8b df		 mov	 ebx, edi
  002af	23 5d b8	 and	 ebx, DWORD PTR _a$[ebp]
  002b2	23 c2		 and	 eax, edx
  002b4	0b c3		 or	 eax, ebx
  002b6	03 45 e4	 add	 eax, DWORD PTR _X$[ebp+40]
  002b9	8d 8c 08 53 14
	44 02		 lea	 ecx, DWORD PTR [eax+ecx+38016083]

; 133  : GG (c, d, a, b, X[15], MD5_S23, MD5_T23); 

  002c0	8b c2		 mov	 eax, edx
  002c2	c1 c1 09	 rol	 ecx, 9
  002c5	03 4d b8	 add	 ecx, DWORD PTR _a$[ebp]
  002c8	f7 d0		 not	 eax
  002ca	23 45 b8	 and	 eax, DWORD PTR _a$[ebp]
  002cd	8b d9		 mov	 ebx, ecx
  002cf	23 da		 and	 ebx, edx
  002d1	0b c3		 or	 eax, ebx
  002d3	03 45 f8	 add	 eax, DWORD PTR _X$[ebp+60]
  002d6	8d 84 38 81 e6
	a1 d8		 lea	 eax, DWORD PTR [eax+edi-660478335]

; 134  : GG (b, c, d, a, X[ 4], MD5_S24, MD5_T24); 

  002dd	8b 7d b8	 mov	 edi, DWORD PTR _a$[ebp]
  002e0	c1 c0 0e	 rol	 eax, 14			; 0000000eH
  002e3	03 c1		 add	 eax, ecx
  002e5	f7 d7		 not	 edi
  002e7	23 f9		 and	 edi, ecx
  002e9	8b d8		 mov	 ebx, eax
  002eb	23 5d b8	 and	 ebx, DWORD PTR _a$[ebp]
  002ee	0b fb		 or	 edi, ebx
  002f0	03 7d cc	 add	 edi, DWORD PTR _X$[ebp+16]

; 135  : GG (a, b, c, d, X[ 9], MD5_S21, MD5_T25); 

  002f3	8b d9		 mov	 ebx, ecx
  002f5	8d 94 17 c8 fb
	d3 e7		 lea	 edx, DWORD PTR [edi+edx-405537848]
  002fc	c1 ca 0c	 ror	 edx, 12			; 0000000cH
  002ff	03 d0		 add	 edx, eax
  00301	23 da		 and	 ebx, edx
  00303	89 55 b0	 mov	 DWORD PTR _b$[ebp], edx
  00306	8b f9		 mov	 edi, ecx
  00308	f7 d7		 not	 edi
  0030a	23 f8		 and	 edi, eax
  0030c	0b fb		 or	 edi, ebx
  0030e	03 7d e0	 add	 edi, DWORD PTR _X$[ebp+36]
  00311	8b 5d b8	 mov	 ebx, DWORD PTR _a$[ebp]
  00314	8d bc 1f e6 cd
	e1 21		 lea	 edi, DWORD PTR [edi+ebx+568446438]
  0031b	c1 c7 05	 rol	 edi, 5
  0031e	03 fa		 add	 edi, edx

; 136  : GG (d, a, b, c, X[14], MD5_S22, MD5_T26); 

  00320	8b d8		 mov	 ebx, eax
  00322	f7 d3		 not	 ebx
  00324	23 da		 and	 ebx, edx
  00326	8b d0		 mov	 edx, eax
  00328	23 d7		 and	 edx, edi
  0032a	0b da		 or	 ebx, edx
  0032c	03 5d f4	 add	 ebx, DWORD PTR _X$[ebp+56]

; 137  : GG (c, d, a, b, X[ 3], MD5_S23, MD5_T27); 

  0032f	8b 55 b0	 mov	 edx, DWORD PTR _b$[ebp]
  00332	f7 d2		 not	 edx
  00334	23 d7		 and	 edx, edi
  00336	8d 8c 0b d6 07
	37 c3		 lea	 ecx, DWORD PTR [ebx+ecx-1019803690]
  0033d	c1 c1 09	 rol	 ecx, 9
  00340	03 cf		 add	 ecx, edi
  00342	8b d9		 mov	 ebx, ecx
  00344	23 5d b0	 and	 ebx, DWORD PTR _b$[ebp]
  00347	0b d3		 or	 edx, ebx
  00349	03 55 c8	 add	 edx, DWORD PTR _X$[ebp+12]
  0034c	8d 84 02 87 0d
	d5 f4		 lea	 eax, DWORD PTR [edx+eax-187363961]
  00353	c1 c0 0e	 rol	 eax, 14			; 0000000eH
  00356	03 c1		 add	 eax, ecx

; 138  : GG (b, c, d, a, X[ 8], MD5_S24, MD5_T28); 

  00358	8b d7		 mov	 edx, edi
  0035a	f7 d2		 not	 edx
  0035c	23 d1		 and	 edx, ecx
  0035e	8b d8		 mov	 ebx, eax
  00360	23 df		 and	 ebx, edi
  00362	0b d3		 or	 edx, ebx
  00364	03 55 dc	 add	 edx, DWORD PTR _X$[ebp+32]
  00367	8b 5d b0	 mov	 ebx, DWORD PTR _b$[ebp]
  0036a	8d 94 1a ed 14
	5a 45		 lea	 edx, DWORD PTR [edx+ebx+1163531501]
  00371	c1 ca 0c	 ror	 edx, 12			; 0000000cH
  00374	03 d0		 add	 edx, eax
  00376	89 55 b0	 mov	 DWORD PTR _b$[ebp], edx

; 139  : GG (a, b, c, d, X[13], MD5_S21, MD5_T29); 

  00379	8b d1		 mov	 edx, ecx
  0037b	f7 d2		 not	 edx
  0037d	23 d0		 and	 edx, eax
  0037f	8b d9		 mov	 ebx, ecx
  00381	23 5d b0	 and	 ebx, DWORD PTR _b$[ebp]
  00384	0b d3		 or	 edx, ebx
  00386	03 55 f0	 add	 edx, DWORD PTR _X$[ebp+52]
  00389	8d bc 3a 05 e9
	e3 a9		 lea	 edi, DWORD PTR [edx+edi-1444681467]
  00390	c1 c7 05	 rol	 edi, 5
  00393	03 7d b0	 add	 edi, DWORD PTR _b$[ebp]

; 140  : GG (d, a, b, c, X[ 2], MD5_S22, MD5_T30); 

  00396	8b d0		 mov	 edx, eax
  00398	f7 d2		 not	 edx
  0039a	23 55 b0	 and	 edx, DWORD PTR _b$[ebp]
  0039d	89 7d b8	 mov	 DWORD PTR _a$[ebp], edi
  003a0	8b f8		 mov	 edi, eax
  003a2	23 7d b8	 and	 edi, DWORD PTR _a$[ebp]
  003a5	0b d7		 or	 edx, edi
  003a7	03 55 c4	 add	 edx, DWORD PTR _X$[ebp+8]
  003aa	8b 7d b8	 mov	 edi, DWORD PTR _a$[ebp]
  003ad	8d 8c 0a f8 a3
	ef fc		 lea	 ecx, DWORD PTR [edx+ecx-51403784]

; 141  : GG (c, d, a, b, X[ 7], MD5_S23, MD5_T31); 

  003b4	8b 55 b0	 mov	 edx, DWORD PTR _b$[ebp]
  003b7	c1 c1 09	 rol	 ecx, 9
  003ba	03 cf		 add	 ecx, edi
  003bc	f7 d2		 not	 edx
  003be	23 d7		 and	 edx, edi
  003c0	8b d9		 mov	 ebx, ecx
  003c2	23 5d b0	 and	 ebx, DWORD PTR _b$[ebp]
  003c5	0b d3		 or	 edx, ebx
  003c7	03 55 d8	 add	 edx, DWORD PTR _X$[ebp+28]
  003ca	8d 84 02 d9 02
	6f 67		 lea	 eax, DWORD PTR [edx+eax+1735328473]
  003d1	c1 c0 0e	 rol	 eax, 14			; 0000000eH
  003d4	03 c1		 add	 eax, ecx

; 142  : GG (b, c, d, a, X[12], MD5_S24, MD5_T32); 

  003d6	8b d7		 mov	 edx, edi
  003d8	f7 d2		 not	 edx
  003da	23 d1		 and	 edx, ecx
  003dc	8b d8		 mov	 ebx, eax
  003de	23 df		 and	 ebx, edi
  003e0	0b d3		 or	 edx, ebx
  003e2	03 55 ec	 add	 edx, DWORD PTR _X$[ebp+48]
  003e5	8b 5d b0	 mov	 ebx, DWORD PTR _b$[ebp]
  003e8	8d 94 1a 8a 4c
	2a 8d		 lea	 edx, DWORD PTR [edx+ebx-1926607734]
  003ef	c1 ca 0c	 ror	 edx, 12			; 0000000cH
  003f2	03 d0		 add	 edx, eax

; 143  : 
; 144  : //Perform Round 3 of the transformation
; 145  : HH (a, b, c, d, X[ 5], MD5_S31, MD5_T33); 

  003f4	8b d9		 mov	 ebx, ecx
  003f6	33 d8		 xor	 ebx, eax
  003f8	33 da		 xor	 ebx, edx
  003fa	03 5d d0	 add	 ebx, DWORD PTR _X$[ebp+20]
  003fd	8d bc 3b 42 39
	fa ff		 lea	 edi, DWORD PTR [ebx+edi-378558]
  00404	c1 c7 04	 rol	 edi, 4
  00407	03 fa		 add	 edi, edx

; 146  : HH (d, a, b, c, X[ 8], MD5_S32, MD5_T34); 

  00409	8b d8		 mov	 ebx, eax
  0040b	33 da		 xor	 ebx, edx
  0040d	33 df		 xor	 ebx, edi
  0040f	03 5d dc	 add	 ebx, DWORD PTR _X$[ebp+32]
  00412	8d 8c 0b 81 f6
	71 87		 lea	 ecx, DWORD PTR [ebx+ecx-2022574463]
  00419	c1 c1 0b	 rol	 ecx, 11			; 0000000bH
  0041c	03 cf		 add	 ecx, edi

; 147  : HH (c, d, a, b, X[11], MD5_S33, MD5_T35); 

  0041e	8b d9		 mov	 ebx, ecx
  00420	33 da		 xor	 ebx, edx
  00422	33 df		 xor	 ebx, edi
  00424	03 5d e8	 add	 ebx, DWORD PTR _X$[ebp+44]

; 148  : HH (b, c, d, a, X[14], MD5_S34, MD5_T36); 

  00427	89 4d b4	 mov	 DWORD PTR tv1670[ebp], ecx
  0042a	8d 84 03 22 61
	9d 6d		 lea	 eax, DWORD PTR [ebx+eax+1839030562]
  00431	c1 c0 10	 rol	 eax, 16			; 00000010H
  00434	03 c1		 add	 eax, ecx
  00436	31 45 b4	 xor	 DWORD PTR tv1670[ebp], eax
  00439	8b 5d b4	 mov	 ebx, DWORD PTR tv1670[ebp]
  0043c	33 df		 xor	 ebx, edi
  0043e	03 5d f4	 add	 ebx, DWORD PTR _X$[ebp+56]
  00441	8d 94 13 0c 38
	e5 fd		 lea	 edx, DWORD PTR [ebx+edx-35309556]

; 149  : HH (a, b, c, d, X[ 1], MD5_S31, MD5_T37); 

  00448	8b 5d b4	 mov	 ebx, DWORD PTR tv1670[ebp]
  0044b	c1 ca 09	 ror	 edx, 9
  0044e	03 d0		 add	 edx, eax
  00450	33 da		 xor	 ebx, edx
  00452	03 5d c0	 add	 ebx, DWORD PTR _X$[ebp+4]
  00455	8d bc 3b 44 ea
	be a4		 lea	 edi, DWORD PTR [ebx+edi-1530992060]
  0045c	c1 c7 04	 rol	 edi, 4
  0045f	03 fa		 add	 edi, edx

; 150  : HH (d, a, b, c, X[ 4], MD5_S32, MD5_T38); 

  00461	8b d8		 mov	 ebx, eax
  00463	33 da		 xor	 ebx, edx
  00465	33 df		 xor	 ebx, edi
  00467	03 5d cc	 add	 ebx, DWORD PTR _X$[ebp+16]
  0046a	8d 9c 0b a9 cf
	de 4b		 lea	 ebx, DWORD PTR [ebx+ecx+1272893353]
  00471	c1 c3 0b	 rol	 ebx, 11			; 0000000bH
  00474	03 df		 add	 ebx, edi

; 151  : HH (c, d, a, b, X[ 7], MD5_S33, MD5_T39); 

  00476	8b cb		 mov	 ecx, ebx
  00478	33 ca		 xor	 ecx, edx
  0047a	33 cf		 xor	 ecx, edi
  0047c	03 4d d8	 add	 ecx, DWORD PTR _X$[ebp+28]
  0047f	8d 84 01 60 4b
	bb f6		 lea	 eax, DWORD PTR [ecx+eax-155497632]
  00486	c1 c0 10	 rol	 eax, 16			; 00000010H
  00489	03 c3		 add	 eax, ebx

; 152  : HH (b, c, d, a, X[10], MD5_S34, MD5_T40); 

  0048b	8b cb		 mov	 ecx, ebx
  0048d	89 45 b4	 mov	 DWORD PTR _c$[ebp], eax
  00490	33 c8		 xor	 ecx, eax
  00492	8b c1		 mov	 eax, ecx
  00494	33 c7		 xor	 eax, edi
  00496	03 45 e4	 add	 eax, DWORD PTR _X$[ebp+40]
  00499	8d 84 10 70 bc
	bf be		 lea	 eax, DWORD PTR [eax+edx-1094730640]

; 153  : HH (a, b, c, d, X[13], MD5_S31, MD5_T41); 
; 154  : HH (d, a, b, c, X[ 0], MD5_S32, MD5_T42); 

  004a0	8b 55 b4	 mov	 edx, DWORD PTR _c$[ebp]
  004a3	c1 c8 09	 ror	 eax, 9
  004a6	03 45 b4	 add	 eax, DWORD PTR _c$[ebp]
  004a9	33 c8		 xor	 ecx, eax
  004ab	03 4d f0	 add	 ecx, DWORD PTR _X$[ebp+52]
  004ae	8d 8c 39 c6 7e
	9b 28		 lea	 ecx, DWORD PTR [ecx+edi+681279174]
  004b5	8b fa		 mov	 edi, edx
  004b7	33 f8		 xor	 edi, eax
  004b9	c1 c1 04	 rol	 ecx, 4
  004bc	03 c8		 add	 ecx, eax
  004be	33 f9		 xor	 edi, ecx
  004c0	03 7d bc	 add	 edi, DWORD PTR _X$[ebp]
  004c3	8d 9c 1f fa 27
	a1 ea		 lea	 ebx, DWORD PTR [edi+ebx-358537222]
  004ca	c1 c3 0b	 rol	 ebx, 11			; 0000000bH
  004cd	03 d9		 add	 ebx, ecx

; 155  : HH (c, d, a, b, X[ 3], MD5_S33, MD5_T43); 

  004cf	8b fb		 mov	 edi, ebx
  004d1	33 f8		 xor	 edi, eax
  004d3	33 f9		 xor	 edi, ecx
  004d5	03 7d c8	 add	 edi, DWORD PTR _X$[ebp+12]

; 156  : HH (b, c, d, a, X[ 6], MD5_S34, MD5_T44); 

  004d8	89 5d b4	 mov	 DWORD PTR tv1670[ebp], ebx
  004db	8d bc 17 85 30
	ef d4		 lea	 edi, DWORD PTR [edi+edx-722521979]
  004e2	c1 c7 10	 rol	 edi, 16			; 00000010H
  004e5	03 fb		 add	 edi, ebx
  004e7	31 7d b4	 xor	 DWORD PTR tv1670[ebp], edi
  004ea	8b 55 b4	 mov	 edx, DWORD PTR tv1670[ebp]
  004ed	33 d1		 xor	 edx, ecx
  004ef	03 55 d4	 add	 edx, DWORD PTR _X$[ebp+24]
  004f2	8d 84 02 05 1d
	88 04		 lea	 eax, DWORD PTR [edx+eax+76029189]

; 157  : HH (a, b, c, d, X[ 9], MD5_S31, MD5_T45); 

  004f9	8b 55 b4	 mov	 edx, DWORD PTR tv1670[ebp]
  004fc	c1 c8 09	 ror	 eax, 9
  004ff	03 c7		 add	 eax, edi
  00501	33 d0		 xor	 edx, eax
  00503	03 55 e0	 add	 edx, DWORD PTR _X$[ebp+36]
  00506	8d 8c 0a 39 d0
	d4 d9		 lea	 ecx, DWORD PTR [edx+ecx-640364487]
  0050d	c1 c1 04	 rol	 ecx, 4
  00510	03 c8		 add	 ecx, eax

; 158  : HH (d, a, b, c, X[12], MD5_S32, MD5_T46); 

  00512	8b d7		 mov	 edx, edi
  00514	33 d0		 xor	 edx, eax
  00516	33 d1		 xor	 edx, ecx
  00518	03 55 ec	 add	 edx, DWORD PTR _X$[ebp+48]
  0051b	8d 94 1a e5 99
	db e6		 lea	 edx, DWORD PTR [edx+ebx-421815835]
  00522	c1 c2 0b	 rol	 edx, 11			; 0000000bH
  00525	03 d1		 add	 edx, ecx

; 159  : HH (c, d, a, b, X[15], MD5_S33, MD5_T47); 

  00527	8b da		 mov	 ebx, edx
  00529	33 d8		 xor	 ebx, eax
  0052b	33 d9		 xor	 ebx, ecx
  0052d	03 5d f8	 add	 ebx, DWORD PTR _X$[ebp+60]
  00530	8d bc 3b f8 7c
	a2 1f		 lea	 edi, DWORD PTR [ebx+edi+530742520]
  00537	c1 c7 10	 rol	 edi, 16			; 00000010H
  0053a	03 fa		 add	 edi, edx

; 160  : HH (b, c, d, a, X[ 2], MD5_S34, MD5_T48); 

  0053c	8b da		 mov	 ebx, edx
  0053e	33 df		 xor	 ebx, edi
  00540	33 d9		 xor	 ebx, ecx
  00542	03 5d c4	 add	 ebx, DWORD PTR _X$[ebp+8]
  00545	8d 84 03 65 56
	ac c4		 lea	 eax, DWORD PTR [ebx+eax-995338651]
  0054c	c1 c8 09	 ror	 eax, 9
  0054f	03 c7		 add	 eax, edi

; 161  : 
; 162  : //Perform Round 4 of the transformation
; 163  : II (a, b, c, d, X[ 0], MD5_S41, MD5_T49); 

  00551	8b da		 mov	 ebx, edx
  00553	f7 d3		 not	 ebx
  00555	0b d8		 or	 ebx, eax
  00557	33 df		 xor	 ebx, edi
  00559	03 5d bc	 add	 ebx, DWORD PTR _X$[ebp]
  0055c	8d 8c 0b 44 22
	29 f4		 lea	 ecx, DWORD PTR [ebx+ecx-198630844]
  00563	c1 c1 06	 rol	 ecx, 6
  00566	03 c8		 add	 ecx, eax

; 164  : II (d, a, b, c, X[ 7], MD5_S42, MD5_T50); 

  00568	8b df		 mov	 ebx, edi
  0056a	f7 d3		 not	 ebx
  0056c	0b d9		 or	 ebx, ecx
  0056e	33 d8		 xor	 ebx, eax
  00570	03 5d d8	 add	 ebx, DWORD PTR _X$[ebp+28]
  00573	8d 94 13 97 ff
	2a 43		 lea	 edx, DWORD PTR [ebx+edx+1126891415]
  0057a	c1 c2 0a	 rol	 edx, 10			; 0000000aH

; 165  : II (c, d, a, b, X[14], MD5_S43, MD5_T51); 

  0057d	8b d8		 mov	 ebx, eax
  0057f	03 d1		 add	 edx, ecx
  00581	f7 d3		 not	 ebx
  00583	0b da		 or	 ebx, edx
  00585	33 d9		 xor	 ebx, ecx
  00587	03 5d f4	 add	 ebx, DWORD PTR _X$[ebp+56]
  0058a	8d bc 3b a7 23
	94 ab		 lea	 edi, DWORD PTR [ebx+edi-1416354905]
  00591	c1 c7 0f	 rol	 edi, 15			; 0000000fH
  00594	03 fa		 add	 edi, edx

; 166  : II (b, c, d, a, X[ 5], MD5_S44, MD5_T52); 

  00596	8b d9		 mov	 ebx, ecx
  00598	f7 d3		 not	 ebx
  0059a	0b df		 or	 ebx, edi
  0059c	33 da		 xor	 ebx, edx
  0059e	03 5d d0	 add	 ebx, DWORD PTR _X$[ebp+20]
  005a1	8d 84 03 39 a0
	93 fc		 lea	 eax, DWORD PTR [ebx+eax-57434055]
  005a8	c1 c8 0b	 ror	 eax, 11			; 0000000bH
  005ab	03 c7		 add	 eax, edi

; 167  : II (a, b, c, d, X[12], MD5_S41, MD5_T53); 

  005ad	8b da		 mov	 ebx, edx
  005af	f7 d3		 not	 ebx
  005b1	0b d8		 or	 ebx, eax
  005b3	33 df		 xor	 ebx, edi
  005b5	03 5d ec	 add	 ebx, DWORD PTR _X$[ebp+48]
  005b8	8d 8c 0b c3 59
	5b 65		 lea	 ecx, DWORD PTR [ebx+ecx+1700485571]
  005bf	c1 c1 06	 rol	 ecx, 6
  005c2	03 c8		 add	 ecx, eax

; 168  : II (d, a, b, c, X[ 3], MD5_S42, MD5_T54); 

  005c4	8b df		 mov	 ebx, edi
  005c6	f7 d3		 not	 ebx
  005c8	0b d9		 or	 ebx, ecx
  005ca	33 d8		 xor	 ebx, eax
  005cc	03 5d c8	 add	 ebx, DWORD PTR _X$[ebp+12]
  005cf	8d 94 13 92 cc
	0c 8f		 lea	 edx, DWORD PTR [ebx+edx-1894986606]
  005d6	c1 c2 0a	 rol	 edx, 10			; 0000000aH
  005d9	03 d1		 add	 edx, ecx

; 169  : II (c, d, a, b, X[10], MD5_S43, MD5_T55); 

  005db	8b d8		 mov	 ebx, eax
  005dd	f7 d3		 not	 ebx
  005df	0b da		 or	 ebx, edx
  005e1	33 d9		 xor	 ebx, ecx
  005e3	03 5d e4	 add	 ebx, DWORD PTR _X$[ebp+40]
  005e6	8d bc 3b 7d f4
	ef ff		 lea	 edi, DWORD PTR [ebx+edi-1051523]
  005ed	c1 c7 0f	 rol	 edi, 15			; 0000000fH
  005f0	03 fa		 add	 edi, edx

; 170  : II (b, c, d, a, X[ 1], MD5_S44, MD5_T56); 

  005f2	8b d9		 mov	 ebx, ecx
  005f4	f7 d3		 not	 ebx
  005f6	0b df		 or	 ebx, edi
  005f8	33 da		 xor	 ebx, edx
  005fa	03 5d c0	 add	 ebx, DWORD PTR _X$[ebp+4]
  005fd	8d 84 03 d1 5d
	84 85		 lea	 eax, DWORD PTR [ebx+eax-2054922799]
  00604	c1 c8 0b	 ror	 eax, 11			; 0000000bH
  00607	03 c7		 add	 eax, edi

; 171  : II (a, b, c, d, X[ 8], MD5_S41, MD5_T57); 

  00609	8b da		 mov	 ebx, edx
  0060b	f7 d3		 not	 ebx
  0060d	0b d8		 or	 ebx, eax
  0060f	33 df		 xor	 ebx, edi
  00611	03 5d dc	 add	 ebx, DWORD PTR _X$[ebp+32]
  00614	8d 8c 0b 4f 7e
	a8 6f		 lea	 ecx, DWORD PTR [ebx+ecx+1873313359]
  0061b	c1 c1 06	 rol	 ecx, 6
  0061e	03 c8		 add	 ecx, eax

; 172  : II (d, a, b, c, X[15], MD5_S42, MD5_T58); 

  00620	8b df		 mov	 ebx, edi
  00622	f7 d3		 not	 ebx
  00624	0b d9		 or	 ebx, ecx
  00626	33 d8		 xor	 ebx, eax
  00628	03 5d f8	 add	 ebx, DWORD PTR _X$[ebp+60]
  0062b	8d 94 13 e0 e6
	2c fe		 lea	 edx, DWORD PTR [ebx+edx-30611744]

; 173  : II (c, d, a, b, X[ 6], MD5_S43, MD5_T59); 

  00632	8b d8		 mov	 ebx, eax
  00634	f7 d3		 not	 ebx
  00636	c1 c2 0a	 rol	 edx, 10			; 0000000aH
  00639	03 d1		 add	 edx, ecx
  0063b	0b da		 or	 ebx, edx
  0063d	33 d9		 xor	 ebx, ecx
  0063f	03 5d d4	 add	 ebx, DWORD PTR _X$[ebp+24]
  00642	8d bc 3b 14 43
	01 a3		 lea	 edi, DWORD PTR [ebx+edi-1560198380]
  00649	c1 c7 0f	 rol	 edi, 15			; 0000000fH
  0064c	03 fa		 add	 edi, edx

; 174  : II (b, c, d, a, X[13], MD5_S44, MD5_T60); 

  0064e	8b d9		 mov	 ebx, ecx
  00650	f7 d3		 not	 ebx
  00652	0b df		 or	 ebx, edi
  00654	33 da		 xor	 ebx, edx
  00656	03 5d f0	 add	 ebx, DWORD PTR _X$[ebp+52]
  00659	8d 9c 03 a1 11
	08 4e		 lea	 ebx, DWORD PTR [ebx+eax+1309151649]
  00660	c1 cb 0b	 ror	 ebx, 11			; 0000000bH

; 175  : II (a, b, c, d, X[ 4], MD5_S41, MD5_T61); 

  00663	8b c2		 mov	 eax, edx
  00665	f7 d0		 not	 eax
  00667	03 df		 add	 ebx, edi
  00669	0b c3		 or	 eax, ebx
  0066b	33 c7		 xor	 eax, edi
  0066d	03 45 cc	 add	 eax, DWORD PTR _X$[ebp+16]
  00670	8d 84 08 82 7e
	53 f7		 lea	 eax, DWORD PTR [eax+ecx-145523070]
  00677	c1 c0 06	 rol	 eax, 6
  0067a	03 c3		 add	 eax, ebx

; 176  : II (d, a, b, c, X[11], MD5_S42, MD5_T62); 

  0067c	8b cf		 mov	 ecx, edi
  0067e	f7 d1		 not	 ecx
  00680	0b c8		 or	 ecx, eax
  00682	33 cb		 xor	 ecx, ebx
  00684	03 4d e8	 add	 ecx, DWORD PTR _X$[ebp+44]
  00687	8d 94 11 35 f2
	3a bd		 lea	 edx, DWORD PTR [ecx+edx-1120210379]
  0068e	c1 c2 0a	 rol	 edx, 10			; 0000000aH
  00691	03 d0		 add	 edx, eax

; 177  : II (c, d, a, b, X[ 2], MD5_S43, MD5_T63); 

  00693	8b cb		 mov	 ecx, ebx
  00695	f7 d1		 not	 ecx
  00697	0b ca		 or	 ecx, edx
  00699	33 c8		 xor	 ecx, eax
  0069b	03 4d c4	 add	 ecx, DWORD PTR _X$[ebp+8]
  0069e	8d bc 39 bb d2
	d7 2a		 lea	 edi, DWORD PTR [ecx+edi+718787259]

; 178  : II (b, c, d, a, X[ 9], MD5_S44, MD5_T64); 
; 179  : 
; 180  : //add the transformed values to the current checksum
; 181  : m_lMD5[0] += a;

  006a5	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  006a8	03 c8		 add	 ecx, eax
  006aa	f7 d0		 not	 eax
  006ac	c1 c7 0f	 rol	 edi, 15			; 0000000fH
  006af	03 fa		 add	 edi, edx
  006b1	0b c7		 or	 eax, edi
  006b3	33 c2		 xor	 eax, edx

; 182  : m_lMD5[1] += b;

  006b5	03 45 e0	 add	 eax, DWORD PTR _X$[ebp+36]
  006b8	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx

; 183  : m_lMD5[2] += c;
; 184  : m_lMD5[3] += d;
; 185  : }

  006bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006be	8d 84 18 91 d3
	86 eb		 lea	 eax, DWORD PTR [eax+ebx-343485551]
  006c5	c1 c8 0b	 ror	 eax, 11			; 0000000bH
  006c8	03 46 50	 add	 eax, DWORD PTR [esi+80]
  006cb	33 cd		 xor	 ecx, ebp
  006cd	03 c7		 add	 eax, edi
  006cf	89 46 50	 mov	 DWORD PTR [esi+80], eax
  006d2	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  006d5	03 c7		 add	 eax, edi
  006d7	89 46 54	 mov	 DWORD PTR [esi+84], eax
  006da	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  006dd	03 c2		 add	 eax, edx
  006df	5f		 pop	 edi
  006e0	89 46 58	 mov	 DWORD PTR [esi+88], eax
  006e3	5e		 pop	 esi
  006e4	5b		 pop	 ebx
  006e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006ea	c9		 leave
  006eb	c2 04 00	 ret	 4
?Transform@CMD5Checksum@@IAEXQAE@Z ENDP			; CMD5Checksum::Transform
_TEXT	ENDS
PUBLIC	??0CMD5Checksum@@IAE@XZ				; CMD5Checksum::CMD5Checksum
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT ??0CMD5Checksum@@IAE@XZ
_TEXT	SEGMENT
??0CMD5Checksum@@IAE@XZ PROC				; CMD5Checksum::CMD5Checksum, COMDAT
; _this$ = ecx

; 187  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 188  : // zero members
; 189  : memset( m_lpszBuffer, 0, 64 );

  00003	6a 40		 push	 64			; 00000040H
  00005	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00008	6a 00		 push	 0
  0000a	50		 push	 eax
  0000b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CMD5Checksum@@6B@
  00011	e8 00 00 00 00	 call	 _memset

; 190  : m_nCount[0] = m_nCount[1] = 0;

  00016	83 66 48 00	 and	 DWORD PTR [esi+72], 0
  0001a	83 66 44 00	 and	 DWORD PTR [esi+68], 0
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 191  : 
; 192  : // Load magic state initialization constants
; 193  : m_lMD5[0] = MD5_INIT_STATE_0;

  00021	c7 46 4c 01 23
	45 67		 mov	 DWORD PTR [esi+76], 1732584193 ; 67452301H

; 194  : m_lMD5[1] = MD5_INIT_STATE_1;

  00028	c7 46 50 89 ab
	cd ef		 mov	 DWORD PTR [esi+80], -271733879 ; efcdab89H

; 195  : m_lMD5[2] = MD5_INIT_STATE_2;

  0002f	c7 46 54 fe dc
	ba 98		 mov	 DWORD PTR [esi+84], -1732584194 ; 98badcfeH

; 196  : m_lMD5[3] = MD5_INIT_STATE_3;

  00036	c7 46 58 76 54
	32 10		 mov	 DWORD PTR [esi+88], 271733878 ; 10325476H

; 197  : }

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	c3		 ret	 0
??0CMD5Checksum@@IAE@XZ ENDP				; CMD5Checksum::CMD5Checksum
_TEXT	ENDS
PUBLIC	?DWordToByte@CMD5Checksum@@IAEXPAEPAKI@Z	; CMD5Checksum::DWordToByte
; Function compile flags: /Ogsp
;	COMDAT ?DWordToByte@CMD5Checksum@@IAEXPAEPAKI@Z
_TEXT	SEGMENT
_Output$ = 8						; size = 4
_Input$ = 12						; size = 4
_nLength$ = 16						; size = 4
?DWordToByte@CMD5Checksum@@IAEXPAEPAKI@Z PROC		; CMD5Checksum::DWordToByte, COMDAT
; _this$ = ecx

; 199  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 	QVOD_UINT j = 0;
; 205  : 	for ( ; j < nLength; i++, j += 4) 

  00003	8b 55 10	 mov	 edx, DWORD PTR _nLength$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 32		 je	 SHORT $LN1@DWordToByt

; 200  : 	//entry invariants
; 201  : 	
; 202  : 	//transfer the data by shifting and copying
; 203  : 	QVOD_UINT i = 0;

  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _Output$[ebp]
  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Input$[ebp]
  00010	56		 push	 esi
  00011	8d 72 ff	 lea	 esi, DWORD PTR [edx-1]
  00014	c1 ee 02	 shr	 esi, 2
  00017	41		 inc	 ecx
  00018	83 c0 02	 add	 eax, 2
  0001b	46		 inc	 esi
$LL3@DWordToByt:

; 206  : 	{
; 207  : 		Output[j] = (QVOD_UCHAR)(Input[i] & 0xff);

  0001c	8a 50 fe	 mov	 dl, BYTE PTR [eax-2]
  0001f	88 51 ff	 mov	 BYTE PTR [ecx-1], dl

; 208  : 		Output[j+1] = (QVOD_UCHAR)((Input[i] >> 8) & 0xff);

  00022	8a 50 ff	 mov	 dl, BYTE PTR [eax-1]
  00025	88 11		 mov	 BYTE PTR [ecx], dl

; 209  : 		Output[j+2] = (QVOD_UCHAR)((Input[i] >> 16) & 0xff);

  00027	8a 10		 mov	 dl, BYTE PTR [eax]
  00029	88 51 01	 mov	 BYTE PTR [ecx+1], dl

; 210  : 		Output[j+3] = (QVOD_UCHAR)((Input[i] >> 24) & 0xff);

  0002c	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002f	88 51 02	 mov	 BYTE PTR [ecx+2], dl
  00032	83 c0 04	 add	 eax, 4
  00035	83 c1 04	 add	 ecx, 4
  00038	4e		 dec	 esi
  00039	75 e1		 jne	 SHORT $LL3@DWordToByt
  0003b	5e		 pop	 esi
$LN1@DWordToByt:

; 211  : 	}
; 212  : }

  0003c	5d		 pop	 ebp
  0003d	c2 0c 00	 ret	 12			; 0000000cH
?DWordToByte@CMD5Checksum@@IAEXPAEPAKI@Z ENDP		; CMD5Checksum::DWordToByte
_TEXT	ENDS
PUBLIC	?Update@CMD5Checksum@@IAEXPAEK@Z		; CMD5Checksum::Update
; Function compile flags: /Ogsp
;	COMDAT ?Update@CMD5Checksum@@IAEXPAEK@Z
_TEXT	SEGMENT
_Input$ = 8						; size = 4
_i$ = 12						; size = 4
_nInputLen$ = 12					; size = 4
?Update@CMD5Checksum@@IAEXPAEK@Z PROC			; CMD5Checksum::Update, COMDAT
; _this$ = ecx

; 252  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 253  : 	//Compute number of bytes mod 64
; 254  : 	QVOD_UINT nIndex = (QVOD_UINT)((m_nCount[0] >> 3) & 0x3F);

  00007	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  0000a	57		 push	 edi

; 255  : 	
; 256  : 	//Update number of bits
; 257  : 	if ( ( m_nCount[0] += nInputLen << 3 ) < ( nInputLen << 3) )

  0000b	8b 7d 0c	 mov	 edi, DWORD PTR _nInputLen$[ebp]
  0000e	8b c1		 mov	 eax, ecx
  00010	c1 e8 03	 shr	 eax, 3
  00013	8b d7		 mov	 edx, edi
  00015	8d 0c f9	 lea	 ecx, DWORD PTR [ecx+edi*8]
  00018	c1 e2 03	 shl	 edx, 3
  0001b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0001e	89 4e 44	 mov	 DWORD PTR [esi+68], ecx
  00021	3b ca		 cmp	 ecx, edx
  00023	73 03		 jae	 SHORT $LN6@Update

; 258  : 	{
; 259  : 		m_nCount[1]++;

  00025	ff 46 48	 inc	 DWORD PTR [esi+72]
$LN6@Update:

; 260  : 	}
; 261  : 	m_nCount[1] += (nInputLen >> 29);
; 262  : 	
; 263  : 	//Transform as many times as possible.
; 264  : 	QVOD_UINT i=0;
; 265  : 	QVOD_UINT nPartLen = 64 - nIndex;

  00028	6a 40		 push	 64			; 00000040H
  0002a	8b cf		 mov	 ecx, edi
  0002c	c1 e9 1d	 shr	 ecx, 29			; 0000001dH
  0002f	01 4e 48	 add	 DWORD PTR [esi+72], ecx
  00032	5b		 pop	 ebx
  00033	2b d8		 sub	 ebx, eax

; 266  : 	if (nInputLen >= nPartLen) 

  00035	3b fb		 cmp	 edi, ebx
  00037	72 42		 jb	 SHORT $LN5@Update

; 267  : 	{
; 268  : 		memcpy( &m_lpszBuffer[nIndex], Input, nPartLen );

  00039	53		 push	 ebx
  0003a	ff 75 08	 push	 DWORD PTR _Input$[ebp]
  0003d	8d 44 30 04	 lea	 eax, DWORD PTR [eax+esi+4]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _memcpy
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 269  : 		Transform( m_lpszBuffer );

  0004a	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0004d	50		 push	 eax
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?Transform@CMD5Checksum@@IAEXQAE@Z ; CMD5Checksum::Transform

; 270  : 		for (i = nPartLen; i + 63 < nInputLen; i += 64) 

  00055	89 5d 0c	 mov	 DWORD PTR _i$[ebp], ebx
  00058	83 c3 3f	 add	 ebx, 63			; 0000003fH
  0005b	eb 16		 jmp	 SHORT $LN11@Update
$LL4@Update:
  0005d	8b 45 08	 mov	 eax, DWORD PTR _Input$[ebp]
  00060	8d 44 18 c1	 lea	 eax, DWORD PTR [eax+ebx-63]

; 271  : 		{
; 272  : 			Transform( &Input[i] );

  00064	50		 push	 eax
  00065	8b ce		 mov	 ecx, esi
  00067	e8 00 00 00 00	 call	 ?Transform@CMD5Checksum@@IAEXQAE@Z ; CMD5Checksum::Transform
  0006c	83 45 0c 40	 add	 DWORD PTR _i$[ebp], 64	; 00000040H
  00070	83 c3 40	 add	 ebx, 64			; 00000040H
$LN11@Update:

; 270  : 		for (i = nPartLen; i + 63 < nInputLen; i += 64) 

  00073	3b df		 cmp	 ebx, edi
  00075	72 e6		 jb	 SHORT $LL4@Update

; 273  : 		}
; 274  : 		nIndex = 0;

  00077	33 c0		 xor	 eax, eax

; 275  : 	} 
; 276  : 	else 

  00079	eb 04		 jmp	 SHORT $LN1@Update
$LN5@Update:

; 277  : 	{
; 278  : 		i = 0;

  0007b	83 65 0c 00	 and	 DWORD PTR _i$[ebp], 0
$LN1@Update:

; 279  : 	}
; 280  : 	
; 281  : 	// Buffer remaining input
; 282  : 	memcpy( &m_lpszBuffer[nIndex], &Input[i], nInputLen-i);

  0007f	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  00082	2b f9		 sub	 edi, ecx
  00084	03 4d 08	 add	 ecx, DWORD PTR _Input$[ebp]
  00087	57		 push	 edi
  00088	51		 push	 ecx
  00089	8d 44 30 04	 lea	 eax, DWORD PTR [eax+esi+4]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _memcpy
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx

; 283  : }

  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
?Update@CMD5Checksum@@IAEXPAEK@Z ENDP			; CMD5Checksum::Update
_TEXT	ENDS
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1511 : 		return (this->_Mysize);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1512 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogsp
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2009 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2010 : 			: this->_Bx._Buf);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2011 : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 2009 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2010 : 			: this->_Bx._Buf);

  00009	8b c1		 mov	 eax, ecx

; 2011 : 		}

  0000b	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 459  : 		}

  00000	c3		 ret	 0
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Ogsp
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$ = ecx

; 1905 : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1906 : 		return (this->_Alval);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1907 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogsp
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2003 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2004 : 			: this->_Bx._Buf);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr@2
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2005 : 		}

  00008	c3		 ret	 0
$LN3@Myptr@2:

; 2003 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2004 : 			: this->_Bx._Buf);

  00009	8b c1		 mov	 eax, ecx

; 2005 : 		}

  0000b	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2020 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 183  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1972 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1973 : 		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + this->_Mysize <= _Ptr)

  00003	83 7d 08 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00007	74 2c		 je	 SHORT $LN2@Inside
  00009	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0000c	83 fa 10	 cmp	 edx, 16			; 00000010H
  0000f	72 04		 jb	 SHORT $LN8@Inside
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	eb 02		 jmp	 SHORT $LN9@Inside
$LN8@Inside:
  00015	8b c1		 mov	 eax, ecx
$LN9@Inside:
  00017	39 45 08	 cmp	 DWORD PTR __Ptr$[ebp], eax
  0001a	72 19		 jb	 SHORT $LN2@Inside
  0001c	83 fa 10	 cmp	 edx, 16			; 00000010H
  0001f	72 04		 jb	 SHORT $LN12@Inside
  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	eb 02		 jmp	 SHORT $LN13@Inside
$LN12@Inside:
  00025	8b c1		 mov	 eax, ecx
$LN13@Inside:
  00027	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0002a	03 c8		 add	 ecx, eax
  0002c	3b 4d 08	 cmp	 ecx, DWORD PTR __Ptr$[ebp]
  0002f	76 04		 jbe	 SHORT $LN2@Inside

; 1975 : 		else
; 1976 : 			return (true);

  00031	b0 01		 mov	 al, 1
  00033	eb 02		 jmp	 SHORT $LN1@Inside
$LN2@Inside:

; 1974 : 			return (false);	// don't ask

  00035	32 c0		 xor	 al, al
$LN1@Inside:

; 1977 : 		}

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2015 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	83 c8 ff	 or	 eax, -1

; 220  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogsp
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T52922 = -12						; size = 12
$T52927 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;

  00003	33 c0		 xor	 eax, eax
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 32   : 
; 33   : 	if (_Count <= 0)

  00008	39 45 08	 cmp	 DWORD PTR __Count$[ebp], eax

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000b	76 38		 jbe	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000d	83 7d 08 ff	 cmp	 DWORD PTR __Count$[ebp], -1
  00011	77 0d		 ja	 SHORT $LN1@Allocate
  00013	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00016	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001b	59		 pop	 ecx
  0001c	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0001e	75 25		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00020	83 65 08 00	 and	 DWORD PTR $T52927[ebp], 0
  00024	8d 45 08	 lea	 eax, DWORD PTR $T52927[ebp]
  00027	50		 push	 eax
  00028	8d 4d f4	 lea	 ecx, DWORD PTR $T52922[ebp]
  0002b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00030	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00035	8d 45 f4	 lea	 eax, DWORD PTR $T52922[ebp]
  00038	50		 push	 eax
  00039	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T52922[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00040	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  00045	c9		 leave
  00046	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00014	8b c6		 mov	 eax, esi
  00016	5e		 pop	 esi
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator==<char,char>
; Function compile flags: /Ogsp
;	COMDAT ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator==<char,char>, COMDAT

; 263  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 264  : 	}

  00002	c3		 ret	 0
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator==<char,char>
_TEXT	ENDS
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 454  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 455  : 		}

  00002	c2 04 00	 ret	 4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogsp
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1952 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1953 : 		_Traits::assign(_Myptr()[this->_Mysize = _Newsize], _Elem());

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0000a	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000d	72 02		 jb	 SHORT $LN5@Eos
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN5@Eos:
  00011	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1954 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogsp
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1108 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 1109 : 		if (this->_Mysize < _Off)

  00007	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0000d	3b c1		 cmp	 eax, ecx
  0000f	73 0a		 jae	 SHORT $LN3@erase

; 1110 : 			_Xran();	// _Off off end

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00016	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN28@erase:
$LN3@erase:

; 1111 : 		if (this->_Mysize - _Off < _Count)

  0001b	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0001e	2b c1		 sub	 eax, ecx
  00020	3b c3		 cmp	 eax, ebx
  00022	73 02		 jae	 SHORT $LN2@erase

; 1112 : 			_Count = this->_Mysize - _Off;	// trim _Count

  00024	8b d8		 mov	 ebx, eax
$LN2@erase:

; 1113 : 		if (0 < _Count)

  00026	85 db		 test	 ebx, ebx
  00028	74 46		 je	 SHORT $LN25@erase

; 1114 : 			{	// move elements down
; 1115 : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 1116 : 				this->_Mysize - _Off - _Count);

  0002a	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0002d	57		 push	 edi
  0002e	83 fa 10	 cmp	 edx, 16			; 00000010H
  00031	72 04		 jb	 SHORT $LN11@erase
  00033	8b 3e		 mov	 edi, DWORD PTR [esi]
  00035	eb 02		 jmp	 SHORT $LN12@erase
$LN11@erase:
  00037	8b fe		 mov	 edi, esi
$LN12@erase:
  00039	83 fa 10	 cmp	 edx, 16			; 00000010H
  0003c	72 04		 jb	 SHORT $LN15@erase
  0003e	8b 16		 mov	 edx, DWORD PTR [esi]
  00040	eb 02		 jmp	 SHORT $LN16@erase
$LN15@erase:
  00042	8b d6		 mov	 edx, esi
$LN16@erase:
  00044	2b c3		 sub	 eax, ebx
  00046	03 f9		 add	 edi, ecx
  00048	50		 push	 eax
  00049	03 fb		 add	 edi, ebx
  0004b	03 d1		 add	 edx, ecx
  0004d	57		 push	 edi
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 _memmove

; 1117 : 			size_type _Newsize = this->_Mysize - _Count;

  00054	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	2b c3		 sub	 eax, ebx

; 1118 : 			_Eos(_Newsize);

  0005c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00060	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00063	5f		 pop	 edi
  00064	72 04		 jb	 SHORT $LN23@erase
  00066	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00068	eb 02		 jmp	 SHORT $LN24@erase
$LN23@erase:
  0006a	8b ce		 mov	 ecx, esi
$LN24@erase:
  0006c	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
$LN25@erase:

; 1119 : 			}
; 1120 : 		return (*this);

  00070	8b c6		 mov	 eax, esi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx

; 1121 : 		}

  00074	5d		 pop	 ebp
  00075	c2 08 00	 ret	 8
$LN27@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogsp
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1516 : 		size_type _Num = this->_Alval.max_size();
; 1517 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	6a fe		 push	 -2			; fffffffeH
  00002	58		 pop	 eax

; 1518 : 		}

  00003	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 188  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
PUBLIC	??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator!=<char,char>
; Function compile flags: /Ogsp
;	COMDAT ??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator!=<char,char>, COMDAT

; 271  : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 272  : 	}

  00002	c3		 ret	 0
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator!=<char,char>
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1987 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1988 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 20		 je	 SHORT $LN9@Tidy

; 1989 : 			;
; 1990 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 1a		 jb	 SHORT $LN9@Tidy

; 1991 : 			{	// copy any leftovers to small buffer and deallocate
; 1992 : 			_Elem *_Ptr = this->_Bx._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 1993 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN7@Tidy

; 1994 : 				_Traits::copy(this->_Bx._Buf, _Ptr, _Newsize);

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@Tidy:

; 1995 : 			this->_Alval.deallocate(_Ptr, this->_Myres + 1);

  00028	53		 push	 ebx
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	59		 pop	 ecx
  0002f	5b		 pop	 ebx
$LN9@Tidy:

; 1996 : 			}
; 1997 : 		this->_Myres = this->_BUF_SIZE - 1;
; 1998 : 		_Eos(_Newsize);

  00030	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00033	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0003a	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi

; 1999 : 		}

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__EH_epilog3:PROC
EXTRN	__EH_prolog3_catch:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
tv296 = -20						; size = 4
__Newres$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1918 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	6a 0c		 push	 12			; 0000000cH
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_catch
  0000c	8b f1		 mov	 esi, ecx
  0000e	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi

; 1919 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00011	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  00014	83 cf 0f	 or	 edi, 15			; 0000000fH

; 1920 : 		if (max_size() < _Newres)

  00017	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0001a	76 05		 jbe	 SHORT $LN9@Copy

; 1921 : 			_Newres = _Newsize;	// undo roundup if too big

  0001c	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0001f	eb 27		 jmp	 SHORT $LN5@Copy
$LN9@Copy:

; 1922 : 		else if (this->_Myres / 2 <= _Newres / 3)

  00021	33 d2		 xor	 edx, edx
  00023	6a 03		 push	 3
  00025	8b c7		 mov	 eax, edi
  00027	5b		 pop	 ebx
  00028	f7 f3		 div	 ebx
  0002a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0002d	89 4d ec	 mov	 DWORD PTR tv296[ebp], ecx
  00030	d1 6d ec	 shr	 DWORD PTR tv296[ebp], 1
  00033	8b 55 ec	 mov	 edx, DWORD PTR tv296[ebp]
  00036	3b d0		 cmp	 edx, eax
  00038	76 0e		 jbe	 SHORT $LN5@Copy

; 1923 : 			;
; 1924 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

  0003a	6a fe		 push	 -2			; fffffffeH
  0003c	5f		 pop	 edi
  0003d	8b c7		 mov	 eax, edi
  0003f	2b c2		 sub	 eax, edx
  00041	3b c8		 cmp	 ecx, eax
  00043	77 03		 ja	 SHORT $LN5@Copy

; 1925 : 			_Newres = this->_Myres
; 1926 : 				+ this->_Myres / 2;	// grow exponentially if possible

  00045	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]
$LN5@Copy:

; 1927 : 		else
; 1928 : 			_Newres = max_size();	// settle for max_size()
; 1929 : 
; 1930 : 		_Elem *_Ptr;
; 1931 : 		_TRY_BEGIN

  00048	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1932 : 			_Ptr = this->_Alval.allocate(_Newres + 1);

  0004c	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0004f	6a 00		 push	 0
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>
  00057	59		 pop	 ecx
  00058	59		 pop	 ecx
  00059	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  0005c	eb 27		 jmp	 SHORT $LN19@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 1933 : 		_CATCH_ALL
; 1934 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  0005e	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00061	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00064	89 45 ec	 mov	 DWORD PTR __Newres$[ebp], eax

; 1935 : 			_TRY_BEGIN
; 1936 : 				_Ptr = this->_Alval.allocate(_Newres + 1);

  00067	40		 inc	 eax
  00068	6a 00		 push	 0
  0006a	50		 push	 eax
  0006b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  0006f	e8 00 00 00 00	 call	 ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>
  00074	59		 pop	 ecx
  00075	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  00078	59		 pop	 ecx

; 1940 : 			_CATCH_END
; 1941 : 		_CATCH_END

  00079	b8 00 00 00 00	 mov	 eax, $LN63@Copy
  0007e	c3		 ret	 0
$LN63@Copy:
  0007f	8b 75 e8	 mov	 esi, DWORD PTR _this$[ebp]
  00082	8b 7d ec	 mov	 edi, DWORD PTR __Newres$[ebp]
$LN19@Copy:

; 1942 : 
; 1943 : 		if (0 < _Oldlen)

  00085	8b 5d 0c	 mov	 ebx, DWORD PTR __Oldlen$[ebp]
  00088	85 db		 test	 ebx, ebx
  0008a	74 19		 je	 SHORT $LN52@Copy

; 1944 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

  0008c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00090	72 04		 jb	 SHORT $LN50@Copy
  00092	8b 06		 mov	 eax, DWORD PTR [esi]
  00094	eb 02		 jmp	 SHORT $LN51@Copy
$LN50@Copy:
  00096	8b c6		 mov	 eax, esi
$LN51@Copy:
  00098	53		 push	 ebx
  00099	50		 push	 eax
  0009a	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0009d	e8 00 00 00 00	 call	 _memcpy
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN52@Copy:

; 1945 : 		_Tidy(true);

  000a5	6a 00		 push	 0
  000a7	6a 01		 push	 1
  000a9	8b ce		 mov	 ecx, esi
  000ab	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1946 : 		this->_Bx._Ptr = _Ptr;

  000b0	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000b3	89 06		 mov	 DWORD PTR [esi], eax

; 1947 : 		this->_Myres = _Newres;

  000b5	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 1948 : 		_Eos(_Oldlen);

  000b8	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000bb	83 ff 10	 cmp	 edi, 16			; 00000010H
  000be	73 02		 jae	 SHORT $LN59@Copy
  000c0	8b c6		 mov	 eax, esi
$LN59@Copy:
  000c2	c6 04 18 00	 mov	 BYTE PTR [eax+ebx], 0

; 1949 : 		}

  000c6	e8 00 00 00 00	 call	 __EH_epilog3
  000cb	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 1937 : 			_CATCH_ALL
; 1938 : 			_Tidy(true);	// failed again, discard storage and reraise

  000ce	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	33 f6		 xor	 esi, esi
  000d3	56		 push	 esi
  000d4	6a 01		 push	 1
  000d6	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1939 : 			_RERAISE;

  000db	56		 push	 esi
  000dc	56		 push	 esi
  000dd	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN67@Copy:
$LN66@Copy:
  000e2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 550  : 		{	// construct empty string

  00000	8b c1		 mov	 eax, ecx

; 551  : 		_Tidy();

  00002	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00006	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
  0000d	c6 00 00	 mov	 BYTE PTR [eax], 0

; 552  : 		}

  00010	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogsp
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 753  : 		_Tidy(true);

  00000	6a 00		 push	 0
  00002	6a 01		 push	 1
  00004	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 754  : 		}

  00009	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Ogsp
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1958 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1959 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0000a	76 0a		 jbe	 SHORT $LN6@Grow

; 1960 : 			_Xlen();	// result too long

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN31@Grow:
$LN6@Grow:

; 1961 : 		if (this->_Myres < _Newsize)

  00016	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00019	3b c6		 cmp	 eax, esi
  0001b	73 0b		 jae	 SHORT $LN5@Grow

; 1962 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

  0001d	ff 71 10	 push	 DWORD PTR [ecx+16]
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00026	eb 2f		 jmp	 SHORT $LN28@Grow
$LN5@Grow:

; 1963 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00028	33 d2		 xor	 edx, edx
  0002a	38 55 0c	 cmp	 BYTE PTR __Trim$[ebp], dl
  0002d	74 18		 je	 SHORT $LN3@Grow
  0002f	83 fe 10	 cmp	 esi, 16			; 00000010H
  00032	73 13		 jae	 SHORT $LN3@Grow

; 1964 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1965 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

  00034	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00037	3b f0		 cmp	 esi, eax
  00039	73 02		 jae	 SHORT $LN9@Grow
  0003b	8b c6		 mov	 eax, esi
$LN9@Grow:
  0003d	50		 push	 eax
  0003e	6a 01		 push	 1
  00040	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00045	eb 10		 jmp	 SHORT $LN28@Grow
$LN3@Grow:

; 1966 : 		else if (_Newsize == 0)

  00047	3b f2		 cmp	 esi, edx
  00049	75 0c		 jne	 SHORT $LN28@Grow

; 1967 : 			_Eos(0);	// new size is zero, just null terminate

  0004b	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0004e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00051	72 02		 jb	 SHORT $LN26@Grow
  00053	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN26@Grow:
  00055	88 11		 mov	 BYTE PTR [ecx], dl
$LN28@Grow:

; 1968 : 		return (0 < _Newsize);	// return true only if more work to do

  00057	33 c0		 xor	 eax, eax
  00059	3b c6		 cmp	 eax, esi
  0005b	1b c0		 sbb	 eax, eax
  0005d	f7 d8		 neg	 eax
  0005f	5e		 pop	 esi

; 1969 : 		}

  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
$LN30@Grow:
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogsp
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 798  : 		{	// append _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 799  : 		if (_Right.size() < _Roff)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	3b 45 0c	 cmp	 eax, DWORD PTR __Roff$[ebp]
  00010	73 0a		 jae	 SHORT $LN4@append

; 800  : 			_Xran();	// _Roff off end

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00017	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN36@append:
$LN4@append:

; 801  : 		size_type _Num = _Right.size() - _Roff;

  0001c	2b 45 0c	 sub	 eax, DWORD PTR __Roff$[ebp]

; 802  : 		if (_Num < _Count)

  0001f	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp]
  00022	3b c3		 cmp	 eax, ebx
  00024	73 02		 jae	 SHORT $LN3@append

; 803  : 			_Count = _Num;	// trim _Count to size

  00026	8b d8		 mov	 ebx, eax
$LN3@append:

; 804  : 		if (npos - this->_Mysize <= _Count)

  00028	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002b	83 c9 ff	 or	 ecx, -1
  0002e	2b c8		 sub	 ecx, eax
  00030	3b cb		 cmp	 ecx, ebx
  00032	77 0a		 ja	 SHORT $LN2@append

; 805  : 			_Xlen();	// result too long

  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00039	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN37@append:
$LN2@append:

; 806  : 
; 807  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

  0003e	85 db		 test	 ebx, ebx
  00040	74 50		 je	 SHORT $LN32@append
  00042	57		 push	 edi
  00043	8d 3c 18	 lea	 edi, DWORD PTR [eax+ebx]
  00046	6a 00		 push	 0
  00048	57		 push	 edi
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00050	84 c0		 test	 al, al
  00052	74 3d		 je	 SHORT $LN34@append

; 808  : 			{	// make room and append new stuff
; 809  : 			_Traits::copy(_Myptr() + this->_Mysize,
; 810  : 				_Right._Myptr() + _Roff, _Count);

  00054	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00057	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0005b	72 02		 jb	 SHORT $LN18@append
  0005d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN18@append:
  0005f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00063	72 04		 jb	 SHORT $LN22@append
  00065	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00067	eb 02		 jmp	 SHORT $LN23@append
$LN22@append:
  00069	8b ce		 mov	 ecx, esi
$LN23@append:
  0006b	03 45 0c	 add	 eax, DWORD PTR __Roff$[ebp]
  0006e	53		 push	 ebx
  0006f	50		 push	 eax
  00070	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00073	03 c1		 add	 eax, ecx
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _memcpy
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 811  : 			_Eos(_Num);

  0007e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00082	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00085	72 04		 jb	 SHORT $LN30@append
  00087	8b 06		 mov	 eax, DWORD PTR [esi]
  00089	eb 02		 jmp	 SHORT $LN31@append
$LN30@append:
  0008b	8b c6		 mov	 eax, esi
$LN31@append:
  0008d	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN34@append:
  00091	5f		 pop	 edi
$LN32@append:

; 812  : 			}
; 813  : 		return (*this);

  00092	8b c6		 mov	 eax, esi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx

; 814  : 		}

  00096	5d		 pop	 ebp
  00097	c2 0c 00	 ret	 12			; 0000000cH
$LN35@append:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogsp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 892  : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 893  : 		if (_Right.size() < _Roff)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  00010	57		 push	 edi
  00011	3b c1		 cmp	 eax, ecx
  00013	73 0a		 jae	 SHORT $LN5@assign

; 894  : 			_Xran();	// _Roff off end

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0001a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN34@assign:
$LN5@assign:

; 895  : 		size_type _Num = _Right.size() - _Roff;

  0001f	2b c1		 sub	 eax, ecx
  00021	8b f8		 mov	 edi, eax

; 896  : 		if (_Count < _Num)

  00023	39 7d 10	 cmp	 DWORD PTR __Count$[ebp], edi
  00026	73 03		 jae	 SHORT $LN4@assign

; 897  : 			_Num = _Count;	// trim _Num to size

  00028	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
$LN4@assign:

; 898  : 
; 899  : 		if (this == &_Right)

  0002b	3b f3		 cmp	 esi, ebx
  0002d	75 1a		 jne	 SHORT $LN3@assign

; 900  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0002f	03 f9		 add	 edi, ecx
  00031	6a ff		 push	 -1
  00033	57		 push	 edi
  00034	8b ce		 mov	 ecx, esi
  00036	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0003b	ff 75 0c	 push	 DWORD PTR __Roff$[ebp]
  0003e	8b ce		 mov	 ecx, esi
  00040	6a 00		 push	 0
  00042	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00047	eb 47		 jmp	 SHORT $LN31@assign
$LN3@assign:

; 901  : 		else if (_Grow(_Num))

  00049	6a 00		 push	 0
  0004b	57		 push	 edi
  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00053	84 c0		 test	 al, al
  00055	74 39		 je	 SHORT $LN31@assign

; 902  : 			{	// make room and assign new stuff
; 903  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

  00057	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  0005b	72 04		 jb	 SHORT $LN17@assign
  0005d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0005f	eb 02		 jmp	 SHORT $LN18@assign
$LN17@assign:
  00061	8b c3		 mov	 eax, ebx
$LN18@assign:
  00063	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00067	72 04		 jb	 SHORT $LN21@assign
  00069	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0006b	eb 02		 jmp	 SHORT $LN22@assign
$LN21@assign:
  0006d	8b ce		 mov	 ecx, esi
$LN22@assign:
  0006f	03 45 0c	 add	 eax, DWORD PTR __Roff$[ebp]
  00072	57		 push	 edi
  00073	50		 push	 eax
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _memcpy
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 904  : 			_Eos(_Num);

  0007d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00081	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00084	72 04		 jb	 SHORT $LN29@assign
  00086	8b 06		 mov	 eax, DWORD PTR [esi]
  00088	eb 02		 jmp	 SHORT $LN30@assign
$LN29@assign:
  0008a	8b c6		 mov	 eax, esi
$LN30@assign:
  0008c	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN31@assign:

; 905  : 			}
; 906  : 		return (*this);

  00090	5f		 pop	 edi
  00091	8b c6		 mov	 eax, esi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx

; 907  : 		}

  00095	5d		 pop	 ebp
  00096	c2 0c 00	 ret	 12			; 0000000cH
$LN33@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogsp
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 817  : 		{	// append [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 818  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 819  : 		if (_Count != 0)
; 820  : 			_DEBUG_POINTER(_Ptr);
; 821  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 822  : 
; 823  : 		if (_Inside(_Ptr))

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
  00010	84 c0		 test	 al, al
  00012	74 1c		 je	 SHORT $LN3@append@2

; 824  : 			return (append(*this, _Ptr - _Myptr(), _Count));	// substring

  00014	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00018	72 04		 jb	 SHORT $LN8@append@2
  0001a	8b 06		 mov	 eax, DWORD PTR [esi]
  0001c	eb 02		 jmp	 SHORT $LN9@append@2
$LN8@append@2:
  0001e	8b c6		 mov	 eax, esi
$LN9@append@2:
  00020	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00023	2b f8		 sub	 edi, eax
  00025	57		 push	 edi
  00026	56		 push	 esi
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0002e	eb 63		 jmp	 SHORT $LN4@append@2
$LN3@append@2:

; 825  : 		if (npos - this->_Mysize <= _Count)

  00030	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00033	83 c9 ff	 or	 ecx, -1
  00036	53		 push	 ebx
  00037	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0003a	2b c8		 sub	 ecx, eax
  0003c	3b cb		 cmp	 ecx, ebx
  0003e	77 0a		 ja	 SHORT $LN2@append@2

; 826  : 			_Xlen();	// result too long

  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00045	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN28@append@2:
$LN2@append@2:

; 827  : 
; 828  : 		size_type _Num;
; 829  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

  0004a	85 db		 test	 ebx, ebx
  0004c	74 42		 je	 SHORT $LN25@append@2
  0004e	8d 3c 18	 lea	 edi, DWORD PTR [eax+ebx]
  00051	6a 00		 push	 0
  00053	57		 push	 edi
  00054	8b ce		 mov	 ecx, esi
  00056	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  0005b	84 c0		 test	 al, al
  0005d	74 31		 je	 SHORT $LN25@append@2

; 830  : 			{	// make room and append new stuff
; 831  : 			_Traits::copy(_Myptr() + this->_Mysize, _Ptr, _Count);

  0005f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00063	72 04		 jb	 SHORT $LN15@append@2
  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	eb 02		 jmp	 SHORT $LN16@append@2
$LN15@append@2:
  00069	8b c6		 mov	 eax, esi
$LN16@append@2:
  0006b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0006e	53		 push	 ebx
  0006f	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00072	03 c8		 add	 ecx, eax
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _memcpy
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 832  : 			_Eos(_Num);

  0007d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00081	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00084	72 04		 jb	 SHORT $LN23@append@2
  00086	8b 06		 mov	 eax, DWORD PTR [esi]
  00088	eb 02		 jmp	 SHORT $LN24@append@2
$LN23@append@2:
  0008a	8b c6		 mov	 eax, esi
$LN24@append@2:
  0008c	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN25@append@2:

; 833  : 			}
; 834  : 		return (*this);

  00090	8b c6		 mov	 eax, esi
  00092	5b		 pop	 ebx
$LN4@append@2:
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi

; 835  : 		}

  00095	5d		 pop	 ebp
  00096	c2 08 00	 ret	 8
$LN27@append@2:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogsp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 886  : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 887  : 		return (assign(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 888  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogsp
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 838  : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 839  : 		_DEBUG_POINTER(_Ptr);
; 840  : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00004	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 _strlen
  0000e	59		 pop	 ecx
  0000f	50		 push	 eax
  00010	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0001a	5e		 pop	 esi

; 841  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogsp
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 762  : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 763  : 		return (assign(_Right));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 764  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogsp
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 782  : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 783  : 		return (append(_Ptr));

  00004	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 _strlen
  0000e	59		 pop	 ecx
  0000f	50		 push	 eax
  00010	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0001a	5e		 pop	 esi

; 784  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogsp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 713  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 714  : 		if (this == &_Right)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	3b fe		 cmp	 edi, esi
  0000c	74 41		 je	 SHORT $LN43@assign@2

; 715  : 			;
; 716  : 		else if (get_allocator() != _Right.get_allocator()
; 717  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 718  : 			*this = _Right;
; 719  : 		else
; 720  : 			{	// not same, clear this and steal from _Right
; 721  : 			_Tidy(true);

  0000e	6a 00		 push	 0
  00010	6a 01		 push	 1
  00012	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 722  : 			if (_Right._Myres < this->_BUF_SIZE)

  00017	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0001b	73 11		 jae	 SHORT $LN2@assign@2

; 723  : 				_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 724  : 					_Right._Mysize + 1);

  0001d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00020	40		 inc	 eax
  00021	50		 push	 eax
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	e8 00 00 00 00	 call	 _memmove
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH

; 725  : 			else

  0002c	eb 07		 jmp	 SHORT $LN1@assign@2
$LN2@assign@2:

; 726  : 				{	// copy pointer
; 727  : 				this->_Bx._Ptr = _Right._Bx._Ptr;

  0002e	8b 06		 mov	 eax, DWORD PTR [esi]
  00030	89 07		 mov	 DWORD PTR [edi], eax

; 728  : 				_Right._Bx._Ptr = 0;

  00032	83 26 00	 and	 DWORD PTR [esi], 0
$LN1@assign@2:

; 729  : 				}
; 730  : 			this->_Mysize = _Right._Mysize;

  00035	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00038	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 731  : 			this->_Myres = _Right._Myres;

  0003b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0003e	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 732  : 
; 733  : 			_Right._Tidy();

  00041	83 66 10 00	 and	 DWORD PTR [esi+16], 0
  00045	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0004c	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN43@assign@2:

; 734  : 			}
; 735  : 		return (*this);

  0004f	8b c7		 mov	 eax, edi
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 736  : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogsp
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 702  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 703  : 		_Tidy();
; 704  : 		assign(_STD forward<_Myt>(_Right));

  00004	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	83 66 10 00	 and	 DWORD PTR [esi+16], 0
  0000d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00014	c6 06 00	 mov	 BYTE PTR [esi], 0
  00017	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 705  : 		}

  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??_C@_02NJNOFBBI@?$CFx?$AA@			; `string'
PUBLIC	??_C@_03PHPAKPLH@0?$CFx?$AA@			; `string'
PUBLIC	??_C@_02PLJDPFIO@00?$AA@			; `string'
PUBLIC	?Final@CMD5Checksum@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CMD5Checksum::Final
EXTRN	_sprintf:PROC
EXTRN	_strcpy:PROC
EXTRN	__EH_epilog3_GS:PROC
EXTRN	__EH_prolog3_GS:PROC
;	COMDAT ??_C@_02NJNOFBBI@?$CFx?$AA@
CONST	SEGMENT
??_C@_02NJNOFBBI@?$CFx?$AA@ DB '%x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PHPAKPLH@0?$CFx?$AA@
CONST	SEGMENT
??_C@_03PHPAKPLH@0?$CFx?$AA@ DB '0%x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02PLJDPFIO@00?$AA@
CONST	SEGMENT
??_C@_02PLJDPFIO@00?$AA@ DB '00', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Final@CMD5Checksum@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Final@CMD5Checksum@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0
__ehfuncinfo$?Final@CMD5Checksum@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Final@CMD5Checksum@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\qvodbase\md5.cpp
xdata$x	ENDS
;	COMDAT ?Final@CMD5Checksum@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_strMD5$ = -76						; size = 28
_lpszMD5$ = -48						; size = 16
_Bits$ = -32						; size = 8
_str$49171 = -24					; size = 8
$T53660 = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?Final@CMD5Checksum@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; CMD5Checksum::Final, COMDAT
; _this$ = ecx

; 214  : {

  00000	6a 40		 push	 64			; 00000040H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?Final@CMD5Checksum@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  0000f	83 65 ec 00	 and	 DWORD PTR $T53660[ebp], 0
  00013	8b f1		 mov	 esi, ecx

; 215  : 	//Save number of bits
; 216  : 	QVOD_BYTE Bits[8];
; 217  : 	DWordToByte( Bits, m_nCount, 8 );

  00015	6a 08		 push	 8
  00017	8d 7e 44	 lea	 edi, DWORD PTR [esi+68]
  0001a	57		 push	 edi
  0001b	8d 45 e0	 lea	 eax, DWORD PTR _Bits$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?DWordToByte@CMD5Checksum@@IAEXPAEPAKI@Z ; CMD5Checksum::DWordToByte

; 218  : 	
; 219  : 	//Pad out to 56 mod 64.
; 220  : 	QVOD_UINT nIndex = (QVOD_UINT)((m_nCount[0] >> 3) & 0x3f);

  00024	8b 07		 mov	 eax, DWORD PTR [edi]
  00026	c1 e8 03	 shr	 eax, 3

; 221  : 	QVOD_UINT nPadLen = (nIndex < 56) ? (56 - nIndex) : (120 - nIndex);

  00029	6a 38		 push	 56			; 00000038H
  0002b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0002e	59		 pop	 ecx
  0002f	3b c1		 cmp	 eax, ecx
  00031	72 03		 jb	 SHORT $LN84@Final
  00033	6a 78		 push	 120			; 00000078H
  00035	59		 pop	 ecx
$LN84@Final:
  00036	2b c8		 sub	 ecx, eax

; 222  : 	Update( PADDING, nPadLen );

  00038	51		 push	 ecx
  00039	68 00 00 00 00	 push	 OFFSET _PADDING
  0003e	8b ce		 mov	 ecx, esi
  00040	e8 00 00 00 00	 call	 ?Update@CMD5Checksum@@IAEXPAEK@Z ; CMD5Checksum::Update

; 223  : 	
; 224  : 	//Append length (before padding)
; 225  : 	Update( Bits, 8 );

  00045	6a 08		 push	 8
  00047	8d 45 e0	 lea	 eax, DWORD PTR _Bits$[ebp]
  0004a	50		 push	 eax
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ?Update@CMD5Checksum@@IAEXPAEK@Z ; CMD5Checksum::Update

; 226  : 	
; 227  : 	//Store final state in 'lpszMD5'
; 228  : 	const int nMD5Size = 16;
; 229  : 	unsigned char lpszMD5[ nMD5Size ];
; 230  : 	DWordToByte( lpszMD5, m_lMD5, nMD5Size );

  00052	6a 10		 push	 16			; 00000010H
  00054	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  00057	50		 push	 eax
  00058	8d 45 d0	 lea	 eax, DWORD PTR _lpszMD5$[ebp]
  0005b	50		 push	 eax
  0005c	8b ce		 mov	 ecx, esi
  0005e	e8 00 00 00 00	 call	 ?DWordToByte@CMD5Checksum@@IAEXPAEPAKI@Z ; CMD5Checksum::DWordToByte

; 231  : 	
; 232  : 	//Convert the hexadecimal checksum to a std::string
; 233  : 	std::string strMD5;

  00063	6a 0f		 push	 15			; 0000000fH
  00065	5e		 pop	 esi
  00066	33 ff		 xor	 edi, edi
  00068	89 75 c8	 mov	 DWORD PTR _strMD5$[ebp+20], esi
  0006b	89 7d c4	 mov	 DWORD PTR _strMD5$[ebp+16], edi
  0006e	c6 45 b4 00	 mov	 BYTE PTR _strMD5$[ebp], 0
  00072	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
$LL7@Final:

; 234  : 	for ( int i=0; i < nMD5Size; i++) 
; 235  : 	{
; 236  : 		char str[8];
; 237  : 		if (lpszMD5[i] == 0) {

  00075	8a 44 3d d0	 mov	 al, BYTE PTR _lpszMD5$[ebp+edi]
  00079	84 c0		 test	 al, al
  0007b	75 12		 jne	 SHORT $LN4@Final

; 238  : 			strcpy(str,"00");

  0007d	8d 45 e8	 lea	 eax, DWORD PTR _str$49171[ebp]
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_02PLJDPFIO@00?$AA@
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 _strcpy
  0008b	59		 pop	 ecx
  0008c	59		 pop	 ecx
  0008d	eb 20		 jmp	 SHORT $LN1@Final
$LN4@Final:

; 239  : 		}
; 240  : 		else if (lpszMD5[i] <= 15) {

  0008f	3c 0f		 cmp	 al, 15			; 0000000fH

; 241  : 			sprintf(str,"0%x",lpszMD5[i]);

  00091	0f b6 c0	 movzx	 eax, al
  00094	50		 push	 eax
  00095	8d 45 e8	 lea	 eax, DWORD PTR _str$49171[ebp]
  00098	77 07		 ja	 SHORT $LN2@Final
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_03PHPAKPLH@0?$CFx?$AA@

; 242  : 		}
; 243  : 		else {

  0009f	eb 05		 jmp	 SHORT $LN85@Final
$LN2@Final:

; 244  : 			sprintf(str,"%x",lpszMD5[i]);

  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
$LN85@Final:
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 _sprintf
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Final:

; 245  : 		}
; 246  : 		
; 247  : 		strMD5 += str;

  000af	8d 45 e8	 lea	 eax, DWORD PTR _str$49171[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 _strlen
  000b8	59		 pop	 ecx
  000b9	50		 push	 eax
  000ba	8d 45 e8	 lea	 eax, DWORD PTR _str$49171[ebp]
  000bd	50		 push	 eax
  000be	8d 4d b4	 lea	 ecx, DWORD PTR _strMD5$[ebp]
  000c1	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  000c6	47		 inc	 edi
  000c7	83 ff 10	 cmp	 edi, 16			; 00000010H
  000ca	7c a9		 jl	 SHORT $LL7@Final

; 248  : 	}
; 249  : 	return strMD5;

  000cc	83 63 10 00	 and	 DWORD PTR [ebx+16], 0
  000d0	8d 45 b4	 lea	 eax, DWORD PTR _strMD5$[ebp]
  000d3	89 73 14	 mov	 DWORD PTR [ebx+20], esi
  000d6	50		 push	 eax
  000d7	8b cb		 mov	 ecx, ebx
  000d9	c6 03 00	 mov	 BYTE PTR [ebx], 0
  000dc	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000e1	6a 00		 push	 0
  000e3	6a 01		 push	 1
  000e5	8d 4d b4	 lea	 ecx, DWORD PTR _strMD5$[ebp]
  000e8	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  000ed	8b c3		 mov	 eax, ebx

; 250  : }

  000ef	e8 00 00 00 00	 call	 __EH_epilog3_GS
  000f4	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Final@CMD5Checksum@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0:
  00000	8d 4d b4	 lea	 ecx, DWORD PTR _strMD5$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Final@CMD5Checksum@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Final@CMD5Checksum@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Final@CMD5Checksum@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; CMD5Checksum::Final
PUBLIC	?GetMD5@CMD5Checksum@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEI@Z ; CMD5Checksum::GetMD5
;	COMDAT xdata$x
; File f:\projects\git\yfnet\trunk\src\include\md5.h
xdata$x	SEGMENT
__unwindtable$?GetMD5@CMD5Checksum@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMD5@CMD5Checksum@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEI@Z$0
__ehfuncinfo$?GetMD5@CMD5Checksum@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetMD5@CMD5Checksum@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\qvodbase\md5.cpp
xdata$x	ENDS
;	COMDAT ?GetMD5@CMD5Checksum@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEI@Z
_TEXT	SEGMENT
$T53901 = -112						; size = 4
_MD5Checksum$ = -108					; size = 92
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_pBuf$ = 12						; size = 4
_nLength$ = 16						; size = 4
?GetMD5@CMD5Checksum@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEI@Z PROC ; CMD5Checksum::GetMD5, COMDAT

; 28   : {

  00000	6a 64		 push	 100			; 00000064H
  00002	b8 00 00 00 00	 mov	 eax, __ehhandler$?GetMD5@CMD5Checksum@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEI@Z
  00007	e8 00 00 00 00	 call	 __EH_prolog3_GS
  0000c	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000f	8b 7d 0c	 mov	 edi, DWORD PTR _pBuf$[ebp]
  00012	83 65 90 00	 and	 DWORD PTR $T53901[ebp], 0

; 29   : 	
; 30   : 	//calculate and return the checksum
; 31   : 	CMD5Checksum MD5Checksum;

  00016	8d 4d 94	 lea	 ecx, DWORD PTR _MD5Checksum$[ebp]
  00019	e8 00 00 00 00	 call	 ??0CMD5Checksum@@IAE@XZ	; CMD5Checksum::CMD5Checksum

; 32   : 	MD5Checksum.Update( pBuf, nLength );

  0001e	ff 75 10	 push	 DWORD PTR _nLength$[ebp]
  00021	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00025	57		 push	 edi
  00026	8d 4d 94	 lea	 ecx, DWORD PTR _MD5Checksum$[ebp]
  00029	e8 00 00 00 00	 call	 ?Update@CMD5Checksum@@IAEXPAEK@Z ; CMD5Checksum::Update

; 33   : 	return MD5Checksum.Final();

  0002e	56		 push	 esi
  0002f	8d 4d 94	 lea	 ecx, DWORD PTR _MD5Checksum$[ebp]
  00032	e8 00 00 00 00	 call	 ?Final@CMD5Checksum@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CMD5Checksum::Final
  00037	8b c6		 mov	 eax, esi

; 34   : }

  00039	e8 00 00 00 00	 call	 __EH_epilog3_GS
  0003e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMD5@CMD5Checksum@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEI@Z$0:
  00000	8d 4d 94	 lea	 ecx, DWORD PTR _MD5Checksum$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMD5Checksum@@MAE@XZ	; CMD5Checksum::~CMD5Checksum
__ehhandler$?GetMD5@CMD5Checksum@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEI@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a 8c	 mov	 ecx, DWORD PTR [edx-116]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetMD5@CMD5Checksum@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEI@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetMD5@CMD5Checksum@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEI@Z ENDP ; CMD5Checksum::GetMD5
END
