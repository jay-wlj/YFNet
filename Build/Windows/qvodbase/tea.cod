; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	F:\Projects\Git\YFNet\trunk\Src\qvodbase\tea.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_szDefaultKey DB 0deH
	DB	049H
	DB	07dH
	DB	083H
	DB	0f9H
	DB	0aeH
	DB	034H
	DB	0b8H
	DB	0c4H
	DB	095H
	DB	024H
	DB	0ffH
	DB	00H
	DB	018H
	DB	0afH
	DB	0deH
_g_szIpListKey DB 017H
	DB	085H
	DB	074H
	DB	056H
	DB	098H
	DB	012H
	DB	094H
	DB	0faH
	DB	0a1H
	DB	0e7H
	DB	02bH
	DB	045H
	DB	0cdH
	DB	01cH
	DB	032H
	DB	04aH
_DATA	ENDS
PUBLIC	?SetKey@Tea@@QAEXPAE@Z				; Tea::SetKey
EXTRN	_memcpy:PROC
; Function compile flags: /Ogsp
; File f:\projects\git\yfnet\trunk\src\qvodbase\tea.cpp
;	COMDAT ?SetKey@Tea@@QAEXPAE@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?SetKey@Tea@@QAEXPAE@Z PROC				; Tea::SetKey, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 27   : 	memcpy(m_szKey,key,16);

  00003	6a 10		 push	 16			; 00000010H
  00005	ff 75 08	 push	 DWORD PTR _key$[ebp]
  00008	51		 push	 ecx
  00009	e8 00 00 00 00	 call	 _memcpy
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28   : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?SetKey@Tea@@QAEXPAE@Z ENDP				; Tea::SetKey
_TEXT	ENDS
PUBLIC	?RetKey@Tea@@QAEXXZ				; Tea::RetKey
; Function compile flags: /Ogsp
;	COMDAT ?RetKey@Tea@@QAEXXZ
_TEXT	SEGMENT
?RetKey@Tea@@QAEXXZ PROC				; Tea::RetKey, COMDAT
; _this$ = ecx

; 32   : 	memcpy(m_szKey,g_szDefaultKey,16);

  00000	6a 10		 push	 16			; 00000010H
  00002	68 00 00 00 00	 push	 OFFSET _g_szDefaultKey
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _memcpy
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 33   : }

  00010	c3		 ret	 0
?RetKey@Tea@@QAEXXZ ENDP				; Tea::RetKey
_TEXT	ENDS
PUBLIC	?encrypt@Tea@@QAEXPAEH_N1@Z			; Tea::encrypt
; Function compile flags: /Ogsp
;	COMDAT ?encrypt@Tea@@QAEXPAEH_N1@Z
_TEXT	SEGMENT
_c$ = -16						; size = 4
_d$ = -12						; size = 4
_a$ = -8						; size = 4
_b$ = -4						; size = 4
_pPos$ = 8						; size = 4
_pData$ = 8						; size = 4
_z$3606 = 12						; size = 4
_len$ = 12						; size = 4
_round$3609 = 16					; size = 4
_y$3604 = 16						; size = 4
_bUsingPublicKey$ = 16					; size = 1
tv156 = 20						; size = 4
_bLimitLen$ = 20					; size = 1
?encrypt@Tea@@QAEXPAEH_N1@Z PROC			; Tea::encrypt, COMDAT
; _this$ = ecx

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 37   : 	unsigned long *k = 0;
; 38   : 	if ( bUsingPublicKey )

  00006	80 7d 10 00	 cmp	 BYTE PTR _bUsingPublicKey$[ebp], 0

; 39   : 	{
; 40   : 		k = (unsigned long *)g_szDefaultKey;

  0000a	b8 00 00 00 00	 mov	 eax, OFFSET _g_szDefaultKey
  0000f	75 02		 jne	 SHORT $LN6@encrypt

; 41   : 	}
; 42   : 	else
; 43   : 	{
; 44   : 		k = (unsigned long*)m_szKey;

  00011	8b c1		 mov	 eax, ecx
$LN6@encrypt:

; 45   : 	}
; 46   : 	register unsigned long a = k[0];
; 47   : 	register unsigned long b = k[1];
; 48   : 	register unsigned long c = k[2];
; 49   : 	register unsigned long d = k[3];
; 50   : 	register unsigned long delta = 0x9E3779B9; /* (sqrt(5)-1)/2*2^32 */
; 51   : 
; 52   : 	unsigned char *pPos = pData;
; 53   : 	int iMinLen = sizeof(long) * 2;
; 54   : 	if (bLimitLen)

  00013	80 7d 14 00	 cmp	 BYTE PTR _bLimitLen$[ebp], 0
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	89 4d f8	 mov	 DWORD PTR _a$[ebp], ecx
  0001c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001f	89 4d fc	 mov	 DWORD PTR _b$[ebp], ecx
  00022	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00025	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00028	56		 push	 esi
  00029	8b 75 08	 mov	 esi, DWORD PTR _pData$[ebp]
  0002c	89 45 f4	 mov	 DWORD PTR _d$[ebp], eax

; 55   : 	{
; 56   : 		len = min(len,MAX_CODE_LENGTH);

  0002f	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00032	89 4d f0	 mov	 DWORD PTR _c$[ebp], ecx
  00035	89 75 08	 mov	 DWORD PTR _pPos$[ebp], esi
  00038	74 0b		 je	 SHORT $LN11@encrypt
  0003a	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0003f	3b c1		 cmp	 eax, ecx
  00041	7c 02		 jl	 SHORT $LN11@encrypt
  00043	8b c1		 mov	 eax, ecx
$LN11@encrypt:

; 57   : 	}
; 58   : 	while ( len >= iMinLen )

  00045	83 f8 08	 cmp	 eax, 8
  00048	0f 8c 8d 00 00
	00		 jl	 $LN3@encrypt
  0004e	c1 e8 03	 shr	 eax, 3
  00051	89 45 14	 mov	 DWORD PTR tv156[ebp], eax
  00054	57		 push	 edi
$LL4@encrypt:

; 59   : 	{
; 60   : 		register unsigned long sum = 0;
; 61   : 		register unsigned long y = *(unsigned long *)pPos;

  00055	8b 06		 mov	 eax, DWORD PTR [esi]

; 62   : 		register unsigned long z = *(unsigned long *)(pPos+sizeof(unsigned long));

  00057	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005a	33 d2		 xor	 edx, edx

; 63   : 		register int round = 16;

  0005c	c7 45 10 10 00
	00 00		 mov	 DWORD PTR _round$3609[ebp], 16 ; 00000010H
$LL2@encrypt:

; 64   : 
; 65   : 		while (round--) 

  00063	ff 4d 10	 dec	 DWORD PTR _round$3609[ebp]

; 66   : 		{	/* basic cycle start */
; 67   : 			sum += delta;
; 68   : 			y += ((z << 4) + a) ^ (z + sum) ^ ((z >> 5) + b);

  00066	8b f1		 mov	 esi, ecx
  00068	c1 ee 05	 shr	 esi, 5
  0006b	03 75 fc	 add	 esi, DWORD PTR _b$[ebp]
  0006e	8b f9		 mov	 edi, ecx
  00070	c1 e7 04	 shl	 edi, 4
  00073	03 7d f8	 add	 edi, DWORD PTR _a$[ebp]
  00076	81 ea 47 86 c8
	61		 sub	 edx, 1640531527		; 61c88647H
  0007c	33 f7		 xor	 esi, edi
  0007e	8d 3c 11	 lea	 edi, DWORD PTR [ecx+edx]
  00081	33 f7		 xor	 esi, edi
  00083	03 c6		 add	 eax, esi

; 69   : 			z += ((y << 4) + c) ^ (y + sum) ^ ((y >> 5) + d);

  00085	8b f0		 mov	 esi, eax
  00087	c1 ee 05	 shr	 esi, 5
  0008a	03 75 f4	 add	 esi, DWORD PTR _d$[ebp]
  0008d	8b f8		 mov	 edi, eax
  0008f	c1 e7 04	 shl	 edi, 4
  00092	03 7d f0	 add	 edi, DWORD PTR _c$[ebp]
  00095	33 f7		 xor	 esi, edi
  00097	8d 3c 10	 lea	 edi, DWORD PTR [eax+edx]
  0009a	33 f7		 xor	 esi, edi
  0009c	03 ce		 add	 ecx, esi
  0009e	83 7d 10 00	 cmp	 DWORD PTR _round$3609[ebp], 0
  000a2	75 bf		 jne	 SHORT $LL2@encrypt

; 70   : 		}	/* end cycle */
; 71   : 		memcpy(pPos,&y,sizeof(y));

  000a4	8b 75 08	 mov	 esi, DWORD PTR _pPos$[ebp]
  000a7	89 45 10	 mov	 DWORD PTR _y$3604[ebp], eax
  000aa	6a 04		 push	 4
  000ac	8d 45 10	 lea	 eax, DWORD PTR _y$3604[ebp]
  000af	50		 push	 eax
  000b0	56		 push	 esi
  000b1	89 4d 0c	 mov	 DWORD PTR _z$3606[ebp], ecx
  000b4	e8 00 00 00 00	 call	 _memcpy

; 72   : 		memcpy(pPos+sizeof(y),&z,sizeof(y));

  000b9	6a 04		 push	 4
  000bb	8d 45 0c	 lea	 eax, DWORD PTR _z$3606[ebp]
  000be	50		 push	 eax
  000bf	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 _memcpy

; 73   : 		pPos = pPos + sizeof(y) + sizeof(z);

  000c8	83 c6 08	 add	 esi, 8
  000cb	83 c4 18	 add	 esp, 24			; 00000018H
  000ce	ff 4d 14	 dec	 DWORD PTR tv156[ebp]
  000d1	89 75 08	 mov	 DWORD PTR _pPos$[ebp], esi
  000d4	0f 85 7b ff ff
	ff		 jne	 $LL4@encrypt
  000da	5f		 pop	 edi
$LN3@encrypt:
  000db	5e		 pop	 esi

; 74   : 		len -= sizeof(y)+sizeof(z);
; 75   : 	}
; 76   : }

  000dc	c9		 leave
  000dd	c2 10 00	 ret	 16			; 00000010H
?encrypt@Tea@@QAEXPAEH_N1@Z ENDP			; Tea::encrypt
_TEXT	ENDS
PUBLIC	?decrypt@Tea@@QAEXPAEH_N1@Z			; Tea::decrypt
; Function compile flags: /Ogsp
;	COMDAT ?decrypt@Tea@@QAEXPAEH_N1@Z
_TEXT	SEGMENT
_a$ = -16						; size = 4
_b$ = -12						; size = 4
_c$ = -8						; size = 4
_d$ = -4						; size = 4
_pPos$ = 8						; size = 4
_pData$ = 8						; size = 4
_z$3641 = 12						; size = 4
_len$ = 12						; size = 4
_y$3639 = 16						; size = 4
_round$3637 = 16					; size = 4
_bUsingPublicKey$ = 16					; size = 1
tv156 = 20						; size = 4
_bLimitLen$ = 20					; size = 1
?decrypt@Tea@@QAEXPAEH_N1@Z PROC			; Tea::decrypt, COMDAT
; _this$ = ecx

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 80   : 	unsigned long *k = 0;
; 81   : 	if ( bUsingPublicKey )

  00006	80 7d 10 00	 cmp	 BYTE PTR _bUsingPublicKey$[ebp], 0

; 82   : 	{
; 83   : 		k = (unsigned long *)g_szDefaultKey;

  0000a	b8 00 00 00 00	 mov	 eax, OFFSET _g_szDefaultKey
  0000f	75 02		 jne	 SHORT $LN6@decrypt

; 84   : 	}
; 85   : 	else
; 86   : 	{
; 87   : 		k = (unsigned long*)m_szKey;

  00011	8b c1		 mov	 eax, ecx
$LN6@decrypt:

; 88   : 	}
; 89   : 	register unsigned long a = k[0];
; 90   : 	register unsigned long b = k[1];
; 91   : 	register unsigned long c = k[2];
; 92   : 	register unsigned long d = k[3];
; 93   : 	register unsigned long delta = 0x9E3779B9;
; 94   : 
; 95   : 	unsigned char *pPos = pData;
; 96   : 	int iMinLen = sizeof(long) * 2;
; 97   : 	if (bLimitLen)

  00013	80 7d 14 00	 cmp	 BYTE PTR _bLimitLen$[ebp], 0
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	89 4d f0	 mov	 DWORD PTR _a$[ebp], ecx
  0001c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001f	89 4d f4	 mov	 DWORD PTR _b$[ebp], ecx
  00022	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00025	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00028	56		 push	 esi
  00029	8b 75 08	 mov	 esi, DWORD PTR _pData$[ebp]
  0002c	89 45 fc	 mov	 DWORD PTR _d$[ebp], eax

; 98   : 	{
; 99   : 		len = min(len,MAX_CODE_LENGTH);

  0002f	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00032	89 4d f8	 mov	 DWORD PTR _c$[ebp], ecx
  00035	89 75 08	 mov	 DWORD PTR _pPos$[ebp], esi
  00038	74 0b		 je	 SHORT $LN11@decrypt
  0003a	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0003f	3b c1		 cmp	 eax, ecx
  00041	7c 02		 jl	 SHORT $LN11@decrypt
  00043	8b c1		 mov	 eax, ecx
$LN11@decrypt:

; 100  : 	}
; 101  : 	while ( len >= iMinLen )

  00045	83 f8 08	 cmp	 eax, 8
  00048	0f 8c 90 00 00
	00		 jl	 $LN3@decrypt
  0004e	c1 e8 03	 shr	 eax, 3
  00051	89 45 14	 mov	 DWORD PTR tv156[ebp], eax
  00054	57		 push	 edi
$LL4@decrypt:

; 102  : 	{
; 103  : 		register int round = 16;
; 104  : 		register unsigned long sum = 0xE3779B90;
; 105  : 		register unsigned long y = *(unsigned long *)pPos;

  00055	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 106  : 		register unsigned long z = *(unsigned long *)(pPos+sizeof(unsigned long));

  00057	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0005a	c7 45 10 10 00
	00 00		 mov	 DWORD PTR _round$3637[ebp], 16 ; 00000010H
  00061	ba 90 9b 77 e3	 mov	 edx, -478700656		; e3779b90H
$LL2@decrypt:

; 107  : 
; 108  : 		while (round--)

  00066	ff 4d 10	 dec	 DWORD PTR _round$3637[ebp]

; 109  : 		{
; 110  : 			z -= ((y << 4) + c) ^ (y + sum) ^ ((y >> 5) + d);

  00069	8b f1		 mov	 esi, ecx
  0006b	c1 ee 05	 shr	 esi, 5
  0006e	03 75 fc	 add	 esi, DWORD PTR _d$[ebp]
  00071	8b f9		 mov	 edi, ecx
  00073	c1 e7 04	 shl	 edi, 4
  00076	03 7d f8	 add	 edi, DWORD PTR _c$[ebp]
  00079	33 f7		 xor	 esi, edi
  0007b	8d 3c 11	 lea	 edi, DWORD PTR [ecx+edx]
  0007e	33 f7		 xor	 esi, edi
  00080	2b c6		 sub	 eax, esi

; 111  : 			y -= ((z << 4) + a) ^ (z + sum) ^ ((z >> 5) + b);

  00082	8b f0		 mov	 esi, eax
  00084	c1 ee 05	 shr	 esi, 5
  00087	03 75 f4	 add	 esi, DWORD PTR _b$[ebp]
  0008a	8b f8		 mov	 edi, eax
  0008c	c1 e7 04	 shl	 edi, 4
  0008f	03 7d f0	 add	 edi, DWORD PTR _a$[ebp]
  00092	33 f7		 xor	 esi, edi
  00094	8d 3c 10	 lea	 edi, DWORD PTR [eax+edx]
  00097	33 f7		 xor	 esi, edi
  00099	2b ce		 sub	 ecx, esi

; 112  : 			sum -= delta;

  0009b	81 c2 47 86 c8
	61		 add	 edx, 1640531527		; 61c88647H
  000a1	83 7d 10 00	 cmp	 DWORD PTR _round$3637[ebp], 0
  000a5	75 bf		 jne	 SHORT $LL2@decrypt

; 113  : 		}
; 114  : 		memcpy(pPos,&y,sizeof(y));

  000a7	8b 75 08	 mov	 esi, DWORD PTR _pPos$[ebp]
  000aa	89 45 0c	 mov	 DWORD PTR _z$3641[ebp], eax
  000ad	6a 04		 push	 4
  000af	8d 45 10	 lea	 eax, DWORD PTR _y$3639[ebp]
  000b2	50		 push	 eax
  000b3	56		 push	 esi
  000b4	89 4d 10	 mov	 DWORD PTR _y$3639[ebp], ecx
  000b7	e8 00 00 00 00	 call	 _memcpy

; 115  : 		memcpy(pPos+sizeof(y),&z,sizeof(z));

  000bc	6a 04		 push	 4
  000be	8d 45 0c	 lea	 eax, DWORD PTR _z$3641[ebp]
  000c1	50		 push	 eax
  000c2	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _memcpy

; 116  : 
; 117  : 		pPos += sizeof(y) + sizeof(z);

  000cb	83 c6 08	 add	 esi, 8
  000ce	83 c4 18	 add	 esp, 24			; 00000018H
  000d1	ff 4d 14	 dec	 DWORD PTR tv156[ebp]
  000d4	89 75 08	 mov	 DWORD PTR _pPos$[ebp], esi
  000d7	0f 85 78 ff ff
	ff		 jne	 $LL4@decrypt
  000dd	5f		 pop	 edi
$LN3@decrypt:
  000de	5e		 pop	 esi

; 118  : 		len -= sizeof(y) + sizeof(z);
; 119  : 	}
; 120  : }

  000df	c9		 leave
  000e0	c2 10 00	 ret	 16			; 00000010H
?decrypt@Tea@@QAEXPAEH_N1@Z ENDP			; Tea::decrypt
_TEXT	ENDS
PUBLIC	?Encrypt@Tea@@QAEXPAEH@Z			; Tea::Encrypt
; Function compile flags: /Ogsp
;	COMDAT ?Encrypt@Tea@@QAEXPAEH@Z
_TEXT	SEGMENT
_c$ = -24						; size = 4
_d$ = -20						; size = 4
_a$ = -16						; size = 4
_b$ = -12						; size = 4
tv131 = -8						; size = 4
_round$3671 = -4					; size = 4
_z$3668 = -4						; size = 4
_y$3666 = 8						; size = 4
_sum$3665 = 8						; size = 4
_pData$ = 8						; size = 4
_len$ = 12						; size = 4
?Encrypt@Tea@@QAEXPAEH@Z PROC				; Tea::Encrypt, COMDAT
; _this$ = ecx

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 126  : 	register unsigned long b = k[1];
; 127  : 	register unsigned long c = k[2];
; 128  : 	register unsigned long d = k[3];
; 129  : 	register unsigned long delta = 0x9E3779B9; /* (sqrt(5)-1)/2*2^32 */
; 130  : 
; 131  : 	unsigned char *pPos = pData;
; 132  : 	int iMinLen = sizeof(long) * 2;
; 133  : 	while ( len >= iMinLen )

  00006	83 7d 0c 08	 cmp	 DWORD PTR _len$[ebp], 8
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_szIpListKey
  0000f	89 45 f0	 mov	 DWORD PTR _a$[ebp], eax
  00012	a1 04 00 00 00	 mov	 eax, DWORD PTR _g_szIpListKey+4
  00017	89 45 f4	 mov	 DWORD PTR _b$[ebp], eax
  0001a	a1 08 00 00 00	 mov	 eax, DWORD PTR _g_szIpListKey+8
  0001f	89 45 e8	 mov	 DWORD PTR _c$[ebp], eax
  00022	a1 0c 00 00 00	 mov	 eax, DWORD PTR _g_szIpListKey+12
  00027	56		 push	 esi
  00028	8b 75 08	 mov	 esi, DWORD PTR _pData$[ebp]
  0002b	89 45 ec	 mov	 DWORD PTR _d$[ebp], eax
  0002e	0f 8c 97 00 00
	00		 jl	 $LN11@Encrypt

; 124  : 	unsigned long *k =(unsigned long*)g_szIpListKey;
; 125  : 	register unsigned long a = k[0];

  00034	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00037	c1 e8 03	 shr	 eax, 3
  0003a	89 45 f8	 mov	 DWORD PTR tv131[ebp], eax

; 126  : 	register unsigned long b = k[1];
; 127  : 	register unsigned long c = k[2];
; 128  : 	register unsigned long d = k[3];
; 129  : 	register unsigned long delta = 0x9E3779B9; /* (sqrt(5)-1)/2*2^32 */
; 130  : 
; 131  : 	unsigned char *pPos = pData;
; 132  : 	int iMinLen = sizeof(long) * 2;
; 133  : 	while ( len >= iMinLen )

  0003d	6b c0 f8	 imul	 eax, -8			; fffffff8H
  00040	01 45 0c	 add	 DWORD PTR _len$[ebp], eax
  00043	57		 push	 edi
$LL6@Encrypt:

; 134  : 	{
; 135  : 		register unsigned long sum = 0;

  00044	83 65 08 00	 and	 DWORD PTR _sum$3665[ebp], 0

; 136  : 		register unsigned long y = *(unsigned long *)pPos;

  00048	8b 06		 mov	 eax, DWORD PTR [esi]

; 137  : 		register unsigned long z = *(unsigned long *)(pPos+sizeof(unsigned long));

  0004a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 138  : 		register int round = 16;

  0004d	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR _round$3671[ebp], 16 ; 00000010H
$LL4@Encrypt:

; 139  : 
; 140  : 		while (round--) 
; 141  : 		{	/* basic cycle start */
; 142  : 			sum += delta;

  00054	81 6d 08 47 86
	c8 61		 sub	 DWORD PTR _sum$3665[ebp], 1640531527 ; 61c88647H
  0005b	ff 4d fc	 dec	 DWORD PTR _round$3671[ebp]

; 143  : 			y += ((z << 4) + a) ^ (z + sum) ^ ((z >> 5) + b);

  0005e	8b d1		 mov	 edx, ecx
  00060	c1 ea 05	 shr	 edx, 5
  00063	03 55 f4	 add	 edx, DWORD PTR _b$[ebp]
  00066	8b f9		 mov	 edi, ecx
  00068	c1 e7 04	 shl	 edi, 4
  0006b	03 7d f0	 add	 edi, DWORD PTR _a$[ebp]
  0006e	33 d7		 xor	 edx, edi
  00070	8b 7d 08	 mov	 edi, DWORD PTR _sum$3665[ebp]
  00073	03 f9		 add	 edi, ecx
  00075	33 d7		 xor	 edx, edi
  00077	03 c2		 add	 eax, edx

; 144  : 			z += ((y << 4) + c) ^ (y + sum) ^ ((y >> 5) + d);

  00079	8b d0		 mov	 edx, eax
  0007b	c1 ea 05	 shr	 edx, 5
  0007e	03 55 ec	 add	 edx, DWORD PTR _d$[ebp]
  00081	8b f8		 mov	 edi, eax
  00083	c1 e7 04	 shl	 edi, 4
  00086	03 7d e8	 add	 edi, DWORD PTR _c$[ebp]
  00089	33 d7		 xor	 edx, edi
  0008b	8b 7d 08	 mov	 edi, DWORD PTR _sum$3665[ebp]
  0008e	03 f8		 add	 edi, eax
  00090	33 d7		 xor	 edx, edi
  00092	03 ca		 add	 ecx, edx
  00094	83 7d fc 00	 cmp	 DWORD PTR _round$3671[ebp], 0
  00098	75 ba		 jne	 SHORT $LL4@Encrypt

; 145  : 		}	/* end cycle */
; 146  : 		memcpy(pPos,&y,sizeof(y));

  0009a	89 45 08	 mov	 DWORD PTR _y$3666[ebp], eax
  0009d	6a 04		 push	 4
  0009f	8d 45 08	 lea	 eax, DWORD PTR _y$3666[ebp]
  000a2	50		 push	 eax
  000a3	56		 push	 esi
  000a4	89 4d fc	 mov	 DWORD PTR _z$3668[ebp], ecx
  000a7	e8 00 00 00 00	 call	 _memcpy

; 147  : 		memcpy(pPos+sizeof(y),&z,sizeof(y));

  000ac	6a 04		 push	 4
  000ae	8d 45 fc	 lea	 eax, DWORD PTR _z$3668[ebp]
  000b1	50		 push	 eax
  000b2	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _memcpy
  000bb	83 c4 18	 add	 esp, 24			; 00000018H

; 148  : 		pPos = pPos + sizeof(y) + sizeof(z);

  000be	83 c6 08	 add	 esi, 8
  000c1	ff 4d f8	 dec	 DWORD PTR tv131[ebp]
  000c4	0f 85 7a ff ff
	ff		 jne	 $LL6@Encrypt
  000ca	5f		 pop	 edi
$LN11@Encrypt:

; 149  : 		len -= sizeof(y)+sizeof(z);
; 150  : 	}
; 151  : 	while(len)

  000cb	83 7d 0c 00	 cmp	 DWORD PTR _len$[ebp], 0
  000cf	74 09		 je	 SHORT $LN1@Encrypt
$LL2@Encrypt:

; 152  : 	{
; 153  : 		*pPos -= 0x40;

  000d1	80 06 c0	 add	 BYTE PTR [esi], 192	; 000000c0H

; 154  : 		++pPos;

  000d4	46		 inc	 esi

; 155  : 		--len;

  000d5	ff 4d 0c	 dec	 DWORD PTR _len$[ebp]
  000d8	75 f7		 jne	 SHORT $LL2@Encrypt
$LN1@Encrypt:
  000da	5e		 pop	 esi

; 156  : 	}
; 157  : }

  000db	c9		 leave
  000dc	c2 08 00	 ret	 8
?Encrypt@Tea@@QAEXPAEH@Z ENDP				; Tea::Encrypt
_TEXT	ENDS
PUBLIC	?Decrypt@Tea@@QAEXPAEH@Z			; Tea::Decrypt
; Function compile flags: /Ogsp
;	COMDAT ?Decrypt@Tea@@QAEXPAEH@Z
_TEXT	SEGMENT
_a$ = -24						; size = 4
_b$ = -20						; size = 4
_c$ = -16						; size = 4
_d$ = -12						; size = 4
tv139 = -8						; size = 4
_z$3700 = -4						; size = 4
_round$3696 = -4					; size = 4
_y$3698 = 8						; size = 4
_sum$3697 = 8						; size = 4
_pData$ = 8						; size = 4
_len$ = 12						; size = 4
?Decrypt@Tea@@QAEXPAEH@Z PROC				; Tea::Decrypt, COMDAT
; _this$ = ecx

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 163  : 	register unsigned long b = k[1];
; 164  : 	register unsigned long c = k[2];
; 165  : 	register unsigned long d = k[3];
; 166  : 	register unsigned long delta = 0x9E3779B9;
; 167  : 
; 168  : 	unsigned char *pPos = pData;
; 169  : 	int iMinLen = sizeof(long) * 2;
; 170  : 	while ( len >= iMinLen )

  00006	83 7d 0c 08	 cmp	 DWORD PTR _len$[ebp], 8
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_szIpListKey
  0000f	89 45 e8	 mov	 DWORD PTR _a$[ebp], eax
  00012	a1 04 00 00 00	 mov	 eax, DWORD PTR _g_szIpListKey+4
  00017	89 45 ec	 mov	 DWORD PTR _b$[ebp], eax
  0001a	a1 08 00 00 00	 mov	 eax, DWORD PTR _g_szIpListKey+8
  0001f	89 45 f0	 mov	 DWORD PTR _c$[ebp], eax
  00022	a1 0c 00 00 00	 mov	 eax, DWORD PTR _g_szIpListKey+12
  00027	56		 push	 esi
  00028	8b 75 08	 mov	 esi, DWORD PTR _pData$[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR _d$[ebp], eax
  0002e	0f 8c 9a 00 00
	00		 jl	 $LN11@Decrypt

; 161  : 	unsigned long *k = (unsigned long*)g_szIpListKey;
; 162  : 	register unsigned long a = k[0];

  00034	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00037	c1 e8 03	 shr	 eax, 3
  0003a	89 45 f8	 mov	 DWORD PTR tv139[ebp], eax

; 163  : 	register unsigned long b = k[1];
; 164  : 	register unsigned long c = k[2];
; 165  : 	register unsigned long d = k[3];
; 166  : 	register unsigned long delta = 0x9E3779B9;
; 167  : 
; 168  : 	unsigned char *pPos = pData;
; 169  : 	int iMinLen = sizeof(long) * 2;
; 170  : 	while ( len >= iMinLen )

  0003d	6b c0 f8	 imul	 eax, -8			; fffffff8H
  00040	01 45 0c	 add	 DWORD PTR _len$[ebp], eax
  00043	57		 push	 edi
$LL6@Decrypt:

; 171  : 	{
; 172  : 		register int round = 16;
; 173  : 		register unsigned long sum = 0xE3779B90;
; 174  : 		register unsigned long y = *(unsigned long *)pPos;

  00044	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 175  : 		register unsigned long z = *(unsigned long *)(pPos+sizeof(unsigned long));

  00046	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00049	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR _round$3696[ebp], 16 ; 00000010H
  00050	c7 45 08 90 9b
	77 e3		 mov	 DWORD PTR _sum$3697[ebp], -478700656 ; e3779b90H
$LL4@Decrypt:

; 176  : 
; 177  : 		while (round--)

  00057	ff 4d fc	 dec	 DWORD PTR _round$3696[ebp]

; 178  : 		{
; 179  : 			z -= ((y << 4) + c) ^ (y + sum) ^ ((y >> 5) + d);

  0005a	8b d1		 mov	 edx, ecx
  0005c	c1 ea 05	 shr	 edx, 5
  0005f	03 55 f4	 add	 edx, DWORD PTR _d$[ebp]
  00062	8b f9		 mov	 edi, ecx
  00064	c1 e7 04	 shl	 edi, 4
  00067	03 7d f0	 add	 edi, DWORD PTR _c$[ebp]
  0006a	33 d7		 xor	 edx, edi
  0006c	8b 7d 08	 mov	 edi, DWORD PTR _sum$3697[ebp]
  0006f	03 f9		 add	 edi, ecx
  00071	33 d7		 xor	 edx, edi
  00073	2b c2		 sub	 eax, edx

; 180  : 			y -= ((z << 4) + a) ^ (z + sum) ^ ((z >> 5) + b);

  00075	8b d0		 mov	 edx, eax
  00077	c1 ea 05	 shr	 edx, 5
  0007a	03 55 ec	 add	 edx, DWORD PTR _b$[ebp]
  0007d	8b f8		 mov	 edi, eax
  0007f	c1 e7 04	 shl	 edi, 4
  00082	03 7d e8	 add	 edi, DWORD PTR _a$[ebp]
  00085	33 d7		 xor	 edx, edi
  00087	8b 7d 08	 mov	 edi, DWORD PTR _sum$3697[ebp]

; 181  : 			sum -= delta;

  0008a	81 45 08 47 86
	c8 61		 add	 DWORD PTR _sum$3697[ebp], 1640531527 ; 61c88647H
  00091	03 f8		 add	 edi, eax
  00093	33 d7		 xor	 edx, edi
  00095	2b ca		 sub	 ecx, edx
  00097	83 7d fc 00	 cmp	 DWORD PTR _round$3696[ebp], 0
  0009b	75 ba		 jne	 SHORT $LL4@Decrypt

; 182  : 		}
; 183  : 		memcpy(pPos,&y,sizeof(y));

  0009d	89 45 fc	 mov	 DWORD PTR _z$3700[ebp], eax
  000a0	6a 04		 push	 4
  000a2	8d 45 08	 lea	 eax, DWORD PTR _y$3698[ebp]
  000a5	50		 push	 eax
  000a6	56		 push	 esi
  000a7	89 4d 08	 mov	 DWORD PTR _y$3698[ebp], ecx
  000aa	e8 00 00 00 00	 call	 _memcpy

; 184  : 		memcpy(pPos+sizeof(y),&z,sizeof(z));

  000af	6a 04		 push	 4
  000b1	8d 45 fc	 lea	 eax, DWORD PTR _z$3700[ebp]
  000b4	50		 push	 eax
  000b5	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _memcpy
  000be	83 c4 18	 add	 esp, 24			; 00000018H

; 185  : 
; 186  : 		pPos += sizeof(y) + sizeof(z);

  000c1	83 c6 08	 add	 esi, 8
  000c4	ff 4d f8	 dec	 DWORD PTR tv139[ebp]
  000c7	0f 85 77 ff ff
	ff		 jne	 $LL6@Decrypt
  000cd	5f		 pop	 edi
$LN11@Decrypt:

; 187  : 		len -= sizeof(y) + sizeof(z);
; 188  : 	}
; 189  : 	while(len)

  000ce	83 7d 0c 00	 cmp	 DWORD PTR _len$[ebp], 0
  000d2	74 09		 je	 SHORT $LN1@Decrypt
$LL2@Decrypt:

; 190  : 	{
; 191  : 		*pPos += 0x40;

  000d4	80 06 40	 add	 BYTE PTR [esi], 64	; 00000040H

; 192  : 		++pPos;

  000d7	46		 inc	 esi

; 193  : 		--len;

  000d8	ff 4d 0c	 dec	 DWORD PTR _len$[ebp]
  000db	75 f7		 jne	 SHORT $LL2@Decrypt
$LN1@Decrypt:
  000dd	5e		 pop	 esi

; 194  : 	}
; 195  : }

  000de	c9		 leave
  000df	c2 08 00	 ret	 8
?Decrypt@Tea@@QAEXPAEH@Z ENDP				; Tea::Decrypt
_TEXT	ENDS
PUBLIC	?EncryptTask@Tea@@QAEXPAEHPAD@Z			; Tea::EncryptTask
; Function compile flags: /Ogsp
;	COMDAT ?EncryptTask@Tea@@QAEXPAEHPAD@Z
_TEXT	SEGMENT
_z$3731 = -24						; size = 4
_c$ = -20						; size = 4
_d$ = -16						; size = 4
_a$ = -12						; size = 4
_b$ = -8						; size = 4
tv133 = -4						; size = 4
_pPos$ = 8						; size = 4
_pData$ = 8						; size = 4
_len$ = 12						; size = 4
_round$3734 = 16					; size = 4
_y$3729 = 16						; size = 4
_pKey$ = 16						; size = 4
?EncryptTask@Tea@@QAEXPAEHPAD@Z PROC			; Tea::EncryptTask, COMDAT
; _this$ = ecx

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 199  : 	unsigned long *k =(unsigned long*)pKey;
; 200  : 	register unsigned long a = k[0];

  00006	8b 45 10	 mov	 eax, DWORD PTR _pKey$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d f4	 mov	 DWORD PTR _a$[ebp], ecx

; 201  : 	register unsigned long b = k[1];

  0000e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00011	89 4d f8	 mov	 DWORD PTR _b$[ebp], ecx

; 202  : 	register unsigned long c = k[2];

  00014	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 203  : 	register unsigned long d = k[3];

  00017	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0001a	89 45 f0	 mov	 DWORD PTR _d$[ebp], eax

; 204  : 	register unsigned long delta = 0x9E3779B9; /* (sqrt(5)-1)/2*2^32 */
; 205  : 
; 206  : 	len = min(len,1024);

  0001d	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  00022	89 4d ec	 mov	 DWORD PTR _c$[ebp], ecx
  00025	39 45 0c	 cmp	 DWORD PTR _len$[ebp], eax
  00028	7c 03		 jl	 SHORT $LN10@EncryptTas
  0002a	89 45 0c	 mov	 DWORD PTR _len$[ebp], eax
$LN10@EncryptTas:

; 208  : 	int iMinLen = sizeof(long) * 2;
; 209  : 	while ( len >= iMinLen )

  0002d	83 7d 0c 08	 cmp	 DWORD PTR _len$[ebp], 8
  00031	56		 push	 esi
  00032	8b 75 08	 mov	 esi, DWORD PTR _pData$[ebp]
  00035	89 75 08	 mov	 DWORD PTR _pPos$[ebp], esi
  00038	0f 8c 96 00 00
	00		 jl	 $LN13@EncryptTas

; 207  : 	unsigned char *pPos = pData;

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00041	c1 e8 03	 shr	 eax, 3
  00044	89 45 fc	 mov	 DWORD PTR tv133[ebp], eax

; 208  : 	int iMinLen = sizeof(long) * 2;
; 209  : 	while ( len >= iMinLen )

  00047	6b c0 f8	 imul	 eax, -8			; fffffff8H
  0004a	01 45 0c	 add	 DWORD PTR _len$[ebp], eax
  0004d	57		 push	 edi
$LL6@EncryptTas:

; 210  : 	{
; 211  : 		register unsigned long sum = 0;
; 212  : 		register unsigned long y = *(unsigned long *)pPos;

  0004e	8b 06		 mov	 eax, DWORD PTR [esi]

; 213  : 		register unsigned long z = *(unsigned long *)(pPos+sizeof(unsigned long));

  00050	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00053	33 d2		 xor	 edx, edx

; 214  : 		register int round = 16;

  00055	c7 45 10 10 00
	00 00		 mov	 DWORD PTR _round$3734[ebp], 16 ; 00000010H
$LL4@EncryptTas:

; 215  : 
; 216  : 		while (round--) 

  0005c	ff 4d 10	 dec	 DWORD PTR _round$3734[ebp]

; 217  : 		{	/* basic cycle start */
; 218  : 			sum += delta;
; 219  : 			y += ((z << 4) + a) ^ (z + sum) ^ ((z >> 5) + b);

  0005f	8b f1		 mov	 esi, ecx
  00061	c1 ee 05	 shr	 esi, 5
  00064	03 75 f8	 add	 esi, DWORD PTR _b$[ebp]
  00067	8b f9		 mov	 edi, ecx
  00069	c1 e7 04	 shl	 edi, 4
  0006c	03 7d f4	 add	 edi, DWORD PTR _a$[ebp]
  0006f	81 ea 47 86 c8
	61		 sub	 edx, 1640531527		; 61c88647H
  00075	33 f7		 xor	 esi, edi
  00077	8d 3c 11	 lea	 edi, DWORD PTR [ecx+edx]
  0007a	33 f7		 xor	 esi, edi
  0007c	03 c6		 add	 eax, esi

; 220  : 			z += ((y << 4) + c) ^ (y + sum) ^ ((y >> 5) + d);

  0007e	8b f0		 mov	 esi, eax
  00080	c1 ee 05	 shr	 esi, 5
  00083	03 75 f0	 add	 esi, DWORD PTR _d$[ebp]
  00086	8b f8		 mov	 edi, eax
  00088	c1 e7 04	 shl	 edi, 4
  0008b	03 7d ec	 add	 edi, DWORD PTR _c$[ebp]
  0008e	33 f7		 xor	 esi, edi
  00090	8d 3c 10	 lea	 edi, DWORD PTR [eax+edx]
  00093	33 f7		 xor	 esi, edi
  00095	03 ce		 add	 ecx, esi
  00097	83 7d 10 00	 cmp	 DWORD PTR _round$3734[ebp], 0
  0009b	75 bf		 jne	 SHORT $LL4@EncryptTas

; 221  : 		}	/* end cycle */
; 222  : 		memcpy(pPos,&y,sizeof(y));

  0009d	8b 75 08	 mov	 esi, DWORD PTR _pPos$[ebp]
  000a0	89 45 10	 mov	 DWORD PTR _y$3729[ebp], eax
  000a3	6a 04		 push	 4
  000a5	8d 45 10	 lea	 eax, DWORD PTR _y$3729[ebp]
  000a8	50		 push	 eax
  000a9	56		 push	 esi
  000aa	89 4d e8	 mov	 DWORD PTR _z$3731[ebp], ecx
  000ad	e8 00 00 00 00	 call	 _memcpy

; 223  : 		memcpy(pPos+sizeof(y),&z,sizeof(y));

  000b2	6a 04		 push	 4
  000b4	8d 45 e8	 lea	 eax, DWORD PTR _z$3731[ebp]
  000b7	50		 push	 eax
  000b8	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _memcpy

; 224  : 		pPos = pPos + sizeof(y) + sizeof(z);

  000c1	83 c6 08	 add	 esi, 8
  000c4	83 c4 18	 add	 esp, 24			; 00000018H
  000c7	ff 4d fc	 dec	 DWORD PTR tv133[ebp]
  000ca	89 75 08	 mov	 DWORD PTR _pPos$[ebp], esi
  000cd	0f 85 7b ff ff
	ff		 jne	 $LL6@EncryptTas
  000d3	5f		 pop	 edi
$LN13@EncryptTas:

; 225  : 		len -= sizeof(y)+sizeof(z);
; 226  : 	}
; 227  : 	while(len)

  000d4	83 7d 0c 00	 cmp	 DWORD PTR _len$[ebp], 0
  000d8	74 09		 je	 SHORT $LN1@EncryptTas
$LL2@EncryptTas:

; 228  : 	{
; 229  : 		*pPos -= 0x40;

  000da	80 06 c0	 add	 BYTE PTR [esi], 192	; 000000c0H

; 230  : 		++pPos;

  000dd	46		 inc	 esi

; 231  : 		--len;

  000de	ff 4d 0c	 dec	 DWORD PTR _len$[ebp]
  000e1	75 f7		 jne	 SHORT $LL2@EncryptTas
$LN1@EncryptTas:
  000e3	5e		 pop	 esi

; 232  : 	}
; 233  : }

  000e4	c9		 leave
  000e5	c2 0c 00	 ret	 12			; 0000000cH
?EncryptTask@Tea@@QAEXPAEHPAD@Z ENDP			; Tea::EncryptTask
_TEXT	ENDS
PUBLIC	?DecryptTask@Tea@@QAEXPAEHPAD@Z			; Tea::DecryptTask
; Function compile flags: /Ogsp
;	COMDAT ?DecryptTask@Tea@@QAEXPAEHPAD@Z
_TEXT	SEGMENT
_z$3764 = -24						; size = 4
_a$ = -20						; size = 4
_b$ = -16						; size = 4
_c$ = -12						; size = 4
_d$ = -8						; size = 4
tv141 = -4						; size = 4
_pPos$ = 8						; size = 4
_pData$ = 8						; size = 4
_len$ = 12						; size = 4
_y$3762 = 16						; size = 4
_round$3760 = 16					; size = 4
_pKey$ = 16						; size = 4
?DecryptTask@Tea@@QAEXPAEHPAD@Z PROC			; Tea::DecryptTask, COMDAT
; _this$ = ecx

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 237  : 	unsigned long *k = (unsigned long*)pKey;
; 238  : 	register unsigned long a = k[0];

  00006	8b 45 10	 mov	 eax, DWORD PTR _pKey$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d ec	 mov	 DWORD PTR _a$[ebp], ecx

; 239  : 	register unsigned long b = k[1];

  0000e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00011	89 4d f0	 mov	 DWORD PTR _b$[ebp], ecx

; 240  : 	register unsigned long c = k[2];

  00014	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 241  : 	register unsigned long d = k[3];

  00017	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0001a	89 45 f8	 mov	 DWORD PTR _d$[ebp], eax

; 242  : 	register unsigned long delta = 0x9E3779B9;
; 243  : 
; 244  : 	len = min(len,1024);

  0001d	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  00022	89 4d f4	 mov	 DWORD PTR _c$[ebp], ecx
  00025	39 45 0c	 cmp	 DWORD PTR _len$[ebp], eax
  00028	7c 03		 jl	 SHORT $LN10@DecryptTas
  0002a	89 45 0c	 mov	 DWORD PTR _len$[ebp], eax
$LN10@DecryptTas:

; 246  : 	int iMinLen = sizeof(long) * 2;
; 247  : 	while ( len >= iMinLen )

  0002d	83 7d 0c 08	 cmp	 DWORD PTR _len$[ebp], 8
  00031	56		 push	 esi
  00032	8b 75 08	 mov	 esi, DWORD PTR _pData$[ebp]
  00035	89 75 08	 mov	 DWORD PTR _pPos$[ebp], esi
  00038	0f 8c 99 00 00
	00		 jl	 $LN13@DecryptTas

; 245  : 	unsigned char *pPos = pData;

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00041	c1 e8 03	 shr	 eax, 3
  00044	89 45 fc	 mov	 DWORD PTR tv141[ebp], eax

; 246  : 	int iMinLen = sizeof(long) * 2;
; 247  : 	while ( len >= iMinLen )

  00047	6b c0 f8	 imul	 eax, -8			; fffffff8H
  0004a	01 45 0c	 add	 DWORD PTR _len$[ebp], eax
  0004d	57		 push	 edi
$LL6@DecryptTas:

; 248  : 	{
; 249  : 		register int round = 16;
; 250  : 		register unsigned long sum = 0xE3779B90;
; 251  : 		register unsigned long y = *(unsigned long *)pPos;

  0004e	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 252  : 		register unsigned long z = *(unsigned long *)(pPos+sizeof(unsigned long));

  00050	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00053	c7 45 10 10 00
	00 00		 mov	 DWORD PTR _round$3760[ebp], 16 ; 00000010H
  0005a	ba 90 9b 77 e3	 mov	 edx, -478700656		; e3779b90H
$LL4@DecryptTas:

; 253  : 
; 254  : 		while (round--)

  0005f	ff 4d 10	 dec	 DWORD PTR _round$3760[ebp]

; 255  : 		{
; 256  : 			z -= ((y << 4) + c) ^ (y + sum) ^ ((y >> 5) + d);

  00062	8b f1		 mov	 esi, ecx
  00064	c1 ee 05	 shr	 esi, 5
  00067	03 75 f8	 add	 esi, DWORD PTR _d$[ebp]
  0006a	8b f9		 mov	 edi, ecx
  0006c	c1 e7 04	 shl	 edi, 4
  0006f	03 7d f4	 add	 edi, DWORD PTR _c$[ebp]
  00072	33 f7		 xor	 esi, edi
  00074	8d 3c 11	 lea	 edi, DWORD PTR [ecx+edx]
  00077	33 f7		 xor	 esi, edi
  00079	2b c6		 sub	 eax, esi

; 257  : 			y -= ((z << 4) + a) ^ (z + sum) ^ ((z >> 5) + b);

  0007b	8b f0		 mov	 esi, eax
  0007d	c1 ee 05	 shr	 esi, 5
  00080	03 75 f0	 add	 esi, DWORD PTR _b$[ebp]
  00083	8b f8		 mov	 edi, eax
  00085	c1 e7 04	 shl	 edi, 4
  00088	03 7d ec	 add	 edi, DWORD PTR _a$[ebp]
  0008b	33 f7		 xor	 esi, edi
  0008d	8d 3c 10	 lea	 edi, DWORD PTR [eax+edx]
  00090	33 f7		 xor	 esi, edi
  00092	2b ce		 sub	 ecx, esi

; 258  : 			sum -= delta;

  00094	81 c2 47 86 c8
	61		 add	 edx, 1640531527		; 61c88647H
  0009a	83 7d 10 00	 cmp	 DWORD PTR _round$3760[ebp], 0
  0009e	75 bf		 jne	 SHORT $LL4@DecryptTas

; 259  : 		}
; 260  : 		memcpy(pPos,&y,sizeof(y));

  000a0	8b 75 08	 mov	 esi, DWORD PTR _pPos$[ebp]
  000a3	89 45 e8	 mov	 DWORD PTR _z$3764[ebp], eax
  000a6	6a 04		 push	 4
  000a8	8d 45 10	 lea	 eax, DWORD PTR _y$3762[ebp]
  000ab	50		 push	 eax
  000ac	56		 push	 esi
  000ad	89 4d 10	 mov	 DWORD PTR _y$3762[ebp], ecx
  000b0	e8 00 00 00 00	 call	 _memcpy

; 261  : 		memcpy(pPos+sizeof(y),&z,sizeof(z));

  000b5	6a 04		 push	 4
  000b7	8d 45 e8	 lea	 eax, DWORD PTR _z$3764[ebp]
  000ba	50		 push	 eax
  000bb	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _memcpy

; 262  : 
; 263  : 		pPos += sizeof(y) + sizeof(z);

  000c4	83 c6 08	 add	 esi, 8
  000c7	83 c4 18	 add	 esp, 24			; 00000018H
  000ca	ff 4d fc	 dec	 DWORD PTR tv141[ebp]
  000cd	89 75 08	 mov	 DWORD PTR _pPos$[ebp], esi
  000d0	0f 85 78 ff ff
	ff		 jne	 $LL6@DecryptTas
  000d6	5f		 pop	 edi
$LN13@DecryptTas:

; 264  : 		len -= sizeof(y) + sizeof(z);
; 265  : 	}
; 266  : 	while(len)

  000d7	83 7d 0c 00	 cmp	 DWORD PTR _len$[ebp], 0
  000db	74 09		 je	 SHORT $LN1@DecryptTas
$LL2@DecryptTas:

; 267  : 	{
; 268  : 		*pPos += 0x40;

  000dd	80 06 40	 add	 BYTE PTR [esi], 64	; 00000040H

; 269  : 		++pPos;

  000e0	46		 inc	 esi

; 270  : 		--len;

  000e1	ff 4d 0c	 dec	 DWORD PTR _len$[ebp]
  000e4	75 f7		 jne	 SHORT $LL2@DecryptTas
$LN1@DecryptTas:
  000e6	5e		 pop	 esi

; 271  : 	}
; 272  : }

  000e7	c9		 leave
  000e8	c2 0c 00	 ret	 12			; 0000000cH
?DecryptTask@Tea@@QAEXPAEHPAD@Z ENDP			; Tea::DecryptTask
_TEXT	ENDS
END
